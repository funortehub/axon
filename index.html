<!DOCTYPE html>
<html lang="pt-br">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">
    <title>Axon</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <link rel="manifest" href="/manifest.json">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" id="status-bar-style-meta" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Axon">
    <link rel="apple-touch-icon" href="https://i.imgur.com/ZsfZEh2.png">
    <meta name="theme-color" id="theme-color-meta" content="#1a202c">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
        :root {
            --bg-gradient: linear-gradient(135deg, #1a202c, #2d3748);
            --glass-bg: rgba(28, 35, 49, 0.65);
            --glass-border: rgba(255, 255, 255, 0.18);
            --glass-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.37);
            --text-color: #e2e8f0;
            --header-text-color: #f7fafc;
            --prompt-color: #63b3ed;
            --command-color: #90cdf4;
            --output-color: #e2e8f0;
            --error-color: #fc8181;
            --success-color: #68d391;
            --border-color: rgba(255, 255, 255, 0.1);
            --highlight-color: #4299e1;
            --highlight-text-color: #ffffff;
            --diagnosis-color: #b794f4;
            --conduct-color: #68d391;
            --altered-color: #faf089;
            --input-bg: rgba(0, 0, 0, 0.2);
            --terminal-header-bg: rgba(0, 0, 0, 0.2);
            --button-bg: rgba(255, 255, 255, 0.1);
            --button-hover-bg: rgba(255, 255, 255, 0.2);
            --free-mode-bg: rgba(0, 0, 0, 0.2)
        }

        body.light-mode {
            --bg-gradient: linear-gradient(135deg, #f0f9ff, #e0f2fe);
            --glass-bg: rgba(255, 255, 255, 0.5);
            --glass-border: rgba(0, 0, 0, 0.1);
            --glass-shadow: 0 8px 32px 0 rgba(100, 100, 100, 0.2);
            --text-color: #2d3748;
            --header-text-color: #1a202c;
            --prompt-color: #2b6cb0;
            --command-color: #2c5282;
            --output-color: #2d3748;
            --error-color: #c53030;
            --success-color: #2f855a;
            --border-color: rgba(0, 0, 0, 0.1);
            --highlight-color: #3182ce;
            --highlight-text-color: #ffffff;
            --diagnosis-color: #805ad5;
            --conduct-color: #2f855a;
            --altered-color: #d69e2e;
            --input-bg: rgba(0, 0, 0, 0.05);
            --terminal-header-bg: rgba(0, 0, 0, 0.05);
            --button-bg: rgba(0, 0, 0, 0.05);
            --button-hover-bg: rgba(0, 0, 0, 0.1);
            --free-mode-bg: #f7f9fc
        }

        body.light-mode .terminal-logo-internal {
            filter: invert(1);
            opacity: 0.15;
            /* Slightly increase opacity for better visibility */
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: Consolas, 'Courier New', monospace;
            touch-action: manipulation;
            user-select: none;
            /* Disable text selection for native app feel */
            -webkit-user-select: none;
        }

        /* Allow selection in inputs and editable areas */
        input,
        textarea,
        [contenteditable] {
            user-select: text;
            -webkit-user-select: text;
        }

        body {
            background: var(--bg-gradient);
            background-attachment: fixed;
            color: var(--text-color);
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            transition: background .5s ease, color .5s ease
        }

        .header {
            background: var(--glass-bg);
            backdrop-filter: blur(15px);
            -webkit-backdrop-filter: blur(15px);
            padding: 12px 20px;
            border-bottom: 1px solid var(--glass-border);
            display: flex;
            align-items: center;
            justify-content: space-between;
            position: relative;
            height: 65px;
            flex-shrink: 0
        }

        .header-right {
            display: flex;
            align-items: center;
            gap: 10px
        }

        .logout-button,
        .settings-button,
        .theme-toggle {
            color: var(--text-color);
            font-size: 20px;
            cursor: pointer;
            transition: color .3s ease, transform .2s ease, background-color .3s ease;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%
        }

        .logout-button:hover,
        .settings-button:hover,
        .theme-toggle:hover {
            color: var(--highlight-color);
            background-color: var(--button-hover-bg);
            transform: scale(1.1)
        }

        .logout-button:hover {
            color: var(--error-color)
        }

        .app-title {
            font-size: 22px;
            font-weight: 700;
            color: var(--header-text-color);
            text-shadow: 0 1px 2px rgba(0, 0, 0, .1)
        }

        .status-bar {
            display: flex;
            gap: 15px;
            font-size: 14px;
            background: var(--input-bg);
            padding: 5px 15px;
            border-radius: 20px;
            border: 1px solid var(--border-color)
        }

        .status-item {
            display: flex;
            align-items: center;
            gap: 5px
        }

        .status-indicator {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background-color: var(--success-color);
            box-shadow: 0 0 5px var(--success-color)
        }

        .status-off {
            background-color: var(--error-color);
            box-shadow: 0 0 5px var(--error-color)
        }

        .container {
            display: flex;
            flex: 1;
            padding: 20px;
            gap: 20px;
            height: calc(100vh - 65px - 40px);
            min-height: 0
        }

        .terminal {
            background: var(--glass-bg);
            backdrop-filter: blur(15px);
            -webkit-backdrop-filter: blur(15px);
            border: 1px solid var(--glass-border);
            border-radius: 16px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            box-shadow: var(--glass-shadow);
            position: relative
        }

        .terminal-header {
            padding: 8px 12px;
            background-color: var(--terminal-header-bg);
            border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            justify-content: space-between
        }

        .terminal-title {
            font-size: 14px;
            font-weight: 700
        }

        .terminal-actions {
            display: flex;
            gap: 8px
        }

        .terminal-btn {
            width: 12px;
            height: 12px;
            border-radius: 50%
        }

        .close-btn {
            background-color: #ff5f56
        }

        .minimize-btn {
            background-color: #ffbd2e
        }

        .maximize-btn {
            background-color: #27c93f
        }

        .terminal-content {
            flex: 1;
            overflow-y: auto;
            padding: 15px;
            display: flex;
            flex-direction: column;
            gap: 10px
        }

        .terminal-content::-webkit-scrollbar {
            width: 8px
        }

        .terminal-content::-webkit-scrollbar-track {
            background: 0 0
        }

        .terminal-content::-webkit-scrollbar-thumb {
            background-color: var(--button-hover-bg);
            border-radius: 10px;
            border: 2px solid transparent;
            background-clip: content-box
        }

        .terminal-content::-webkit-scrollbar-thumb:hover {
            background-color: var(--highlight-color)
        }

        .interactive-terminal,
        .non-interactive-terminal {
            flex: 1;
            min-width: 300px;
            min-height: 0
        }

        .input-line {
            display: flex;
            align-items: center;
            gap: 8px
        }

        .prompt {
            color: var(--prompt-color);
            white-space: nowrap
        }

        .command-input {
            background: 0 0;
            border: none;
            color: var(--command-color);
            width: 100%;
            font-size: 16px;
            caret-color: var(--command-color);
            outline: 0;
            padding: 2px 0
        }

        .command-output {
            color: var(--output-color);
            white-space: pre-wrap;
            line-height: 1.5;
            text-align: left
        }

        .command {
            color: var(--command-color);
            font-weight: 700
        }

        .error {
            color: var(--error-color)
        }

        .success {
            color: var(--success-color)
        }

        .technical-log {
            opacity: 0.7;
            font-size: 0.9em;
            border-left: 2px solid var(--border-color);
            padding-left: 5px;
            margin: 2px 0;
        }

        .hide-technical-logs .technical-log {
            display: none !important;
        }

        .info {
            color: var(--prompt-color)
        }

        .highlight {
            color: var(--highlight-color)
        }

        .blocked-msg {
            color: var(--altered-color)
        }

        .anamnesis-content {
            line-height: 1.8;
            font-size: 15px
        }

        .section-title {
            font-weight: 700;
            margin-top: 10px;
            color: var(--highlight-color)
        }

        .help-list {
            padding-left: 0;
            margin: 10px 0;
            line-height: 1.8;
            list-style: none
        }

        .help-item {
            margin-bottom: 5px
        }

        .diagnosis-item {
            color: var(--diagnosis-color);
            margin-bottom: 8px;
            padding-left: 15px;
            position: relative
        }

        .diagnosis-item:before {
            content: "â€¢";
            position: absolute;
            left: 0;
            color: var(--diagnosis-color)
        }

        .conduct-section {
            margin-bottom: 15px
        }

        .conduct-title {
            color: var(--conduct-color);
            font-weight: 700;
            margin-bottom: 5px;
            border-bottom: 1px solid var(--conduct-color);
            padding-bottom: 3px;
            cursor: pointer;
            transition: color .2s, border-bottom-color .2s
        }

        .conduct-title:hover {
            color: var(--highlight-color);
            border-bottom-color: var(--highlight-color)
        }

        .conduct-item {
            margin-bottom: 8px;
            padding-left: 15px;
            position: relative
        }

        .conduct-item:before {
            content: "-";
            position: absolute;
            left: 0
        }

        .receituario-item {
            white-space: pre;
            font-family: 'Courier New', monospace;
            color: var(--output-color);
            margin-bottom: 5px
        }

        .footer {
            background: var(--glass-bg);
            backdrop-filter: blur(15px);
            -webkit-backdrop-filter: blur(15px);
            padding: 10px 20px;
            border-top: 1px solid var(--glass-border);
            text-align: center;
            font-size: 12px;
            color: var(--text-color);
            height: 40px;
            flex-shrink: 0
        }

        .terminal-logo-internal {
            position: absolute;
            top: 15px;
            right: 15px;
            height: calc(105.3px * 1.8 * .7 * 1.2);
            width: auto;
            opacity: .1;
            z-index: 0
        }

        .monitor-view {
            text-transform: uppercase;
            height: 100%
        }

        .monitor-view .axon-eye-title,
        .monitor-view .conduct-title,
        .monitor-view .section-title {
            text-transform: none
        }

        .camera-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: transparent;
            z-index: 100;
            flex-direction: column;
            justify-content: flex-start;
            align-items: center;
            padding: 0
        }

        .camera-container {
            display: flex;
            flex-direction: column;
            background: var(--glass-bg);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid var(--glass-border);
            border-radius: 16px;
            position: relative;
            z-index: 1;
            padding: 0;
            gap: 10px;
            overflow: hidden;
            width: 100%;
            height: 100%;
            max-width: none;
            max-height: none
        }

        .camera-video-wrapper {
            position: relative;
            width: 100%;
            padding-bottom: 177.77%;
            background-color: #000;
            border-radius: 10px;
            overflow: hidden;
            flex-shrink: 0
        }

        .camera-video {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            height: 100%;
            object-fit: cover
        }

        #axon-web-access-blocked-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #000;
            z-index: 2147483647;
            /* Max Z-Index to stay on top of everything */
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            padding: 20px;
            color: #fff;
        }

        #axon-web-access-blocked-overlay img {
            width: 150px;
            height: 150px;
            margin-bottom: 20px;
            filter: drop-shadow(0 0 10px rgba(255, 0, 0, 0.5));
        }

        #axon-web-access-blocked-overlay h1 {
            font-size: 24px;
            margin-bottom: 10px;
            color: #ff5f56;
        }

        #axon-web-access-blocked-overlay p {
            font-size: 16px;
            line-height: 1.6;
            max-width: 600px;
        }

        .camera-controls {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
            z-index: 2;
            width: 90%
        }

        .camera-button {
            background-color: rgba(0, 0, 0, .5);
            color: #fff;
            border: 1px solid rgba(255, 255, 255, .2);
            padding: 10px 15px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 18px;
            transition: background-color .3s ease, transform .2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 50px;
            height: 50px;
            flex-shrink: 0;
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px)
        }

        .camera-button:hover {
            background-color: var(--highlight-color);
            transform: scale(1.05)
        }

        .camera-button.disabled {
            background-color: #555;
            cursor: not-allowed;
            opacity: .7
        }

        .album-button,
        .camera-action-buttons {
            position: absolute;
            top: 10px;
            display: flex;
            gap: 5px;
            z-index: 10;
            background-color: rgba(0, 0, 0, .4);
            border: 1px solid var(--border-color);
            border-radius: 20px;
            padding: 5px 10px;
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px)
        }

        .album-button {
            left: 10px
        }

        .camera-action-buttons {
            right: 10px
        }

        .camera-switch-button,
        .flashlight-button {
            background-color: transparent;
            color: #fff;
            border: none;
            cursor: pointer;
            font-size: 12px;
            transition: color .2s
        }

        .album-button:hover,
        .camera-switch-button:hover,
        .flashlight-button:hover {
            color: var(--highlight-color)
        }

        .flashlight-button.active {
            color: var(--highlight-color)
        }

        .album-count {
            background-color: var(--highlight-color);
            color: var(--highlight-text-color);
            border-radius: 50%;
            padding: 2px 6px;
            font-size: 10px;
            font-weight: 700;
            min-width: 18px;
            text-align: center
        }

        .monitor-toggle-buttons {
            display: flex;
            gap: 5px;
            margin-left: auto;
            margin-right: 10px
        }

        .monitor-toggle-button {
            background-color: var(--button-bg);
            color: var(--text-color);
            border: 1px solid var(--border-color);
            padding: 5px 10px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 12px;
            transition: all .3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 5px
        }

        .monitor-toggle-button:hover {
            background-color: var(--button-hover-bg)
        }

        .monitor-toggle-button.active {
            background-color: var(--highlight-color);
            color: var(--highlight-text-color);
            border-color: transparent
        }

        #monitor-content-wrapper {
            position: relative
        }

        .monitor-copy-btn {
            position: absolute;
            top: 50px;
            right: 25px;
            background: var(--button-bg);
            color: var(--text-color);
            border: 1px solid var(--border-color);
            padding: 5px 10px;
            border-radius: 50%;
            width: 35px;
            height: 35px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 14px;
            transition: all .3s ease;
            z-index: 5
        }

        .monitor-copy-btn:hover {
            background-color: var(--highlight-color);
            color: var(--highlight-text-color)
        }

        .fullscreen-modal {
            display: none;
            position: fixed;
            z-index: 2000;
            padding-top: 60px;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0, 0, 0, .9)
        }

        .modal-content {
            margin: auto;
            display: block;
            width: 80%;
            max-width: 700px;
            border-radius: 10px
        }

        #caption,
        .modal-content {
            animation-name: zoom;
            animation-duration: .6s
        }

        @keyframes zoom {
            from {
                transform: scale(0)
            }

            to {
                transform: scale(1)
            }
        }

        .modal-close {
            position: absolute;
            top: 15px;
            right: 35px;
            color: #f1f1f1;
            font-size: 40px;
            font-weight: 700;
            transition: .3s
        }

        .modal-close:focus,
        .modal-close:hover {
            color: #bbb;
            text-decoration: none;
            cursor: pointer
        }

        .output .altered-text {
            color: var(--altered-color);
            font-weight: 700;
            margin-left: 10px
        }

        .album-modal,
        .app-modal,
        .patient-details-modal,
        .patient-list-modal {
            display: none;
            position: fixed;
            z-index: 105;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0, 0, 0, .5);
            justify-content: center;
            align-items: center
        }

        .album-modal-content,
        .app-modal-content,
        .patient-details-content,
        .patient-list-content {
            background: var(--glass-bg);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            margin: auto;
            padding: 25px;
            border: 1px solid var(--glass-border);
            border-radius: 16px;
            width: 90%;
            max-width: 500px;
            box-shadow: var(--glass-shadow);
            position: relative;
            display: flex;
            flex-direction: column;
            max-height: 90vh
        }

        .app-modal-body {
            flex: 1;
            overflow-y: auto;
            padding-right: 5px;
            /* Prevent scrollbar overlap */
        }

        .album-modal-content,
        .patient-details-content,
        .patient-list-content {
            max-width: 800px
        }

        .album-modal-header,
        .app-modal-header,
        .patient-details-header,
        .patient-list-header {
            display: flex;
            align-items: center;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 15px;
            margin-bottom: 20px
        }

        .album-modal-title,
        .app-modal-title,
        .patient-details-title,
        .patient-list-title {
            font-size: 20px;
            font-weight: 700;
            color: var(--prompt-color)
        }

        .album-modal-close,
        .app-modal-close,
        .patient-details-close,
        .patient-list-close {
            color: var(--text-color);
            font-size: 28px;
            font-weight: 700;
            cursor: pointer;
            transition: .3s;
            position: absolute;
            top: 15px;
            right: 20px
        }

        .album-modal-close:hover,
        .app-modal-close:hover,
        .patient-details-close:hover,
        .patient-list-close:hover {
            color: var(--highlight-color)
        }

        .album-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
            gap: 15px;
            overflow-y: auto;
            padding-right: 5px
        }

        .album-item {
            position: relative;
            width: 100%;
            padding-bottom: 100%;
            overflow: hidden;
            border: 1px solid var(--border-color);
            border-radius: 10px;
            cursor: pointer;
            transition: transform .2s ease
        }

        .album-item:hover {
            transform: scale(1.03)
        }

        .album-image {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            display: block
        }

        .album-delete-button {
            position: absolute;
            top: 5px;
            right: 5px;
            background-color: rgba(255, 0, 0, .7);
            color: #fff;
            border: none;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            font-size: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 10;
            transition: background-color .2s
        }

        .album-delete-button:hover {
            background-color: rgba(255, 0, 0, 1)
        }

        .axon-eye-title {
            color: var(--error-color);
            font-weight: 700;
            margin-top: 10px;
            margin-bottom: 5px;
            border-bottom: 1px solid var(--error-color);
            padding-bottom: 3px
        }

        .axon-eye-image-preview {
            max-width: 100%;
            height: auto;
            margin-top: 15px;
            border: 1px solid var(--border-color);
            border-radius: 10px
        }

        .patient-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
            overflow-y: auto;
            max-height: 400px
        }

        .patient-item {
            padding: 12px;
            background-color: var(--button-bg);
            border: 1px solid var(--border-color);
            border-radius: 10px;
            cursor: pointer;
            transition: background-color .2s
        }

        .patient-item:hover {
            background-color: var(--button-hover-bg)
        }

        .patient-details-body {
            overflow-y: auto;
            padding-right: 5px
        }

        .patient-details-section {
            margin-bottom: 20px
        }

        .patient-details-section-title {
            font-weight: 700;
            color: var(--highlight-color);
            margin-bottom: 10px;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 5px
        }

        .patient-images-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
            gap: 10px;
            margin-top: 10px
        }

        .patient-image-item {
            position: relative;
            width: 100%;
            padding-bottom: 100%;
            overflow: hidden;
            border: 1px solid var(--border-color);
            border-radius: 10px;
            cursor: pointer
        }

        .patient-image {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            display: block
        }

        .consultation-item {
            background-color: var(--input-bg);
            border: 1px solid var(--border-color);
            border-radius: 10px;
            margin-bottom: 10px;
            overflow: hidden
        }

        .consultation-header {
            padding: 10px 15px;
            cursor: pointer;
            font-weight: 700;
            transition: background-color .2s
        }

        .consultation-header:hover {
            background-color: var(--button-hover-bg)
        }

        .consultation-body {
            padding: 15px;
            border-top: 1px solid var(--border-color);
            background-color: transparent
        }

        .patient-actions {
            display: flex;
            gap: 10px;
            margin-top: 10px
        }

        .patient-action-button {
            background-color: var(--button-bg);
            color: var(--text-color);
            border: 1px solid var(--border-color);
            padding: 8px 12px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 12px;
            transition: all .3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 5px;
            flex: 1
        }

        .patient-action-button.disabled {
            background-color: var(--input-bg);
            color: var(--text-color);
            cursor: not-allowed;
            opacity: .5
        }

        .patient-action-button:not(.disabled):hover {
            background-color: var(--button-hover-bg)
        }

        .patient-action-button.delete:not(.disabled) {
            color: var(--error-color)
        }

        .patient-action-button.delete:not(.disabled):hover {
            background-color: var(--error-color);
            color: #fff
        }

        .patient-action-button.pdf:not(.disabled) {
            color: var(--success-color)
        }

        .patient-action-button.pdf:not(.disabled):hover {
            background-color: var(--success-color);
            color: #fff
        }

        .patient-action-button.details:not(.disabled) {
            color: var(--prompt-color)
        }

        .patient-action-button.details:not(.disabled):hover {
            background-color: var(--prompt-color);
            color: #fff
        }

        .patient-search-container {
            margin-bottom: 15px
        }

        .patient-search-input {
            width: 100%;
            padding: 12px;
            background-color: var(--input-bg);
            color: var(--text-color);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            font-size: 14px
        }

        .patient-search-input:focus {
            outline: 0;
            border-color: var(--highlight-color)
        }

        .terminal-footer {
            padding: 8px 15px;
            border-top: 1px solid var(--border-color);
            background-color: var(--terminal-header-bg)
        }

        .action-buttons-container {
            display: flex;
            justify-content: space-around;
            margin-bottom: 10px
        }

        .action-button {
            background-color: var(--button-bg);
            color: var(--text-color);
            border: 1px solid var(--border-color);
            border-radius: 50%;
            width: 44px;
            height: 44px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            cursor: pointer;
            transition: all .2s, transform .1s
        }

        .action-button:focus,
        .action-button:hover {
            background-color: var(--highlight-color);
            color: var(--highlight-text-color);
            outline: 0
        }

        .action-button:active {
            transform: scale(.95)
        }

        .action-button.active {
            background-color: var(--success-color);
            color: var(--highlight-text-color);
            box-shadow: 0 0 8px var(--success-color)
        }

        .action-button.blocked-ui {
            opacity: .4;
            cursor: not-allowed
        }

        .app-modal-body p {
            margin-bottom: 20px;
            color: var(--text-color)
        }

        .app-modal-input {
            width: 100%;
            padding: 12px;
            margin-bottom: 15px;
            background-color: var(--input-bg);
            color: var(--text-color);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            font-size: 16px
        }

        .app-modal-input:focus {
            outline: 0;
            border-color: var(--highlight-color)
        }

        .app-modal-button {
            width: 100%;
            padding: 12px;
            background-color: var(--highlight-color);
            color: var(--highlight-text-color);
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 700;
            transition: background-color .3s ease
        }

        body.light-mode .app-modal-button:hover {
            background-color: #2b6cb0
        }

        body:not(.light-mode) .app-modal-button:hover {
            background-color: #63b3ed
        }

        .app-modal-button:disabled {
            background-color: #555;
            cursor: not-allowed
        }

        .app-modal-feedback {
            margin-top: 15px;
            color: var(--error-color);
            min-height: 20px
        }

        .admin-section {
            margin-bottom: 20px;
            text-align: left;
            border: 1px solid var(--border-color);
            padding: 15px;
            border-radius: 10px
        }

        .admin-section-title {
            color: var(--prompt-color);
            font-weight: 700;
            margin-bottom: 10px;
            font-size: 14px;
            text-transform: uppercase
        }

        .admin-list {
            display: flex;
            flex-direction: column;
            gap: 8px
        }

        .admin-list-item {
            display: flex;
            gap: 8px;
            align-items: center
        }

        .admin-input-group {
            flex: 1;
            display: flex;
            gap: 5px
        }

        .admin-input {
            flex: 1;
            padding: 8px;
            background-color: var(--input-bg);
            color: var(--text-color);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            font-size: 12px
        }

        .admin-action-btn,
        .admin-btn-add,
        .admin-btn-remove {
            border-radius: 8px
        }

        #admin-panel-modal .app-modal-content {
            max-width: 900px;
            width: 95%;
            height: 85vh;
            display: flex;
            flex-direction: column
        }

        .admin-tab-content {
            flex: 1;
            overflow-y: auto;
            padding-bottom: 15px;
            display: flex;
            flex-direction: column
        }

        .admin-users-container {
            display: flex;
            flex: 1;
            min-height: 0;
            gap: 20px;
            text-align: left;
            overflow: hidden
        }

        .admin-users-list-section {
            flex: 1;
            border-right: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            padding-right: 10px
        }

        .admin-users-details-section {
            flex: 2;
            overflow-y: auto;
            padding-left: 10px
        }

        .user-list-scroll {
            overflow-y: auto;
            flex: 1
        }

        .user-list-item {
            padding: 10px;
            cursor: pointer;
            border-bottom: 1px solid var(--border-color);
            transition: background-color .2s;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-radius: 8px;
            margin-bottom: 5px
        }

        .user-list-item:hover {
            background-color: var(--button-hover-bg)
        }

        .user-list-item.selected {
            background-color: rgba(66, 153, 225, .2);
            border-left: 3px solid var(--highlight-color)
        }

        .user-detail-header {
            margin-bottom: 15px;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 10px
        }

        .user-detail-row {
            margin-bottom: 10px
        }

        .user-detail-label {
            color: var(--prompt-color);
            font-weight: 700;
            font-size: 12px;
            display: block;
            margin-bottom: 2px
        }

        .user-detail-value {
            color: var(--text-color);
            font-size: 14px
        }

        .admin-user-images {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
            gap: 10px;
            margin-top: 10px
        }

        .admin-user-img {
            width: 100%;
            height: 80px;
            object-fit: cover;
            border-radius: 8px;
            cursor: pointer;
            border: 1px solid var(--border-color);
            transition: transform .2s
        }

        .admin-user-img:hover {
            transform: scale(1.05)
        }

        .usage-stats-box {
            background-color: var(--input-bg);
            border: 1px solid var(--border-color);
            padding: 10px;
            border-radius: 10px;
            margin-top: 10px
        }

        .admin-tabs {
            display: flex;
            border-bottom: 1px solid var(--border-color);
            margin-bottom: 15px
        }

        .admin-tab-btn {
            flex: 1;
            background: 0 0;
            border: none;
            color: var(--text-color);
            padding: 10px;
            cursor: pointer;
            border-bottom: 3px solid transparent;
            font-size: 14px;
            transition: all .3s ease
        }

        .admin-tab-btn:hover {
            background-color: var(--button-hover-bg)
        }

        .admin-tab-btn.active {
            border-bottom-color: var(--highlight-color);
            color: var(--highlight-color);
            font-weight: 700
        }

        .radio-group {
            display: flex;
            gap: 15px;
            margin-bottom: 10px;
            flex-wrap: wrap
        }

        .radio-label {
            display: flex;
            align-items: center;
            gap: 5px;
            cursor: pointer
        }

        .ai-processing-animation {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: var(--prompt-color)
        }

        .scanner-animation {
            width: 100px;
            height: 100px;
            position: relative;
            margin-bottom: 15px
        }

        .scanner-animation .brain-icon {
            width: 100%;
            height: 100%;
            font-size: 80px;
            line-height: 100px;
            text-align: center;
            opacity: .5
        }

        .scanner-line {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 3px;
            background: var(--highlight-color);
            box-shadow: 0 0 10px var(--highlight-color);
            border-radius: 2px;
            animation: scan 2.5s infinite linear
        }

        @keyframes scan {
            0% {
                top: 0
            }

            50% {
                top: 100%
            }

            100% {
                top: 0
            }
        }

        .prescription-template-item {
            background-color: var(--input-bg);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            margin-bottom: 15px;
            padding: 15px
        }

        .prescription-template-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px
        }

        .prescription-template-title {
            font-weight: 700;
            color: var(--prompt-color)
        }

        .prescription-template-copy-btn {
            background-color: var(--button-bg);
            border: 1px solid var(--border-color);
            color: var(--text-color);
            padding: 5px 10px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
            transition: all .2s
        }

        .prescription-template-copy-btn:hover {
            background-color: var(--highlight-color);
            color: var(--highlight-text-color)
        }

        .prescription-template-text {
            white-space: pre-wrap;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            color: var(--output-color);
            background: rgba(0, 0, 0, .1);
            padding: 10px;
            border-radius: 5px
        }

        .mobile-2-0-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: center;
            padding: 20px;
            gap: 20px;
            height: calc(100vh - 65px - 40px)
        }

        .mobile-header {
            text-align: center;
            margin-bottom: 10px
        }

        .mobile-header h2 {
            font-size: 24px;
            color: var(--header-text-color)
        }

        .mobile-header p {
            font-size: 14px;
            opacity: .8
        }

        .mobile-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            width: 100%;
            max-width: 450px
        }

        .mobile-btn {
            background: var(--glass-bg);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid var(--glass-border);
            border-radius: 18px;
            padding: 15px;
            aspect-ratio: 1/1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 10px;
            color: var(--text-color);
            text-decoration: none;
            text-align: center;
            box-shadow: var(--glass-shadow);
            transition: transform .2s ease, background-color .3s ease
        }

        .mobile-btn:active {
            transform: scale(.96);
            background-color: var(--button-hover-bg)
        }

        .mobile-btn img {
            height: 76px;
            width: 76px;
            object-fit: contain;
            margin-bottom: 5px
        }

        .mobile-btn span {
            font-size: 14px;
            font-weight: 700
        }

        .info-banner {
            width: 100%;
            max-width: 450px;
            padding: 0 10px;
            margin-bottom: 10px
        }

        .chat-bubble-info {
            background: var(--glass-bg);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid var(--glass-border);
            border-radius: 12px;
            padding: 12px 15px;
            font-size: 13px;
            line-height: 1.6;
            text-align: center;
            position: relative;
            box-shadow: var(--glass-shadow);
            animation: fadeIn .5s ease-out
        }

        .chat-bubble-info::after {
            content: '';
            position: absolute;
            bottom: -10px;
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 0;
            border-left: 10px solid transparent;
            border-right: 10px solid transparent;
            border-top: 10px solid var(--glass-border)
        }

        .chat-bubble-info .highlight-link {
            color: var(--highlight-color);
            font-weight: 700;
            text-decoration: none;
            background-color: var(--button-bg);
            padding: 2px 6px;
            border-radius: 5px;
            transition: background-color .2s
        }

        .chat-bubble-info .highlight-link:hover {
            background-color: var(--button-hover-bg);
            text-decoration: underline
        }

        .mobile-connection-status {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            margin-top: auto;
            padding-bottom: 10px;
            font-size: 12px;
            color: var(--text-color);
            opacity: .7;
            cursor: pointer
        }

        .mobile-connection-status .status-dot {
            width: 10px;
            height: 10px;
            background-color: var(--error-color);
            border-radius: 50%;
            box-shadow: 0 0 6px var(--error-color);
            transition: background-color .5s ease, box-shadow .5s ease
        }

        .mobile-connection-status .status-dot.status-on {
            background-color: var(--success-color);
            box-shadow: 0 0 6px var(--success-color)
        }

        .chatbox-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--bg-gradient);
            z-index: 1000;
            flex-direction: column
        }

        .chatbox-header {
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            padding: 12px 20px;
            background: var(--glass-bg);
            backdrop-filter: blur(15px);
            -webkit-backdrop-filter: blur(15px);
            border-bottom: 1px solid var(--glass-border);
            height: 65px;
            flex-shrink: 0
        }

        .chatbox-title {
            font-size: 20px;
            font-weight: 700;
            color: var(--header-text-color)
        }

        .chatbox-close-btn {
            font-size: 24px;
            cursor: pointer;
            color: var(--text-color);
            position: absolute;
            right: 20px
        }

        .chatbox-new-chat-btn {
            font-size: 22px;
            cursor: pointer;
            color: var(--text-color);
            position: absolute;
            left: 20px
        }

        .chatbox-messages {
            flex: 1;
            padding: 15px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 15px;
            background-image: radial-gradient(var(--border-color) 1px, transparent 1px);
            background-size: 15px 15px
        }

        .chat-message {
            display: flex;
            align-items: flex-start;
            gap: 10px;
            max-width: 85%
        }

        .chat-message.user {
            align-self: flex-end;
            flex-direction: row-reverse;
            animation: slideInFromRight .4s ease-out
        }

        @keyframes slideInFromRight {
            from {
                opacity: 0;
                transform: translateX(20px)
            }

            to {
                opacity: 1;
                transform: translateX(0)
            }
        }

        .chat-message.model {
            align-self: flex-start;
            animation: fadeIn .5s ease
        }

        .chat-avatar {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            background-color: var(--input-bg);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            flex-shrink: 0
        }

        .chat-message.user .chat-avatar {
            background-color: var(--highlight-color);
            color: var(--highlight-text-color)
        }

        .message-bubble {
            padding: 12px 18px;
            border-radius: 20px;
            line-height: 1.5;
            white-space: pre-wrap;
            word-wrap: break-word;
            box-shadow: 0 2px 4px rgba(0, 0, 0, .1)
        }

        .message-bubble b {
            font-weight: 600
        }

        .chat-message.user .message-bubble {
            background-color: var(--highlight-color);
            color: var(--highlight-text-color);
            border-bottom-right-radius: 5px
        }

        .chat-message.model .message-bubble {
            background: var(--glass-bg);
            border: 1px solid var(--glass-border);
            color: var(--text-color);
            border-bottom-left-radius: 5px
        }

        .message-bubble.typing {
            display: flex;
            align-items: center;
            gap: 5px;
            padding: 15px 18px
        }

        .message-bubble.typing .dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background-color: var(--text-color);
            opacity: .7;
            animation: typing-blink 1.4s infinite both
        }

        .message-bubble.typing .dot:nth-child(2) {
            animation-delay: .2s
        }

        .message-bubble.typing .dot:nth-child(3) {
            animation-delay: .4s
        }

        @keyframes typing-blink {
            0% {
                opacity: .2
            }

            20% {
                opacity: 1
            }

            100% {
                opacity: .2
            }
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px)
            }

            to {
                opacity: 1;
                transform: translateY(0)
            }
        }

        .chatbox-input-area {
            padding: 10px 15px;
            background: var(--glass-bg);
            backdrop-filter: blur(15px);
            -webkit-backdrop-filter: blur(15px);
            border-top: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            gap: 10px
        }

        .chat-input-row {
            display: flex;
            width: 100%;
            gap: 10px;
            align-items: center
        }

        .chatbox-input {
            flex: 1;
            background: var(--input-bg);
            border: 1px solid var(--border-color);
            border-radius: 20px;
            padding: 12px 15px;
            color: var(--text-color);
            font-size: 16px
        }

        .chatbox-input:focus {
            outline: 0;
            border-color: var(--highlight-color)
        }

        .chatbox-send-btn,
        .chatbox-upload-btn {
            background-color: var(--highlight-color);
            color: var(--highlight-text-color);
            border: none;
            border-radius: 50%;
            width: 44px;
            height: 44px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            cursor: pointer;
            transition: transform .2s;
            flex-shrink: 0
        }

        .chatbox-upload-btn {
            background-color: var(--button-bg);
            color: var(--text-color)
        }

        .chatbox-send-btn:active,
        .chatbox-upload-btn:active {
            transform: scale(.9)
        }

        .chat-image-previews {
            display: flex;
            gap: 10px;
            overflow-x: auto;
            width: 100%;
            padding: 5px 0
        }

        .chat-preview-item {
            position: relative;
            flex-shrink: 0
        }

        .chat-preview-item img {
            width: 60px;
            height: 60px;
            border-radius: 8px;
            object-fit: cover;
            border: 1px solid var(--border-color)
        }

        .chat-preview-delete {
            position: absolute;
            top: -5px;
            right: -5px;
            width: 20px;
            height: 20px;
            background-color: rgba(255, 0, 0, .8);
            color: #fff;
            border: none;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            cursor: pointer
        }

        .message-bubble .chat-image-attachment {
            width: 100%;
            max-width: 200px;
            height: auto;
            border-radius: 10px;
            margin-top: 10px;
            display: block
        }

        .confirm-modal {
            display: none;
            position: fixed;
            z-index: 3000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, .6);
            justify-content: center;
            align-items: center
        }

        .confirm-modal-content {
            background: var(--glass-bg);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            padding: 30px;
            border: 1px solid var(--glass-border);
            border-radius: 16px;
            width: 90%;
            max-width: 400px;
            box-shadow: var(--glass-shadow);
            text-align: center
        }

        #confirm-modal-text {
            margin-bottom: 25px;
            font-size: 16px;
            line-height: 1.6
        }

        .confirm-modal-buttons {
            display: flex;
            gap: 15px;
            justify-content: center
        }

        .confirm-btn {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 700;
            font-size: 14px;
            transition: background-color .2s, transform .1s
        }

        .confirm-btn:active {
            transform: scale(.97)
        }

        #confirm-btn-yes {
            background-color: var(--error-color);
            color: #fff
        }

        #confirm-btn-no {
            background-color: var(--button-bg);
            color: var(--text-color);
            border: 1px solid var(--border-color)
        }

        /* Fix for Button Overflow */
        .confirm-btn {
            min-width: 80px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            padding: 10px 15px;
        }

        .mobile-loader {
            display: none;
            position: fixed;
            z-index: 2500;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--bg-gradient);
            justify-content: center;
            align-items: center
        }

        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 28px
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: var(--button-bg);
            transition: .4s;
            border-radius: 28px;
            border: 1px solid var(--border-color)
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 20px;
            width: 20px;
            left: 4px;
            bottom: 3px;
            background-color: #fff;
            transition: .4s;
            border-radius: 50%
        }

        input:checked+.slider {
            background-color: var(--highlight-color)
        }

        input:checked+.slider:before {
            transform: translateX(22px)
        }

        .transfer-drop-zone {
            border: 2px dashed var(--border-color);
            border-radius: 10px;
            padding: 30px;
            text-align: center;
            color: var(--text-color);
            cursor: pointer;
            margin-bottom: 15px;
            transition: all .3s ease;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px
        }

        .transfer-drop-zone:hover,
        .transfer-drop-zone.dragover {
            border-color: var(--highlight-color);
            background-color: var(--button-bg)
        }

        .transfer-icon {
            font-size: 40px;
            color: var(--highlight-color);
            margin-bottom: 10px
        }

        .transfer-status {
            margin-top: 15px;
            text-align: center;
            font-size: 14px
        }

        .progress-bar-container {
            width: 100%;
            background-color: var(--input-bg);
            border-radius: 10px;
            height: 10px;
            margin-top: 10px;
            overflow: hidden
        }

        .progress-bar-fill {
            height: 100%;
            background-color: var(--success-color);
            width: 0%;
            transition: width .2s ease
        }

        .notification-popup {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: var(--glass-bg);
            backdrop-filter: blur(15px);
            -webkit-backdrop-filter: blur(15px);
            border: 1px solid var(--glass-border);
            padding: 15px;
            border-radius: 10px;
            z-index: 4000;
            display: none;
            flex-direction: column;
            gap: 5px;
            box-shadow: var(--glass-shadow);
            width: 300px;
            animation: slideInRight .3s ease-out
        }

        @keyframes slideInRight {
            from {
                transform: translateX(100%)
            }

            to {
                transform: translateX(0)
            }
        }

        .notification-popup.mobile-center {
            width: 80%;
            max-width: 300px
        }

        .progress-bar-fill.pro-mode {
            background-color: #4299e1;
            box-shadow: 0 0 10px #4299e1
        }

        /* Plugin System Styles */
        .plugin-modal-content {
            background: var(--glass-bg);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            padding: 0;
            border: 1px solid var(--glass-border);
            border-radius: 16px;
            width: 90%;
            max-width: 900px;
            height: 80vh;
            box-shadow: var(--glass-shadow);
            position: relative;
            display: flex;
            flex-direction: column;
            margin: auto;
        }

        .plugin-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 20px;
            padding: 20px;
            overflow-y: auto;
        }

        .plugin-card {
            background: var(--input-bg);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 15px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            transition: all 0.3s ease;
            position: relative;
        }

        .plugin-card:hover {
            transform: translateY(-2px);
            border-color: var(--highlight-color);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        .plugin-icon-area {
            height: 60px;
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .plugin-icon-img {
            width: 50px;
            height: 50px;
            border-radius: 10px;
            object-fit: cover;
            background: var(--button-bg);
        }

        .plugin-info {
            flex: 1;
        }

        .plugin-name {
            font-weight: bold;
            font-size: 16px;
            color: var(--header-text-color);
            margin-bottom: 2px;
        }

        .plugin-author {
            font-size: 12px;
            opacity: 0.7;
        }

        .plugin-desc {
            font-size: 13px;
            opacity: 0.8;
            line-height: 1.4;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
            height: 36px;
        }

        .plugin-actions {
            display: flex;
            gap: 10px;
            margin-top: auto;
        }

        .plugin-btn {
            flex: 1;
            padding: 8px;
            border-radius: 6px;
            border: none;
            cursor: pointer;
            font-size: 13px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 5px;
            transition: all 0.2s;
        }

        .btn-install {
            background: var(--button-bg);
            color: var(--text-color);
            border: 1px solid var(--border-color);
        }

        .btn-install:hover {
            background: var(--highlight-color);
            color: white;
            border-color: transparent;
        }

        .btn-open-plugin {
            background: var(--success-color);
            color: white;
        }

        .btn-uninstall {
            background: transparent;
            color: var(--error-color);
            border: 1px solid var(--border-color);
            width: 30px;
            flex: 0 0 30px;
        }

        .btn-uninstall:hover {
            background: rgba(255, 0, 0, 0.1);
            border-color: var(--error-color);
        }

        /* Floating Window */
        .floating-plugin-window {
            position: fixed;
            top: 100px;
            left: 100px;
            width: 400px;
            height: 500px;
            background: var(--glass-bg);
            backdrop-filter: blur(25px);
            -webkit-backdrop-filter: blur(25px);
            border: 1px solid var(--glass-border);
            border-radius: 12px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.4);
            z-index: 1000;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            min-width: 200px;
            min-height: 150px;
            resize: both;
        }

        .floating-header {
            padding: 10px 15px;
            background: rgba(0, 0, 0, 0.1);
            border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            justify-content: space-between;
            cursor: grab;
        }

        .floating-header:active {
            cursor: grabbing;
        }

        .floating-title {
            font-weight: bold;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .floating-controls {
            display: flex;
            gap: 8px;
        }

        .float-btn {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            cursor: pointer;
        }

        .floating-content {
            flex: 1;
            position: relative;
            background: white;
            /* Plugins are usually white-bg designed */
        }

        body.dark-mode .floating-content {
            background: #1a202c;
            /* Or matching theme */
        }

        .floating-iframe {
            width: 100%;
            height: 100%;
            border: none;
            background: transparent;
        }

        /* Axon Cloud Styles */
        .cloud-container {
            display: flex;
            height: 100%;
            gap: 10px;
            overflow: hidden;
        }

        .cloud-sidebar {
            width: 220px;
            background: var(--input-bg);
            border-right: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            gap: 5px;
            padding: 10px;
            border-radius: 8px;
            flex-shrink: 0;
        }

        .cloud-sidebar-item {
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            transition: background .2s;
            display: flex;
            align-items: center;
            gap: 8px;
            color: var(--text-color);
            font-size: 14px;
        }

        .cloud-sidebar-item:hover,
        .cloud-sidebar-item.active {
            background: var(--button-hover-bg);
            color: var(--highlight-color);
        }

        .cloud-main {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            min-width: 0;
        }

        .cloud-toolbar {
            display: flex;
            align-items: center;
            gap: 10px;
            padding-bottom: 10px;
            border-bottom: 1px solid var(--border-color);
            margin-bottom: 10px;
            flex-wrap: wrap;
        }

        .cloud-breadcrumb {
            font-size: 14px;
            color: var(--text-color);
            display: flex;
            align-items: center;
            gap: 5px;
            flex: 1;
            overflow-x: auto;
            white-space: nowrap;
            padding-bottom: 2px;
        }

        .cloud-breadcrumb-item {
            cursor: pointer;
            opacity: 0.7;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .cloud-breadcrumb-item:hover {
            opacity: 1;
            text-decoration: underline;
        }

        .cloud-content-area {
            flex: 1;
            overflow-y: auto;
            padding-right: 5px;
            position: relative;
        }

        .cloud-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(110px, 1fr));
            gap: 15px;
            padding-bottom: 20px;
            min-height: 100%;
            /* Ensure grid fills height for context menu */
            align-content: start;
        }

        .cloud-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            padding: 15px 10px;
            border-radius: 8px;
            border: 1px solid transparent;
            cursor: pointer;
            transition: all .2s;
            position: relative;
            background: var(--input-bg);
        }

        .cloud-item:hover {
            background: var(--button-hover-bg);
            border-color: var(--border-color);
            transform: translateY(-2px);
        }

        .cloud-item.selected {
            background: rgba(66, 153, 225, 0.2);
            border-color: var(--highlight-color);
        }

        .cloud-item-icon {
            font-size: 40px;
            color: var(--text-color);
        }

        .cloud-item[data-type="folder"] .cloud-item-icon {
            color: #ecc94b;
        }

        .cloud-item-name {
            font-size: 12px;
            text-align: center;
            word-break: break-word;
            max-width: 100%;
            display: -webkit-box;
            line-clamp: 2;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
            line-height: 1.3;
        }

        .cloud-upload-drop {
            border: 2px dashed var(--border-color);
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
            margin-bottom: 10px;
            cursor: pointer;
            color: var(--text-color);
            opacity: 0.7;
            transition: all .2s;
            gap: 10px;
            background: rgba(0, 0, 0, 0.1);
        }

        .cloud-upload-drop:hover {
            border-color: var(--highlight-color);
            opacity: 1;
            color: var(--highlight-color);
            background: rgba(66, 153, 225, 0.1);
        }

        .storage-bar-container {
            width: 100%;
            height: 8px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
            overflow: hidden;
            margin-top: auto;
        }

        .storage-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--highlight-color), var(--success-color));
            width: 0%;
            transition: width 0.5s;
        }

        .storage-text {
            font-size: 11px;
            color: var(--text-color);
            opacity: 0.8;
            margin-top: 5px;
            display: flex;
            justify-content: space-between;
        }

        .context-menu {
            position: absolute;
            background: var(--glass-bg);
            backdrop-filter: blur(15px);
            -webkit-backdrop-filter: blur(15px);
            border: 1px solid var(--glass-border);
            border-radius: 8px;
            padding: 5px 0;
            z-index: 5000;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
            display: none;
            min-width: 150px;
        }

        .context-menu-item {
            padding: 8px 15px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 13px;
            color: var(--text-color);
            transition: background .2s;
        }

        .context-menu-item:hover {
            background: var(--highlight-color);
            color: #fff;
        }

        .context-menu-item i {
            width: 16px;
            text-align: center;
        }

        /* Custom Modals & Preview */
        .custom-modal {
            display: none;
            position: fixed;
            z-index: 6000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            justify-content: center;
            align-items: center;
        }

        .custom-modal-content {
            background: var(--glass-bg);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid var(--glass-border);
            border-radius: 12px;
            padding: 20px;
            width: 90%;
            max-width: 400px;
            box-shadow: var(--glass-shadow);
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .custom-modal-title {
            font-size: 18px;
            font-weight: 700;
            color: var(--highlight-color);
        }

        .custom-modal-input {
            background: var(--input-bg);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 10px;
            color: var(--text-color);
            width: 100%;
        }

        .custom-modal-actions {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
        }

        .preview-modal {
            display: none;
            position: fixed;
            z-index: 7000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            justify-content: center;
            align-items: center;
            flex-direction: column;
        }

        .preview-header {
            width: 100%;
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: rgba(0, 0, 0, 0.5);
            position: absolute;
            top: 0;
            left: 0;
            z-index: 10;
        }

        .preview-title {
            color: #fff;
            font-size: 16px;
            font-weight: 700;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            max-width: 70%;
        }

        .preview-content {
            max-width: 90%;
            max-height: 80%;
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100%;
        }

        .preview-content img,
        .preview-content video {
            max-width: 100%;
            max-height: 80vh;
            border-radius: 8px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
        }

        .preview-content iframe {
            width: 80vw;
            height: 80vh;
            border: none;
            background: white;
            border-radius: 8px;
        }

        /* Admin Axon Drive */
        .pinata-storage-container {
            background: var(--input-bg);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
        }

        .pinata-file-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            margin-top: 10px;
        }

        .pinata-file-row {
            display: flex;
            justify-content: space-between;
            padding: 8px 10px;
            border-bottom: 1px solid var(--border-color);
            font-size: 13px;
        }

        .pinata-file-row:last-child {
            border-bottom: none;
        }

        .pinata-key-manager {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-top: 20px;
        }

        .key-item {
            background: rgba(0, 0, 0, 0.2);
            padding: 10px;
            border-radius: 6px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 12px;
            word-break: break-all;
        }

        /* Custom Modals & Preview */
        .custom-modal {
            display: none;
            position: fixed;
            z-index: 6000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            justify-content: center;
            align-items: center;
        }

        .custom-modal-content {
            background: var(--glass-bg);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid var(--glass-border);
            border-radius: 12px;
            padding: 20px;
            width: 90%;
            max-width: 400px;
            box-shadow: var(--glass-shadow);
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .custom-modal-title {
            font-size: 18px;
            font-weight: 700;
            color: var(--highlight-color);
        }

        .custom-modal-input {
            background: var(--input-bg);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 10px;
            color: var(--text-color);
            width: 100%;
        }

        .custom-modal-actions {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
        }

        .preview-modal {
            display: none;
            position: fixed;
            z-index: 7000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            justify-content: center;
            align-items: center;
            flex-direction: column;
        }

        .preview-header {
            width: 100%;
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: rgba(0, 0, 0, 0.5);
            position: absolute;
            top: 0;
            left: 0;
            z-index: 10;
        }

        .preview-title {
            color: #fff;
            font-size: 16px;
            font-weight: 700;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            max-width: 70%;
        }

        .preview-content {
            max-width: 90%;
            max-height: 80%;
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100%;
        }

        .preview-content img,
        .preview-content video {
            max-width: 100%;
            max-height: 80vh;
            border-radius: 8px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
        }

        .preview-content iframe {
            width: 80vw;
            height: 80vh;
            border: none;
            background: white;
            border-radius: 8px;
        }

        /* Admin Axon Drive */
        .pinata-storage-container {
            background: var(--input-bg);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
        }

        .pinata-file-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            margin-top: 10px;
        }

        .pinata-file-row {
            display: flex;
            justify-content: space-between;
            padding: 8px 10px;
            border-bottom: 1px solid var(--border-color);
            font-size: 13px;
        }

        .pinata-file-row:last-child {
            border-bottom: none;
        }

        .pinata-key-manager {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-top: 20px;
        }

        .key-item {
            background: rgba(0, 0, 0, 0.2);
            padding: 10px;
            border-radius: 6px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 12px;
            word-break: break-all;
        }

        .pinata-debug-container {
            background: var(--input-bg);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
        }

        @media (max-width: 768px) {
            .cloud-sidebar {
                display: none;
                position: absolute;
                left: 0;
                top: 0;
                height: 100%;
                z-index: 100;
                box-shadow: 5px 0 15px rgba(0, 0, 0, 0.5);
            }

            .cloud-sidebar.active {
                display: flex;
            }

            .cloud-container {
                position: relative;
            }

            .notification-popup,
            .notification-popup.mobile-center {
                width: 90%;
                max-width: 400px;
                left: 50%;
                top: 50%;
                transform: translate(-50%, -50%);
                bottom: auto;
                right: auto;
                border-radius: 16px;
                padding: 25px;
            }
        }

        @media (max-width:768px) {
            .notification-popup {
                bottom: auto;
                top: 50%;
                left: 50%;
                right: auto;
                transform: translate(-50%, -50%);
                animation: fadeIn .3s ease-out;
                border-radius: 16px;
                padding: 20px
            }

            .notification-popup.mobile-center {
                width: 85%
            }

            .container {
                flex-direction: column-reverse;
                padding: 10px;
                gap: 10px
            }

            .monitor-toggle-button span,
            .status-bar span {
                display: none
            }

            .monitor-toggle-button {
                padding: 5px 8px;
                font-size: 16px;
                width: auto;
                min-width: 35px
            }

            .status-bar {
                gap: 10px;
                margin-right: 0
            }

            .status-item .status-indicator {
                width: 8px;
                height: 8px
            }

            .logout-button,
            .settings-button,
            .theme-toggle {
                font-size: 18px
            }

            .camera-modal.fullscreen-mobile {
                position: fixed;
                top: 0;
                bottom: 0;
                left: 0;
                width: 100%;
                height: 100%;
                z-index: 100;
                border-radius: 0
            }

            .camera-modal.fullscreen-mobile .camera-container {
                border-radius: 0;
                border: none
            }

            .radio-group {
                flex-direction: column;
                align-items: flex-start;
                gap: 10px
            }

            .admin-users-container {
                flex-direction: column
            }

            .admin-users-list-section {
                flex: 0 0 45%;
                min-height: 220px;
                border-right: none;
                border-bottom: 1px solid var(--border-color);
                padding-bottom: 15px;
                padding-right: 0
            }

            .admin-users-details-section {
                flex: 1;
                min-height: 0;
                padding-left: 0;
                padding-top: 15px
            }
        }

        @media (min-width:769px) {
            .camera-video-wrapper {
                padding-bottom: 56.25%
            }
        }

        /* FIX: Button Text Overflow */
        .custom-modal-actions .action-button,
        .confirm-modal-buttons .confirm-btn {
            width: auto !important;
            height: auto !important;
            padding: 10px 20px !important;
            border-radius: 8px !important;
            white-space: nowrap;
            min-width: 100px;
        }

        /* Text Editor Modal */
        .text-editor-modal {
            display: none;
            position: fixed;
            z-index: 8000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            justify-content: center;
            align-items: center;
        }

        .text-editor-content {
            background: var(--glass-bg);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid var(--glass-border);
            border-radius: 10px;
            width: 80%;
            max-width: 800px;
            height: 80vh;
            display: flex;
            flex-direction: column;
            padding: 20px;
            box-shadow: var(--glass-shadow);
        }

        .text-editor-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 10px;
        }

        .text-editor-title {
            font-size: 18px;
            font-weight: 700;
            color: var(--highlight-color);
        }

        .text-editor-textarea {
            flex: 1;
            background: var(--input-bg);
            border: 1px solid var(--border-color);
            color: var(--text-color);
            padding: 15px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            resize: none;
            border-radius: 8px;
            outline: none;
            margin-bottom: 15px;
        }

        .text-editor-textarea:focus {
            border-color: var(--highlight-color);
        }



        /* Liquid Glass Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: transparent;
        }

        ::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        ::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.4);
        }



        /* Adjust main btn used in wrapper to have square right edges when wrapper is used? 
           Ideally, yes, but simpler to just slap it next to it. 
           Let's style the wrapper to visually group them. */

        /* Prescription Modal Styles - Compact & Scroll */
        .compact-input {
            padding: 8px !important;
            font-size: 13px !important;
            margin-bottom: 10px !important;
        }

        .prescription-row {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }

        .prescription-result-container {
            max-height: 250px;
            overflow-y: auto;
            margin-top: 15px;
            padding-right: 5px;
        }

        .prescription-suggestion-card {
            background: rgba(0, 0, 0, 0.2);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 10px;
            margin-bottom: 15px;
            position: relative;
        }

        .prescription-suggestion-text {
            font-family: 'Courier New', monospace;
            white-space: pre-wrap;
            font-size: 14px;
            font-weight: bold;
            color: var(--text-color);
        }

        .suggestion-copy-btn {
            position: absolute;
            top: 5px;
            right: 5px;
            background: var(--button-bg);
            border: 1px solid var(--border-color);
            padding: 2px 8px;
            font-size: 11px;
            border-radius: 4px;
            cursor: pointer;
        }

        .suggestion-copy-btn:hover {
            background: var(--highlight-color);
            color: white;
        }

        /* Free Mode Styles */
        #free-mode-textarea {
            flex: 1;
            width: 100%;
            background: transparent;
            color: var(--success-color);
            /* Matches terminal aesthetic */
            border: none;
            outline: none;
            resize: none;
            padding: 15px;
            font-family: inherit;
            font-size: 16px;
            line-height: 1.5;
            overflow-y: auto;
        }

        #free-mode-textarea::placeholder {
            color: var(--text-color);
            opacity: 0.5;
        }

        /* Allow selection in inputs and editable areas */
        input,
        textarea,
        [contenteditable] {
            user-select: text;
            -webkit-user-select: text;
        }

        /* Hide main app elements by default to prevent flash of content before access check */
        .header,
        .container,
        #mobile-2-0-container {
            display: none;
        }
    </style>
</head>

<body>
    <div id="axon-web-access-blocked-overlay">
        <img src="https://images.icon-icons.com/3178/PNG/512/error_window_icon_193931.png" alt="Acesso Bloqueado">
        <h1>Acesso Restrito</h1>
        <p id="axon-web-blocked-message">A partir de hoje o sistema somente pode ser acessado via dipostivo Axon USB!
            Caso ainda nÃ£o tenha adquirido entre em contato com o suporte; (38) 998517363.</p>
    </div>

    <div class="header">
        <div class="app-title">Axon</div>
        <div class="header-right">
            <div class="status-bar" id="btn-transfer-file"
                style="cursor:pointer;margin-right:10px;background:var(--highlight-color);color:#fff;border-color:transparent">
                <div class="status-item"><i class="fas fa-paper-plane"></i><span>Enviar</span></div>
            </div>
            <div class="status-bar" id="btn-cloud"
                style="cursor:pointer;margin-right:10px;background:var(--highlight-color);color:#fff;border-color:transparent">
                <div class="status-item"><i class="fas fa-cloud"></i><span>Nuvem</span></div>
            </div>
            <div class="status-bar">
                <div class="status-item">
                    <div class="status-indicator" id="api-status"></div><span class="status-text-api">API</span>
                </div>
                <div class="status-item">
                    <div class="status-indicator status-off" id="mic-status"></div><span
                        class="status-text-mic">Microfone</span>
                </div>
                <div class="status-item">
                    <div class="status-indicator status-off" id="camera-status"></div><span
                        class="status-text-cam">CÃ¢mera</span>
                </div>
            </div>
            <div id="theme-toggle" class="theme-toggle" title="Mudar Tema"><i class="fas fa-sun"></i></div>
            <div id="settings-button" class="settings-button" title="ConfiguraÃ§Ãµes"><i class="fas fa-cog"></i></div>
            <div id="logout-button" class="logout-button" title="Sair"><i class="fas fa-sign-out-alt"></i></div>
        </div>
    </div>
    <div class="container">
        <div class="terminal interactive-terminal">
            <div class="terminal-header">
                <div class="terminal-title">Terminal Interativo</div>
                <div class="terminal-actions">
                    <div class="terminal-btn close-btn"></div>
                    <div class="terminal-btn minimize-btn"></div>
                    <div class="terminal-btn maximize-btn"></div>
                </div>
            </div><button id="btn-free-mode" class="monitor-copy-btn" style="top: 50px; right: 25px;"
                title="Modo Livre"><i class="fas fa-edit"></i></button>
            <div class="terminal-content" id="interactive-output"><img src="axon.png" alt="Axon Logo Terminal"
                    class="terminal-logo-internal">
                <div id="initial-messages" style="position:relative;z-index:1">
                    <pre class="info">
 â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•—  â–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—
â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â•šâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•‘
â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘ â•šâ–ˆâ–ˆâ–ˆâ•”â• â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â–ˆâ–ˆâ•— â–ˆâ–ˆâ•‘
â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘ â–ˆâ–ˆâ•”â–ˆâ–ˆâ•— â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘
â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â• â–ˆâ–ˆâ•—â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘ â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•‘
â•šâ•â•  â•šâ•â•â•šâ•â•  â•šâ•â• â•šâ•â•â•â•â•â• â•šâ•â•  â•šâ•â•â•â•
                    </pre><span class="info">Axon - Assistente MÃ©dico v1.6</span><br><span class="info">Aguardando
                        autenticaÃ§Ã£o...</span><br><br>
                </div>
            </div>
            <div id="free-mode-board" class="terminal-content"
                style="display:none; flex-direction:column; padding:20px; background: var(--free-mode-bg); border-radius: 10px; margin: 10px; height: calc(100% - 20px);">
                <textarea id="free-mode-textarea" placeholder="Digite livremente aqui... (Texto salvo automaticamente)"
                    spellcheck="false"
                    style="flex: 1; background: transparent; border: none; color: var(--text-color); font-family: 'Courier New', monospace; resize: none; font-size: 14px; outline: none; line-height: 1.5;"></textarea>
                <div
                    style="padding-top: 10px; border-top: 1px solid var(--border-color); display:flex; justify-content:flex-end;">
                    <button id="btn-process-free-mode" class="action-button"
                        style="width:auto; padding: 6px 15px; border-radius: 20px; font-weight: bold; display: flex; align-items: center; gap: 8px; font-size: 12px;">
                        <i class="fas fa-paper-plane"></i> Processar
                    </button>
                </div>
            </div>
            <div class="terminal-footer">
                <div class="action-buttons-container"><button id="btn-exames" class="action-button"
                        title="Analisar Exames (/exames)"><i class="fas fa-file-medical-alt"></i></button><button
                        id="btn-see" class="action-button" title="AnÃ¡lise Visual Axon Eye (/see)"><i
                            class="fas fa-eye"></i></button><button id="btn-hd" class="action-button"
                        title="Gerar HipÃ³teses DiagnÃ³sticas (/hd)"><i class="fas fa-lightbulb"></i></button>
                    <button id="btn-cd" class="action-button" title="Gerar Conduta MÃ©dica (/cd)"><i
                            class="fas fa-pills"></i></button>
                    <button id="btn-prescription-assist" class="action-button" title="Assistente de PrescriÃ§Ã£o"><i
                            class="fas fa-heartbeat"></i></button>
                    <button id="btn-records" class="action-button" title="ProntuÃ¡rios"><i
                            class="fas fa-book-medical"></i></button><button id="btn-clear" class="action-button"
                        title="Limpar SessÃ£o (/clear)"><i class="fas fa-eraser"></i></button><button id="btn-mic"
                        class="action-button" title="Ativar/Desativar Microfone"><i
                            class="fas fa-microphone-slash"></i></button>
                </div>
                <div class="input-line"><span class="prompt">></span><input type="text" class="command-input"
                        id="command-input" autocomplete="off" autofocus></div>
            </div>
        </div>
        <div class="terminal non-interactive-terminal">
            <div class="terminal-header">
                <div class="terminal-title">Monitor</div>
                <div class="monitor-toggle-buttons"><button id="toggle-anamnesis"
                        class="monitor-toggle-button active"><i
                            class="fas fa-notes-medical"></i><span>Anamnese</span></button><button id="toggle-exams"
                        class="monitor-toggle-button"><i
                            class="fas fa-file-medical-alt"></i><span>Exames</span></button><button id="toggle-axon-eye"
                        class="monitor-toggle-button"><i class="fas fa-eye"></i><span>Axon Eye</span></button></div>
                <div class="terminal-actions">
                    <div class="terminal-btn close-btn"></div>
                    <div class="terminal-btn minimize-btn"></div>
                    <div class="terminal-btn maximize-btn"></div>
                </div>
            </div><button id="monitor-copy-btn" class="monitor-copy-btn" title="Copiar ConteÃºdo"><i
                    class="fas fa-copy"></i></button>
            <div class="terminal-content" id="monitor-content-wrapper">
                <div id="anamnesis-preview" class="monitor-view">
                    <div class="info">Aguardando inÃ­cio da anamnese...</div>
                </div>
                <div id="exams-results-preview" class="monitor-view" style="display:none">
                    <div class="info">Nenhum exame analisado ainda.</div>
                </div>
                <div id="axon-eye-results-preview" class="monitor-view" style="display:none">
                    <div class="info">Nenhuma anÃ¡lise visual feita ainda.</div>
                </div>
            </div>
        </div>
    </div>
    <div id="mobile-2-0-container" class="mobile-2-0-container" style="display:none">
        <div class="mobile-header">
            <h2 id="mobile-welcome-title">Bem-vindo!</h2>
            <p>Selecione uma opÃ§Ã£o para comeÃ§ar.</p>
        </div>
        <div class="info-banner">
            <div class="chat-bubble-info"><i class="fas fa-info-circle"
                    style="margin-right:8px;color:var(--prompt-color)"></i><span id="info-banner-content">Para acesso
                    completo, abra o Axon Web em seu computador em<a href="https://funortehub.github.io/axon"
                        target="_blank" class="highlight-link">funortehub.github.io/axon</a>ou insira um dispositivo
                    AXON USB.</span></div>
        </div>
        <div class="mobile-grid"><button id="mobile-btn-exames" class="mobile-btn"><img src="btn1.PNG"
                    alt="Analisar Exames"><span>Analisar Exames</span></button><button id="mobile-btn-see"
                class="mobile-btn"><img src="btn2.PNG" alt="AnÃ¡lise Axon Eye"><span>AnÃ¡lise Axon
                    Eye</span></button><button id="mobile-btn-records" class="mobile-btn"><img src="btn3.PNG"
                    alt="ProntuÃ¡rios"><span>ProntuÃ¡rios</span></button><button id="mobile-btn-chat"
                class="mobile-btn"><img src="btn4.PNG" alt="Axon AI Chat"><span>Axon AI Chat</span></button></div>
        <div class="mobile-connection-status">
            <div style="display:flex;align-items:center;justify-content:center;gap:8px">
                <div class="status-dot"></div><span>Nenhum desktop conectado</span>
            </div><small style="font-size:10px;opacity:.8;margin-top:5px;max-width:220px;line-height:1.3">^Clique aqui
                para fazer logout em outros desktops conectados</small>
        </div>
    </div>
    <div class="footer"><span>AXON | Sistema mÃ©dico inteligente desenvolvido por Ian Bastos</span></div>
    <div id="camera-modal" class="camera-modal">
        <div class="camera-container">
            <div class="terminal-header">
                <div class="terminal-title" id="camera-modal-title">CÃ¢mera de Exames</div>
                <div class="terminal-actions">
                    <div class="terminal-btn close-btn" id="camera-close-btn"></div>
                </div>
            </div>
            <div class="terminal-content" style="padding:10px">
                <div class="camera-video-wrapper"><video id="camera-video" class="camera-video" autoplay playsinline
                        muted></video>
                    <div class="camera-action-buttons"><button id="flashlight-button" class="flashlight-button"
                            style="display:none"><i class="fas fa-lightbulb"></i>Lanterna</button><button
                            id="camera-switch-button" class="camera-switch-button" style="display:none"><i
                                class="fas fa-sync-alt"></i>Trocar CÃ¢mera</button></div>
                    <div id="album-button" class="album-button" style="display:none"><i
                            class="fas fa-images"></i>Ãlbum<span id="album-count" class="album-count">0</span></div>
                    <div class="camera-controls"><button id="capture-button" class="camera-button"
                            title="Capturar Foto"><i class="fas fa-camera"></i></button><input type="file"
                            id="file-input" accept="image/*" multiple="multiple" style="display:none"><button
                            id="upload-button" class="camera-button" title="Carregar Arquivo"><i
                                class="fas fa-upload"></i></button><button id="send-exams-button"
                            class="camera-button disabled" title="Enviar Exames"><i
                                class="fas fa-paper-plane"></i></button><button id="send-axon-eye-button"
                            class="camera-button disabled" title="Analisar com Axon Eye" style="display:none"><i
                                class="fas fa-eye"></i></button><button id="cancel-camera-button" class="camera-button"
                            title="Cancelar"><i class="fas fa-times"></i></button></div>
                </div><canvas id="camera-canvas" style="display:none"></canvas>
            </div>
        </div>
    </div>
    <div id="fullscreen-modal" class="fullscreen-modal"><span class="modal-close">&times;</span><img
            class="modal-content" id="modal-image"></div>
    <div id="album-modal" class="album-modal">
        <div class="album-modal-content"><span class="album-modal-close">&times;</span>
            <div class="album-modal-header">
                <div class="album-modal-title">Ãlbum de Exames</div>
            </div>
            <div id="album-grid" class="album-grid"></div>
        </div>
    </div>
    <div id="patient-list-modal" class="patient-list-modal">
        <div class="patient-list-content"><span class="patient-list-close">&times;</span>
            <div class="patient-list-header">
                <div class="patient-list-title">Pacientes Salvos</div>
            </div>
            <div class="patient-search-container"><input type="text" id="patient-search-input"
                    class="patient-search-input" placeholder="Pesquisar paciente..."></div>
            <div id="patient-list" class="patient-list"></div>
            <div class="patient-list-footer"
                style="margin-top:15px;padding-top:15px;border-top:1px solid var(--border-color)"><button
                    id="btn-save-from-list" class="app-modal-button" style="width:100%">Salvar Consulta Atual</button>
            </div>
        </div>
    </div>
    <div id="patient-details-modal" class="patient-details-modal">
        <div class="patient-details-content"><span class="patient-details-close">&times;</span>
            <div class="patient-details-header">
                <div class="patient-details-title" id="patient-details-title">Detalhes do Paciente</div>
            </div>
            <div id="patient-details-body" class="patient-details-body"></div>
        </div>
    </div>
    <div id="login-modal" class="app-modal">
        <div class="app-modal-content">
            <div class="app-modal-header">
                <h2 class="app-modal-title">AXON A.I - Login</h2>
            </div>
            <div class="app-modal-body">
                <p>Por favor, faÃ§a login para continuar.</p><input type="text" id="login-modal-user"
                    placeholder="UsuÃ¡rio" class="app-modal-input" autocomplete="username"> <input type="password"
                    id="login-modal-pass" placeholder="Senha" class="app-modal-input"
                    autocomplete="current-password"><button id="login-modal-button"
                    class="app-modal-button">Entrar</button>
                <div id="login-modal-feedback" class="app-modal-feedback"></div>
            </div>
        </div>
    </div>
    <div id="save-patient-modal" class="app-modal">
        <div class="app-modal-content"><span class="app-modal-close">&times;</span>
            <div class="app-modal-header">
                <h2 class="app-modal-title">Salvar Paciente</h2>
            </div>
            <div class="app-modal-body">
                <p>Insira os dados do paciente para salvar a sessÃ£o atual.</p><input type="text" id="save-patient-name"
                    placeholder="Nome Completo do Paciente" class="app-modal-input"> <input type="text"
                    id="save-patient-dob" placeholder="Data de Nascimento (DD/MM/AAAA)" class="app-modal-input"><button
                    id="save-patient-button" class="app-modal-button">Salvar</button>
                <div id="save-patient-feedback" class="app-modal-feedback"></div>
            </div>
        </div>
    </div>
    <div id="admin-auth-modal" class="app-modal">
        <div class="app-modal-content"><span class="app-modal-close">&times;</span>
            <div class="app-modal-header">
                <h2 class="app-modal-title">AdministraÃ§Ã£o</h2>
            </div>
            <div class="app-modal-body">
                <p>Insira a senha de administrador.</p><input type="password" id="admin-auth-pass" placeholder="Senha"
                    class="app-modal-input"><button id="admin-auth-button" class="app-modal-button">Acessar</button>
                <div id="admin-auth-feedback" class="app-modal-feedback"></div>
            </div>
        </div>
    </div>
    <div id="admin-panel-modal" class="app-modal">
        <div class="app-modal-content"><span class="app-modal-close">&times;</span>
            <div class="app-modal-header">
                <h2 class="app-modal-title">Painel Administrativo</h2>
            </div>
            <div class="admin-tabs"><button class="admin-tab-btn active" data-tab="users">UsuÃ¡rios</button><button
                    class="admin-tab-btn" data-tab="api">API</button><button class="admin-tab-btn"
                    data-tab="axon-drive">Axon Drive</button><button class="admin-tab-btn"
                    data-tab="bridge">Bridge</button><button class="admin-tab-btn" data-tab="debug">Debug</button></div>
            <div id="tab-users" class="admin-tab-content">
                <div class="patient-search-container" style="margin:0 0 15px 0"><input type="text"
                        id="admin-user-search" class="patient-search-input" placeholder="Buscar usuÃ¡rio..."></div>
                <div class="admin-users-container">
                    <div class="admin-users-list-section">
                        <div class="admin-section-title"
                            style="margin-top:0;margin-bottom:10px;flex-shrink:0;display:flex;justify-content:space-between;align-items:center">
                            <span>UsuÃ¡rios (Rank de Uso)</span>
                            <div style="display:flex;gap:5px"><button id="disconnect-all-users-btn"
                                    class="patient-action-button"
                                    style="flex:0;padding:4px 8px;font-size:12px;color:var(--error-color)"><i
                                        class="fas fa-power-off"></i>Desconectar Todos</button><button
                                    id="toggle-create-user-form" class="patient-action-button details"
                                    style="flex:0;padding:4px 8px;font-size:12px"><i
                                        class="fas fa-plus"></i>Novo</button></div>
                        </div>
                        <div id="admin-users-list" class="user-list-scroll">
                            <div class="info">Carregando...</div>
                        </div>
                    </div>
                    <div class="admin-users-details-section" id="admin-user-details">
                        <div class="info" style="margin-top:20px">Selecione um usuÃ¡rio para ver detalhes.</div>
                    </div>
                </div>
                <div id="create-user-form-container" class="admin-section"
                    style="margin-top:15px;padding:10px 15px;flex-shrink:0;display:none">
                    <div class="admin-section-title"
                        style="display:flex;justify-content:space-between;align-items:center"><span>Criar Novo
                            UsuÃ¡rio</span><i id="close-create-user-form" class="fas fa-times"
                            style="cursor:pointer;font-size:16px"></i></div>
                    <div style="display:flex;gap:10px;margin-bottom:10px"><input type="text" id="admin-new-user"
                            class="admin-input" placeholder="Novo nome de usuÃ¡rio" style="flex:1"> <input type="text"
                            id="admin-new-pass" class="admin-input" placeholder="Nova senha" style="flex:1"></div>
                    <button class="app-modal-button" onclick="window.createUserFromPanel()">Criar UsuÃ¡rio</button>
                    <div id="admin-create-user-feedback" class="app-modal-feedback"
                        style="text-align:left;margin-top:10px;min-height:15px;font-size:12px"></div>
                </div>
            </div>
            <div id="tab-api" class="admin-tab-content" style="display:none">
                <div id="admin-settings-body"></div>
            </div>
            <div id="tab-debug" class="admin-tab-content" style="display:none">
                <div id="admin-debug-body"></div>
            </div>

            <!-- AXON DRIVE TAB -->
            <div id="tab-axon-drive" class="admin-tab-content" style="display:none">
                <div class="admin-section">
                    <h3>Status do Armazenamento (Pinata)</h3>
                    <div class="pinata-storage-container">
                        <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
                            <span id="admin-pinata-usage-text">Carregando...</span>
                            <span id="admin-pinata-usage-percent">0%</span>
                        </div>
                        <div class="storage-bar-container" style="height: 15px; background: rgba(255,255,255,0.1);">
                            <div class="storage-bar-fill" id="admin-pinata-usage-bar"></div>
                        </div>
                        <div style="margin-top: 10px; font-size: 11px; opacity: 0.7;">
                            *Armazenamento combinado de todas as chaves ativas.
                        </div>
                    </div>

                    <h3>Gerenciador de Arquivos Global</h3>
                    <div class="pinata-file-list" id="admin-pinata-file-list">
                        <!-- List populated by JS -->
                        <div style="padding: 10px; text-align: center; color: var(--text-color); opacity: 0.5;">
                            Carregando arquivos...</div>
                    </div>
                </div>

                <div class="admin-section">
                    <h3>Gerenciador de Chaves Pinata (Multi-Key)</h3>
                    <div class="pinata-key-manager">
                        <div id="admin-pinata-key-list"></div>

                        <div style="margin-top: 10px; padding: 10px; background: rgba(0,0,0,0.1); border-radius: 8px;">
                            <h4>Adicionar Nova Chave</h4>
                            <input type="text" id="new-pinata-key" placeholder="API Key" class="admin-input"
                                style="margin-bottom: 5px;">
                            <input type="text" id="new-pinata-secret" placeholder="Secret Key" class="admin-input"
                                style="margin-bottom: 5px;">
                            <input type="text" id="new-pinata-jwt" placeholder="JWT (Opcional)" class="admin-input"
                                style="margin-bottom: 5px;">
                            <div style="display:flex; justify-content: flex-end;">
                                <button class="action-button" id="btn-add-pinata-key"
                                    style="background: var(--success-color); width: auto; padding: 6px 12px; white-space: nowrap;">Adicionar
                                    (+1GB)</button>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- SUPABASE SECTION -->
                <div class="admin-section"
                    style="margin-top: 20px; border-top: 1px solid var(--border-color); padding-top: 20px;">
                    <h3>Supabase Storage (OpÃ§Ã£o HÃ­brida)</h3>
                    <div style="font-size:12px; opacity:0.7; margin-bottom:10px">
                        Quando ativado, arquivos menores que 50MB serÃ£o salvos no Supabase. O restante irÃ¡ para o
                        Pinata.
                    </div>

                    <!-- Config -->
                    <div style="background: rgba(0,0,0,0.1); padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                        <div
                            style="display:flex; justify-content:space-between; align-items:center; margin-bottom: 15px;">
                            <span style="font-weight:bold;">Ativar IntegraÃ§Ã£o</span>
                            <label class="toggle-switch">
                                <input type="checkbox" id="admin-supabase-toggle"
                                    onchange="window.toggleSupabase(this.checked)">
                                <span class="slider round"></span>
                            </label>
                        </div>

                        <input type="text" id="admin-supabase-url" class="admin-input"
                            placeholder="Project URL (https://...supabase.co)" style="margin-bottom: 8px;">
                        <input type="text" id="admin-supabase-key" class="admin-input" placeholder="API Key"
                            style="margin-bottom: 8px;">
                        <input type="text" id="admin-supabase-bucket" class="admin-input"
                            placeholder="Nome do Bucket (PadrÃ£o: axons-drive)" style="margin-bottom: 8px;">

                        <div style="display:flex; justify-content:flex-end;">
                            <button class="patient-action-button" id="btn-save-supabase"
                                onclick="window.saveSupabaseConfig()">
                                <i class="fas fa-save"></i> Salvar Credenciais
                            </button>
                        </div>
                    </div>

                    <!-- Storage Visualization (Mocked or simple count) -->
                    <h3>Armazenamento Supabase</h3>
                    <div class="pinata-storage-container">
                        <div style="display: flex; justify-content: space-between; margin-bottom: 5px;">
                            <span id="admin-supabase-usage-text">Carregando...</span>
                            <span id="admin-supabase-usage-percent">0%</span>
                        </div>
                        <div class="storage-bar-container" style="height: 15px; background: rgba(255,255,255,0.1);">
                            <div class="storage-bar-fill" id="admin-supabase-usage-bar"
                                style="width: 0%; background: #3ecf8e;"></div>
                        </div>
                    </div>

                    <!-- File List -->
                    <h3 style="margin-top:15px;">Arquivos no Supabase</h3>
                    <div class="pinata-file-list" id="admin-supabase-file-list">
                        <div class="info">Carregando arquivos...</div>
                    </div>
                </div>
            </div>
            <!-- AXON BRIDGE TAB -->
            <div id="tab-bridge" class="admin-tab-content" style="display:none">
                <div class="admin-section">
                    <h3>Gerenciamento de APIs (Axon Bridge)</h3>
                    <div style="font-size:12px; opacity:0.7; margin-bottom:15px">Controle quais APIs de sistema os
                        plugins podem acessar.</div>
                    <div id="admin-bridge-body">
                        <!-- Dynamically populated -->
                    </div>
                </div>

                <div class="admin-section"
                    style="margin-top: 20px; border-top: 1px solid var(--border-color); padding-top: 20px;">
                    <h3>Gerenciamento de Plugins (Axon Store)</h3>
                    <div style="font-size:12px; opacity:0.7; margin-bottom:15px">Carregue plugins (.json) para a Axon
                        Store global.</div>

                    <div style="display: flex; gap: 10px; margin-bottom: 15px;">
                        <button class="app-modal-button"
                            onclick="document.getElementById('admin-plugin-upload').click()">
                            <i class="fas fa-upload"></i> Upload Plugin (.json)
                        </button>
                        <input type="file" id="admin-plugin-upload" accept=".json" style="display: none;"
                            onchange="window.adminUploadPlugin(this)">
                    </div>

                    <div id="admin-plugins-list" class="pinata-file-list">
                        <!-- List populated by JS -->
                        <div style="padding: 10px; text-align: center; color: var(--text-color); opacity: 0.5;">
                            Carregando plugins...
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div id="prescription-helper-modal" class="app-modal">
        <div class="app-modal-content" style="max-width:600px"><span class="app-modal-close">&times;</span>
            <div class="app-modal-header">
                <h2 class="app-modal-title" id="prescription-helper-title">Assistente de PrescriÃ§Ã£o</h2>
            </div>
            <div class="app-modal-body" id="prescription-helper-body" style="text-align:left;overflow-y:auto"></div>
        </div>
    </div>
    <div id="chatbox-modal" class="chatbox-modal">
        <div class="chatbox-header"><i id="chatbox-new-chat-btn" class="fas fa-plus-circle chatbox-new-chat-btn"
                title="Nova Conversa"></i><span class="chatbox-title">Axon AI Chat</span><i id="chatbox-close-btn"
                class="fas fa-times chatbox-close-btn"></i></div>
        <div class="chatbox-messages" id="chatbox-messages"></div>
        <div class="chatbox-input-area">
            <div id="chat-image-previews" class="chat-image-previews"></div>
            <div class="chat-input-row"><input type="file" id="chat-file-input" accept="image/*" multiple="multiple"
                    style="display:none"><button id="chatbox-upload-btn" class="chatbox-upload-btn"><i
                        class="fas fa-camera"></i></button><input type="text" id="chatbox-input" class="chatbox-input"
                    placeholder="FaÃ§a uma pergunta..."><button id="chatbox-send-btn" class="chatbox-send-btn"><i
                        class="fas fa-paper-plane"></i></button></div>
        </div>
    </div>
    <div id="custom-confirm-modal" class="confirm-modal">
        <div class="confirm-modal-content">
            <p id="confirm-modal-text"></p>
            <div class="confirm-modal-buttons"><button id="confirm-btn-no" class="confirm-btn">Cancelar</button><button
                    id="confirm-btn-yes" class="confirm-btn">Confirmar</button></div>
        </div>
    </div>

    <!-- LOG SETTINGS MODAL -->
    <div id="log-settings-modal" class="app-modal">
        <div class="app-modal-content" style="max-width: 400px; text-align: center;">
            <span class="app-modal-close"
                onclick="document.getElementById('log-settings-modal').style.display='none'">&times;</span>
            <div class="app-modal-header">
                <h2 class="app-modal-title">ConfiguraÃ§Ãµes de Log</h2>
            </div>
            <div class="app-modal-body">
                <div
                    style="background: rgba(255,255,255,0.05); padding: 20px; border-radius: 12px; margin-bottom: 20px;">
                    <div style="font-size: 40px; margin-bottom: 15px; color: var(--prompt-color);">
                        <i class="fas fa-terminal"></i>
                    </div>
                    <p style="margin-bottom: 20px; font-size: 14px; opacity: 0.8;">
                        Gerencie quais mensagens aparecem no terminal. Ocultar logs tÃ©cnicos deixa a interface mais
                        limpa.
                    </p>

                    <div
                        style="display: flex; align-items: center; justify-content: space-between; background: var(--glass-bg); padding: 15px; border-radius: 8px; border: 1px solid var(--border-color);">
                        <span style="font-weight: bold;">Ocultar Logs TÃ©cnicos</span>
                        <label class="toggle-switch">
                            <input type="checkbox" id="modal-hide-status-toggle"
                                onchange="window.toggleLogSuppression(this.checked)">
                            <span class="slider"></span>
                        </label>
                    </div>
                </div>
                <button class="app-modal-button"
                    onclick="document.getElementById('log-settings-modal').style.display='none'">Fechar</button>
            </div>
        </div>
    </div>
    <div id="mobile-analysis-loader" class="mobile-loader">
        <div class="ai-processing-animation">
            <div class="scanner-animation">
                <div class="brain-icon"><i class="fas fa-brain"></i></div>
                <div class="scanner-line"></div>
            </div><span>Analisando Imagens...</span>
        </div>
    </div>
    <div id="transfer-modal" class="app-modal">
        <div class="app-modal-content"><span class="app-modal-close">&times;</span>
            <div class="app-modal-header">
                <h2 class="app-modal-title">TransferÃªncia de Arquivos</h2>
            </div>
            <div class="app-modal-body">
                <div id="transfer-drop-zone" class="transfer-drop-zone">
                    <div class="transfer-icon"><i class="fas fa-cloud-upload-alt"></i></div>
                    <p>Arraste e solte arquivos aqui ou clique para selecionar</p>
                </div><input type="file" id="transfer-file-input" style="display:none" multiple>
                <div id="transfer-status" class="transfer-status"></div>
                <div id="transfer-progress-bar" class="progress-bar-container" style="display:none">
                    <div id="transfer-progress-fill" class="progress-bar-fill"></div>
                </div>
            </div>
        </div>
    </div>
    <div id="transfer-notification" class="app-modal"
        style="display:none;align-items:center;justify-content:center;z-index:4000;">
        <div class="app-modal-content" style="max-width:400px;text-align:center;">
            <div class="app-modal-header">
                <h2 class="app-modal-title">Recebendo Arquivo</h2>
            </div>
            <div class="app-modal-body">
                <div style="font-size:50px;color:var(--highlight-color);margin-bottom:20px;"><i
                        class="fas fa-file-import"></i></div>
                <p id="transfer-notification-text" style="font-size:16px;margin-bottom:20px;">Baixando arquivo...</p>
                <div class="progress-bar-container">
                    <div id="transfer-notification-progress" class="progress-bar-fill"></div>
                </div>
            </div>
        </div>
    </div>

    <div id="axon-cloud-modal" class="app-modal">
        <div class="app-modal-content"
            style="max-width:1000px;height:85vh;width:95%; display: flex; flex-direction: column;">
            <div class="app-modal-header">
                <div
                    style="display:flex; align-items: center; gap: 15px; flex: 1; overflow: hidden; margin-right: 15px;">
                    <h2 class="app-modal-title" style="white-space:nowrap;"><i class="fas fa-cloud"></i> Axon Cloud</h2>
                    <div class="cloud-breadcrumb" id="cloud-breadcrumb" style="border: none; padding: 0;">
                        <div class="cloud-breadcrumb-item"><i class="fas fa-home"></i> InÃ­cio</div>
                    </div>
                </div>
                <span class="app-modal-close axon-cloud-close">&times;</span>
            </div>
            <div class="app-modal-body" style="padding:0;display:flex;flex-direction:column;flex:1;overflow:hidden;">
                <div class="cloud-container">
                    <div class="cloud-sidebar">
                        <div class="cloud-upload-drop" id="cloud-drop-zone"><i class="fas fa-cloud-upload-alt"
                                style="font-size:30px;"></i><span style="font-size: 11px;">Arraste e solte</span>
                        </div>

                        <div class="cloud-sidebar-item active" data-target="all"><i class="fas fa-server"></i> Todos
                        </div>
                        <div class="cloud-sidebar-item" data-target="images"><i class="fas fa-images"></i> Imagens</div>
                        <div class="cloud-sidebar-item" data-target="videos"><i class="fas fa-video"></i> VÃ­deos</div>
                        <div class="cloud-sidebar-item" data-target="docs"><i class="fas fa-file-alt"></i> Docs</div>

                        <div style="margin-top:auto;">
                            <div class="storage-text"><span>Armazenamento</span><span id="cloud-storage-text">0 / 0
                                    GB</span></div>
                            <div class="storage-bar-container">
                                <div id="cloud-storage-bar" class="storage-bar-fill"></div>
                            </div>
                        </div>
                    </div>
                    <div class="cloud-main">
                        <div class="cloud-toolbar"><button class="patient-action-button" id="cloud-btn-upload"><i
                                    class="fas fa-upload"></i> Upload</button><button class="patient-action-button"
                                id="cloud-btn-new-folder"><i class="fas fa-folder-plus"></i> Nova Pasta</button><button
                                class="patient-action-button" id="cloud-btn-refresh"><i
                                    class="fas fa-sync-alt"></i></button>
                            <div style="margin-left: auto;">
                                <input type="text" id="cloud-search" class="admin-input" placeholder="Pesquisar..."
                                    style="width:200px;">
                            </div>
                        </div>
                        <div class="cloud-content-area" id="cloud-content-area">
                            <div class="cloud-grid" id="cloud-grid"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- New Preview Modal -->
    <div id="file-preview-modal" class="preview-modal">
        <div class="preview-header">
            <span class="preview-title" id="preview-title">Nome do Arquivo</span>
            <div style="display: flex; gap: 10px;">
                <a id="preview-download-btn" href="#" download class="action-button"
                    style="text-decoration: none; display: flex; align-items: center; justify-content: center; width: 30px; height: 30px; border-radius: 50%;"><i
                        class="fas fa-download"></i></a>
                <button class="action-button"
                    onclick="document.getElementById('file-preview-modal').style.display='none'"
                    style="width: 30px; height: 30px; display: flex; align-items: center; justify-content: center; border-radius: 50%;"><i
                        class="fas fa-times"></i></button>
            </div>
        </div>
        <div class="preview-content" id="preview-content">
            <!-- Content injected via JS -->
        </div>
    </div>

    <!-- Custom Input Modal -->
    <div id="custom-input-modal" class="custom-modal">
        <div class="custom-modal-content">
            <span class="custom-modal-title" id="custom-input-title">TÃ­tulo</span>
            <p id="custom-input-message" style="font-size: 14px; opacity: 0.8;"></p>
            <input type="text" id="custom-input-field" class="custom-modal-input">
            <div class="custom-modal-actions">
                <button class="action-button" id="custom-input-cancel"
                    style="background: transparent; border: 1px solid var(--border-color);">Cancelar</button>
                <button class="action-button" id="custom-input-confirm">Confirmar</button>
            </div>
        </div>
    </div>

    <!-- Select Folder Modal -->
    <div id="select-folder-modal" class="custom-modal">
        <div class="custom-modal-content" style="max-height: 70vh; display: flex; flex-direction: column;">
            <span class="custom-modal-title">Mover para...</span>
            <div id="folder-list-container"
                style="overflow-y: auto; margin: 15px 0; border: 1px solid var(--border-color); border-radius: 8px; max-height: 300px; text-align: left;">
                <!-- Folder List Injected Here -->
            </div>
            <div class="custom-modal-actions">
                <button class="action-button" id="select-folder-cancel"
                    style="background: transparent; border: 1px solid var(--border-color);">Cancelar</button>
            </div>
        </div>
    </div>

    <div id="cloud-context-menu" class="context-menu">
        <div class="context-menu-item" id="ctx-open"><i class="fas fa-external-link-alt"></i> Abrir</div>
        <div class="context-menu-item" id="ctx-download"><i class="fas fa-download"></i> Download</div>
        <div class="context-menu-item" id="ctx-copy"><i class="fas fa-copy"></i> Copiar</div>
        <div class="context-menu-item" id="ctx-rename"><i class="fas fa-edit"></i> Renomear</div>
        <div class="context-menu-item" id="ctx-move"><i class="fas fa-arrows-alt"></i> Mover para...</div>
        <div class="context-menu-item" id="ctx-delete" style="color:var(--error-color);"><i class="fas fa-trash"></i>
            Excluir</div>
    </div>

    <div id="cloud-bg-context-menu" class="context-menu">
        <div class="context-menu-item" id="ctx-bg-new-folder"><i class="fas fa-folder-plus"></i> Nova Pasta</div>
        <div class="context-menu-item" id="ctx-bg-new-text"><i class="fas fa-file-alt"></i> Novo Arquivo de Texto</div>
        <div class="context-menu-item" id="ctx-bg-paste"><i class="fas fa-paste"></i> Colar</div>
        <div class="context-menu-item" id="ctx-bg-upload"><i class="fas fa-upload"></i> Upload</div>
    </div>

    <!-- Plugin Manager Modal -->
    <div id="plugin-manager-modal" class="app-modal">
        <div class="plugin-modal-content">
            <div class="app-modal-header" style="padding: 20px; border-bottom: 1px solid var(--border-color);">
                <div style="display:flex; align-items:center; gap: 10px;">
                    <h2 class="app-modal-title"><i class="fas fa-cubes"></i> Ferramentas & Plugins</h2>
                    <div
                        style="display:flex; background: var(--input-bg); border-radius: 20px; padding: 2px; margin-left: 20px;">
                        <button class="monitor-toggle-button active" id="tab-installed-plugins"
                            onclick="window.axonPluginManager.switchTab('installed')">Instalados</button>
                        <button class="monitor-toggle-button" id="tab-axon-store"
                            onclick="window.axonPluginManager.switchTab('store')">Axon Store</button>
                    </div>
                </div>
                <span class="app-modal-close"
                    onclick="document.getElementById('plugin-manager-modal').style.display='none'">&times;</span>
            </div>

            <!-- Installed Tab -->
            <div id="view-installed-plugins" class="app-modal-body" style="padding: 0; display: block;">
                <div id="installed-plugins-list" class="plugin-grid">
                    <!-- Plugins injected here -->
                </div>
                <div id="no-plugins-msg" style="text-align:center; padding: 50px; opacity: 0.6; display: none;">
                    <i class="fas fa-box-open" style="font-size: 40px; margin-bottom: 15px;"></i>
                    <p>Nenhum plugin instalado.</p>
                    <button class="confirmation-btn" onclick="window.axonPluginManager.switchTab('store')"
                        style="margin-top:10px; background: var(--highlight-color); border:none; color:white; padding:8px 15px; border-radius:6px; cursor:pointer;">Ir
                        para Loja</button>
                </div>
            </div>

            <!-- Store Tab -->
            <div id="view-axon-store" class="app-modal-body" style="padding: 0; display: none;">
                <div style="padding: 15px; border-bottom: 1px solid var(--border-color); display: flex; gap: 10px;">
                    <input type="text" id="store-search" class="admin-input" placeholder="Buscar na Axon Store..."
                        style="flex:1;" oninput="window.axonPluginManager.renderStore()">
                </div>
                <div id="store-plugins-list" class="plugin-grid">
                    <!-- Store Items injected here -->
                </div>
            </div>
        </div>
    </div>

    <!-- Text Editor Modal -->
    <div id="text-editor-modal" class="text-editor-modal">
        <div class="text-editor-content">
            <div class="text-editor-header">
                <div class="text-editor-title" id="text-editor-title">Editar Arquivo</div>
                <div style="display:flex; gap:10px;">
                    <button class="action-button" id="text-editor-save"
                        style="border-radius:8px; width:auto; padding:0 15px; font-size:14px;"><i class="fas fa-save"
                            style="margin-right:5px;"></i> Salvar</button>
                    <button class="action-button" id="text-editor-close"
                        style="width:30px; height:30px; display:flex; align-items:center; justify-content:center; border-radius:50%;"><i
                            class="fas fa-times"></i></button>
                </div>
            </div>
            <textarea id="text-editor-textarea" class="text-editor-textarea"></textarea>
            <div style="font-size:12px; color:var(--text-color); opacity:0.7; text-align:right;"
                id="text-editor-status"></div>
        </div>
    </div>
    <script type="module">import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
        import { getFirestore, collection, addDoc, query, orderBy, limit, onSnapshot, doc, getDoc, setDoc, updateDoc, deleteDoc, getDocs, where, increment, writeBatch, collectionGroup } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";

        const firebaseConfig = {
            apiKey: "AIzaSyA4bis9CVQkl1eJDfezsvUKTx1X_kFVT4M",
            authDomain: "axon-91d0b.firebaseapp.com",
            projectId: "axon-91d0b",
            storageBucket: "axon-91d0b.firebasestorage.app",
            messagingSenderId: "701115983749",
            appId: "1:701115983749:web:9a57928b678918ffbb86ec"
        };

        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);

        const commandInput = document.getElementById('command-input');
        const interactiveOutput = document.getElementById('interactive-output');
        const anamnesisPreview = document.getElementById('anamnesis-preview');
        const examsResultsPreview = document.getElementById('exams-results-preview');
        const axonEyeResultsPreview = document.getElementById('axon-eye-results-preview');
        const apiStatus = document.getElementById('api-status');
        const micStatus = document.getElementById('mic-status');
        const cameraStatus = document.getElementById('camera-status');
        const initialMessagesContainer = document.getElementById('initial-messages');
        const monitorCopyBtn = document.getElementById('monitor-copy-btn');
        const logoutButton = document.getElementById('logout-button');
        const settingsButton = document.getElementById('settings-button');
        const themeToggleButton = document.getElementById('theme-toggle');

        const cameraModal = document.getElementById('camera-modal');
        const cameraModalTitle = document.getElementById('camera-modal-title');
        const cameraVideo = document.getElementById('camera-video');
        const cameraCanvas = document.getElementById('camera-canvas');
        const captureButton = document.getElementById('capture-button');
        const fileInput = document.getElementById('file-input');
        const uploadButton = document.getElementById('upload-button');
        const sendExamsButton = document.getElementById('send-exams-button');
        const sendAxonEyeButton = document.getElementById('send-axon-eye-button');
        const cancelCameraButton = document.getElementById('cancel-camera-button');
        const cameraSwitchButton = document.getElementById('camera-switch-button');
        const flashlightButton = document.getElementById('flashlight-button');
        const cameraCloseBtn = document.getElementById('camera-close-btn');

        const toggleAnamnesisButton = document.getElementById('toggle-anamnesis');
        const toggleExamsButton = document.getElementById('toggle-exams');
        const toggleAxonEyeButton = document.getElementById('toggle-axon-eye');

        const fullscreenModal = document.getElementById('fullscreen-modal');
        const modalImage = document.getElementById('modal-image');
        const modalClose = document.getElementsByClassName('modal-close')[0];

        const albumButton = document.getElementById('album-button');
        const albumCount = document.getElementById('album-count');
        const albumModal = document.getElementById('album-modal');
        const albumModalClose = albumModal.querySelector('.album-modal-close');
        const albumGrid = document.getElementById('album-grid');

        const btnExames = document.getElementById('btn-exames');
        const btnSee = document.getElementById('btn-see');
        const btnHd = document.getElementById('btn-hd');
        const btnCd = document.getElementById('btn-cd');
        const btnMic = document.getElementById('btn-mic');
        const btnRecords = document.getElementById('btn-records');
        const btnClear = document.getElementById('btn-clear');

        const patientListModal = document.getElementById('patient-list-modal');
        const patientList = document.getElementById('patient-list');
        const patientListClose = patientListModal.querySelector('.patient-list-close');
        const patientDetailsModal = document.getElementById('patient-details-modal');
        const patientDetailsTitle = document.getElementById('patient-details-title');
        const patientDetailsBody = document.getElementById('patient-details-body');
        const patientDetailsClose = patientDetailsModal.querySelector('.patient-details-close');
        const patientSearchInput = document.getElementById('patient-search-input');
        const btnSaveFromList = document.getElementById('btn-save-from-list');

        const loginModal = document.getElementById('login-modal');
        const loginModalUser = document.getElementById('login-modal-user');
        const loginModalPass = document.getElementById('login-modal-pass');
        const loginModalButton = document.getElementById('login-modal-button');
        const loginModalFeedback = document.getElementById('login-modal-feedback');

        const savePatientModal = document.getElementById('save-patient-modal');
        const savePatientNameInput = document.getElementById('save-patient-name');
        const savePatientDobInput = document.getElementById('save-patient-dob');
        const savePatientButton = document.getElementById('save-patient-button');
        const savePatientFeedback = document.getElementById('save-patient-feedback');
        const savePatientModalClose = savePatientModal.querySelector('.app-modal-close');

        const adminAuthModal = document.getElementById('admin-auth-modal');
        const adminAuthPass = document.getElementById('admin-auth-pass');
        const adminAuthButton = document.getElementById('admin-auth-button');
        const adminAuthFeedback = document.getElementById('admin-auth-feedback');
        const adminAuthClose = adminAuthModal.querySelector('.app-modal-close');

        const adminPanelModal = document.getElementById('admin-panel-modal');
        const adminPanelClose = adminPanelModal.querySelector('.app-modal-close');
        const adminSettingsBody = document.getElementById('admin-settings-body');
        const adminDebugBody = document.getElementById('admin-debug-body');
        const adminUsersList = document.getElementById('admin-users-list');
        const adminUserDetails = document.getElementById('admin-user-details');
        const adminUserSearch = document.getElementById('admin-user-search');
        const adminTabButtons = document.querySelectorAll('.admin-tab-btn');
        const disconnectAllUsersBtn = document.getElementById('disconnect-all-users-btn');

        const prescriptionHelperModal = document.getElementById('prescription-helper-modal');
        const prescriptionHelperTitle = document.getElementById('prescription-helper-title');
        const prescriptionHelperBody = document.getElementById('prescription-helper-body');
        const prescriptionHelperClose = prescriptionHelperModal.querySelector('.app-modal-close');

        const statusTextApi = document.querySelector('.status-text-api');
        const statusTextMic = document.querySelector('.status-text-mic');
        const statusTextCam = document.querySelector('.status-text-cam');

        // Mobile 2.0 Elements
        const mobileContainer = document.getElementById('mobile-2-0-container');
        const mobileWelcomeTitle = document.getElementById('mobile-welcome-title');
        const mobileBtnExames = document.getElementById('mobile-btn-exames');
        const mobileBtnSee = document.getElementById('mobile-btn-see');
        const mobileBtnRecords = document.getElementById('mobile-btn-records');
        const mobileBtnChat = document.getElementById('mobile-btn-chat');
        const chatboxModal = document.getElementById('chatbox-modal');
        const chatboxCloseBtn = document.getElementById('chatbox-close-btn');
        const chatboxNewChatBtn = document.getElementById('chatbox-new-chat-btn');
        const chatboxMessages = document.getElementById('chatbox-messages');
        const chatboxInput = document.getElementById('chatbox-input');
        const chatboxSendBtn = document.getElementById('chatbox-send-btn');
        const chatboxUploadBtn = document.getElementById('chatbox-upload-btn');
        const chatFileInput = document.getElementById('chat-file-input');
        const chatImagePreviews = document.getElementById('chat-image-previews');

        const customConfirmModal = document.getElementById('custom-confirm-modal');
        const mobileAnalysisLoader = document.getElementById('mobile-analysis-loader');

        // Transfer Elements
        const btnTransferFile = document.getElementById('btn-transfer-file');
        const btnCloud = document.getElementById('btn-cloud');
        const transferModal = document.getElementById('transfer-modal');
        const transferModalClose = transferModal.querySelector('.app-modal-close');
        const transferDropZone = document.getElementById('transfer-drop-zone');
        const transferFileInput = document.getElementById('transfer-file-input');
        const transferStatus = document.getElementById('transfer-status');
        const transferProgressBar = document.getElementById('transfer-progress-bar');
        const transferProgressFill = document.getElementById('transfer-progress-fill');
        const transferNotification = document.getElementById('transfer-notification');
        const transferNotificationText = document.getElementById('transfer-notification-text');
        const transferNotificationProgress = document.getElementById('transfer-notification-progress');


        let isListening = false;
        let isLoggedIn = false;
        let isUserBlocked = false;
        let isCloudDisabled = false;
        let currentUser = null;
        let recognition = null;
        let audioStream = null;
        let anamnesis = {
            qp: "", hma: "", hp: "", hf: "", hps: "",
            hgo: "", ha: "",
            ectoscopia: "",
            dados_vitais: "",
            exame_fisico: { scv: "", sr: "", sd: "", dermatologico: "" }
        };
        let examsResults = "";
        let axonEyeResults = "";
        let lastAnamnesisInfo = "";
        // let isCloudDisabled = false; // This was already here, but the instruction was to add it. I'll keep the one I added above with other state variables.
        let apiConnectionStatus = "Desconhecido";
        let unsubscribeSnapshot = null;
        let lastClearTimestamp = 0;
        let unsubscribeUserDoc = null;
        let unsubscribeSettings = null;
        let unsubscribeTransfer = null;
        let cameraStream = null;
        let capturedImages = [];
        let temporaryImgurUploads = [];
        let currentCameraFacingMode = 'environment';
        let currentMonitorView = 'anamnesis';
        let isFlashlightOn = false;
        let cameraMode = 'exams';
        const isMobileDevice = () => /Mobi|Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        const isMobile = isMobileDevice();
        let allPatients = [];
        let conversationHistory = [];
        let adminUsersData = [];
        let chatImagesToSend = [];
        let desktopHeartbeatInterval = null;
        let axonCloud = null;
        let deviceId = localStorage.getItem('axon_device_id');
        if (!deviceId) {
            deviceId = 'device_' + Math.random().toString(36).substr(2, 9);
            localStorage.setItem('axon_device_id', deviceId);
        }

        const defaultApiKeys = [
            'AIzaSyB7krrv-Jjw4hn34MIFYBcrzDa5mWB9PpU',
            'AIzaSyAJk2u0SsCv11d9mrECAkoBRafHEVGgwwg',
            'AIzaSyAG0j6JuMlR5FoCTUcNQOvNy_lcS5C9ew0'
        ];
        const defaultApiModels = [
            { id: 1, name: 'gemini-2.0-flash', vision: true },
            { id: 2, name: 'gemini-flash-lite-latest', vision: true },
            { id: 3, name: 'gemini-2.5-flash', vision: true },
            { id: 4, name: 'gemini-2.5-pro', vision: true },
            { id: 5, name: 'gemini-1.5-pro', vision: true },
            { id: 6, name: 'gemini-1.5-flash', vision: true }
        ];
        const openRouterModels = [
            { name: 'amazon/nova-2-lite-v1:free', vision: false },
            { name: 'arcee-ai/trinity-mini:free', vision: false },
            { name: 'tngtech/deepseek-r1t-chimera:free', vision: false },
            { name: 'allenai/olmo-3-32b-think:free', vision: false },
            { name: 'kwaipilot/kat-coder-pro:free', vision: false },
            { name: 'nvidia/nemotron-nano-12b-v2-vl:free', vision: true },
            { name: 'alibaba/tongyi-deepresearch-30b-a3b:free', vision: false },
            { name: 'meituan/longcat-flash-chat:free', vision: false },
            { name: 'nvidia/nemotron-nano-9b-v2:free', vision: true },
            { name: 'openai/gpt-oss-120b', vision: false },
            { name: 'openai/gpt-oss-20b', vision: false },
            { name: 'z-ai/glm-4.5-air', vision: false },
            { name: 'qwen/qwen3-coder-480b-a35b-07-25:free', vision: false },
            { name: 'moonshotai/kimi-k2:free', vision: false },
            { name: 'cognitivecomputations/dolphin-mistral-24b-venice-edition:free', vision: false }, // Uncensored (free)
            { name: 'google/gemma-3n-e2b-it:free', vision: false },
            { name: 'google/gemini-2.0-flash-exp:free', vision: true }
        ];
        const groqModels = []; // Deprecated in favor of dynamic fetching


        let globalSettings = {
            apiKeys: [...defaultApiKeys],
            apiModels: [...defaultApiModels],
            mode: 'automatic',
            manualTextModel: '',
            manualVisionModel: '',
            manualApiKey: '',
            apiProvider: 'gemini',
            openRouterKey: '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',
            groqKey: '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',
            groqModel: 'llama-3.3-70b-versatile',
            mobile2_0_enabled: false,
            customTextProvider: 'gemini',
            customTextProvider: 'gemini',
            customVisionProvider: 'gemini',
            pinataKeys: [
                { key: "5256cd6c1c0b4ccec3a9", secret: "afbed7932f0ebf5c50d88d04378359164aca3ae63a72e2628375dc02e4fcfb05" }
            ],
            bridgePermissions: {
                sendToChat: true,
                callAI: true,
                getAnamnesis: true,
                storage: true
            }
        };

        let currentApiKeyIndex = 0;
        let currentAIModel = 'gemini-2.0-flash';
        let currentVisionAIModel = 'gemini-2.5-flash-lite';
        const IMGUR_CLIENT_ID = '546c25a59c58ad7';

        // Pinata Constants
        // Pinata Constants removed in favor of globalSettings.pinataKeys

        const setTheme = (theme) => {
            localStorage.setItem('theme', theme);
            const icon = themeToggleButton.querySelector('i');
            const themeColorMeta = document.getElementById('theme-color-meta');
            const statusBarStyleMeta = document.getElementById('status-bar-style-meta');

            if (theme === 'light') {
                document.body.classList.add('light-mode');
                icon.classList.remove('fa-sun');
                icon.classList.add('fa-moon');
                if (themeColorMeta) themeColorMeta.setAttribute('content', '#f0f9ff');
                if (statusBarStyleMeta) statusBarStyleMeta.setAttribute('content', 'default');
            } else { // dark mode
                document.body.classList.remove('light-mode');
                icon.classList.remove('fa-moon');
                icon.classList.add('fa-sun');
                if (themeColorMeta) themeColorMeta.setAttribute('content', '#1a202c');
                if (statusBarStyleMeta) statusBarStyleMeta.setAttribute('content', 'black-translucent');
            }
        };

        const toggleTheme = () => {
            const currentTheme = localStorage.getItem('theme') || 'dark';
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
            setTheme(newTheme);
        };

        const getGeminiUrl = (modelName, apiKey) => `https://generativelanguage.googleapis.com/v1beta/models/${modelName}:generateContent?key=${apiKey}`;

        const validCommands = [
            '/exit', '/hear on', '/hear off', '/hd', '/cd', '/copy',
            '/ia', '/help', '/clear', '/api', '/api-set', '/register', '/exames', '/see', '/ask', '/delete', '/pdf', '/load', '/users'
        ];

        const isSpeechRecognitionSupported = () => 'webkitSpeechRecognition' in window || 'SpeechRecognition' in window;

        const initSpeechRecognition = () => {
            if (!isSpeechRecognitionSupported()) {
                appendOutput("Reconhecimento de voz nÃ£o suportado neste navegador.", "error");
                return;
            }

            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            recognition = new SpeechRecognition();
            recognition.continuous = true;
            recognition.interimResults = false;
            recognition.lang = 'pt-BR';

            recognition.onstart = () => {
                isListening = true;
                micStatus.classList.remove('status-off');
                btnMic.classList.add('active');
                btnMic.innerHTML = '<i class="fas fa-microphone"></i>';
                appendOutput("Microfone ativado. Gravando consulta...", "success");
                if (isLoggedIn && currentUser) {
                    updateMonitorStateInFirestore(currentUser, { activeView: 'anamnesis' });
                }
            };

            recognition.onresult = (event) => {
                const transcript = event.results[event.results.length - 1][0].transcript;

                if (transcript.trim()) {
                    appendOutput(`[Voz] ${transcript}`, "info");
                    processAnamnesisInfo(transcript);
                }
            };

            recognition.onerror = (event) => {
                appendOutput(`Erro no reconhecimento de voz: ${event.error}`, "error");
                stopListening();
            };

            recognition.onend = () => {
                if (isListening) {
                    recognition.start();
                }
            };
        };

        const toggleListening = () => {
            if (!isListening) {
                navigator.mediaDevices.getUserMedia({ audio: true })
                    .then(stream => {
                        audioStream = stream;
                        recognition.start();
                    })
                    .catch(err => {
                        appendOutput(`PermissÃ£o de microfone negada: ${err.message}`, "error");
                    });
            } else {
                stopListening();
            }
        };

        const stopListening = () => {
            if (recognition) {
                recognition.stop();
            }
            if (audioStream) {
                audioStream.getTracks().forEach(track => track.stop());
                audioStream = null;
            }
            isListening = false;
            micStatus.classList.add('status-off');
            btnMic.classList.remove('active');
            btnMic.innerHTML = '<i class="fas fa-microphone-slash"></i>';
            appendOutput("Microfone desativado.", "info");
        };

        const appendOutput = (text, type = "output", logToFirebase = true) => {
            const interactiveOutput = document.getElementById('interactive-output');
            if (!interactiveOutput) return;

            // Define phrases to hide if the setting is enabled
            const hiddenPhrases = [
                "tentando motor",
                "sucesso com motor",
                "verificando status",
                "motor conectado",
                "chave #",
                "status da api",
                "gemini",
                "groq",
                "openai",
                "anthropic",
                "llama",
                "conectando",
                "resposta vazia",
                "erro na chamada",
                "falha ao conectar"
            ];

            // Check debug filter
            // Check debug filter and tag message
            let isTechnicalLog = false;
            // Check if text contains any hidden phrase
            if (hiddenPhrases.some(phrase => text.toLowerCase().includes(phrase))) {
                isTechnicalLog = true;
            }

            const outputElement = document.createElement('div');
            outputElement.classList.add('command-output');

            if (type === "command") {
                outputElement.innerHTML = `<span class="prompt">></span> <span class="command">${text}</span>`;
            } else if (type === "error") {
                outputElement.innerHTML = `<span class="error">${text}</span>`;
            } else if (type === "success") {
                outputElement.innerHTML = `<span class="success">${text}</span>`;
            } else if (type === "info") {
                outputElement.innerHTML = `<span class="info">${text}</span>`;
            } else if (type === "highlight") {
                outputElement.classList.add('blocked-msg');
                outputElement.textContent = text;
            }
            else {
                outputElement.innerHTML = `<span class="${type}">${text}</span>`;
            }

            if (isTechnicalLog) {
                outputElement.classList.add('technical-log');
            }

            interactiveOutput.appendChild(outputElement);
            interactiveOutput.scrollTop = interactiveOutput.scrollHeight;

            if (logToFirebase && isLoggedIn && currentUser) {
                logInteractionToFirebase(currentUser, text, type, 'interactive');
            }
        };

        const resetInteractiveTerminal = (requireLogin = false) => {
            const elementsToKeep = [initialMessagesContainer];
            Array.from(interactiveOutput.children).forEach(child => {
                if (!elementsToKeep.includes(child) && !child.classList.contains('terminal-logo-internal')) {
                    child.remove();
                }
            });

            initialMessagesContainer.style.display = 'block';

            if (requireLogin) {
                isLoggedIn = false;
                isUserBlocked = false;
                isCloudDisabled = false;
                currentUser = null;
                localStorage.removeItem('axon_logged_in_user');
                if (unsubscribeSnapshot) {
                    unsubscribeSnapshot();
                    unsubscribeSnapshot = null;
                }
                if (unsubscribeUserDoc) {
                    unsubscribeUserDoc();
                    unsubscribeUserDoc = null;
                }
                if (unsubscribeTransfer) {
                    unsubscribeTransfer();
                    unsubscribeTransfer = null;
                }
                initialMessagesContainer.innerHTML = `
                    <pre class="info">
 â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•—  â–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—
â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â•šâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•‘
â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘ â•šâ–ˆâ–ˆâ–ˆâ•”â• â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â–ˆâ–ˆâ•— â–ˆâ–ˆâ•‘
â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘ â–ˆâ–ˆâ•”â–ˆâ–ˆâ•— â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘
â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â• â–ˆâ–ˆâ•—â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘ â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•‘
â•šâ•â•  â•šâ•â•â•šâ•â•  â•šâ•â• â•šâ•â•â•â•â•â• â•šâ•â•  â•šâ•â•â•â•
                    </pre>
                    <span class="info">Axon - Assistente MÃ©dico v1.6</span><br>
                    <span class="info">Aguardando autenticaÃ§Ã£o...</span><br><br>
                `;
                loginModal.style.display = 'flex';
                loginModalUser.focus();
            } else {
                initialMessagesContainer.innerHTML = `
                    <pre class="info">
 â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•—  â–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—
â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â•šâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•‘
â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘ â•šâ–ˆâ–ˆâ–ˆâ•”â• â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â–ˆâ–ˆâ•— â–ˆâ–ˆâ•‘
â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•‘ â–ˆâ–ˆâ•”â–ˆâ–ˆâ•— â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘
â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â• â–ˆâ–ˆâ•—â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘ â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•‘
â•šâ•â•  â•šâ•â•â•šâ•â•  â•šâ•â• â•šâ•â•â•â•â•â• â•šâ•â•  â•šâ•â•â•â•
                    </pre>
                    <span class="info">Axon - Assistente MÃ©dico v1.6</span><br>
                    <span class="info">Digite </span><span class="command">/help</span><span class="info"> para ver os comandos disponÃ­veis</span><br>
                `;
            }
            interactiveOutput.scrollTop = interactiveOutput.scrollHeight;
        };

        const performSessionClear = async () => {
            // Immediate invalidation to prevent race conditions
            lastClearTimestamp = Date.now();

            // Reset local state immediately
            anamnesis = {
                qp: "", hma: "", hp: "", hf: "", hps: "",
                hgo: "", ha: "",
                ectoscopia: "",
                dados_vitais: "",
                exame_fisico: { scv: "", sr: "", sd: "", dermatologico: "" }
            };
            examsResults = ""; axonEyeResults = ""; conversationHistory = [];
            lastAnamnesisInfo = "";

            updateAnamnesisPreview(false);
            updateExamsResultsPreview(false);
            updateAxonEyeResultsPreview(false);

            await clearTemporaryUploads();

            if (currentUser) {
                const userRef = doc(db, "sessions", currentUser);
                const resetData = {
                    anamnesis: {
                        qp: "", hma: "", hp: "", hf: "", hps: "",
                        hgo: "", ha: "",
                        ectoscopia: "",
                        dados_vitais: "",
                        exame_fisico: { scv: "", sr: "", sd: "", dermatologico: "" }
                    },
                    examsResults: "",
                    axonEyeResults: "",
                    conversationHistory: [],
                    isAnalyzing: { status: false, type: null }
                };
                try {
                    await updateDoc(userRef, resetData);
                } catch (e) {
                    console.error("Erro ao limpar sessÃ£o no Firestore:", e);
                }
            }

            if (window.clearFreeModeData) await window.clearFreeModeData();

            resetInteractiveTerminal(false);
            appendOutput("SessÃ£o limpa.", "success");
        };

        const resetSession = async () => {
            await performSessionClear();
        };

        const logoutUser = async () => {
            appendOutput("Fazendo logout...", "info", false);
            if (desktopHeartbeatInterval) {
                clearInterval(desktopHeartbeatInterval);
                desktopHeartbeatInterval = null;
            }
            await clearTemporaryUploads();
            if (currentUser) {
                try {
                    await deleteDoc(doc(db, "sessions", currentUser));
                } catch (e) {
                    console.error("Could not delete session doc on logout:", e);
                }
            }
            if (unsubscribeUserDoc) {
                unsubscribeUserDoc();
                unsubscribeUserDoc = null;
            }
            if (unsubscribeTransfer) {
                unsubscribeTransfer();
                unsubscribeTransfer = null;
            }
            stopListening();
            resetInteractiveTerminal(true);
        };

        const updateAnamnesisPreview = (logToFirebase = true) => {
            const hasValue = (val) => val && val !== "Nenhuma" && val.trim() !== "";

            let previewHTML = `
                <div class="anamnesis-content">
                    <div class="section-title">Queixa Principal (QP):</div>
                    <div>${anamnesis.qp || "Ainda nÃ£o informado."}</div><br>
                    <div class="section-title">HistÃ³ria da MolÃ©stia Atual (HMA):</div>
                    <div>${anamnesis.hma || "Ainda nÃ£o informado."}</div><br>
                    <div class="section-title">HistÃ³ria PatolÃ³gica (HP):</div>
                    <div>${anamnesis.hp || "Ainda nÃ£o informado."}</div><br>
                    <div class="section-title">HistÃ³ria Familiar (HF):</div>
                    <div>${anamnesis.hf || "Ainda nÃ£o informado."}</div><br>
                    <div class="section-title">HistÃ³ria Psicossocial (HPS):</div>
                    <div>${anamnesis.hps || "Ainda nÃ£o informado."}</div>
                    
                    ${hasValue(anamnesis.hgo) ? `<br><div class="section-title">HistÃ³ria Gineco-obstÃ©trica (HGO):</div><div>${anamnesis.hgo}</div>` : ''}
                    ${hasValue(anamnesis.ha) ? `<br><div class="section-title">HistÃ³ria Alimentar (HA):</div><div>${anamnesis.ha}</div>` : ''}

                    <div style="margin: 15px 0; border-top: 1px solid var(--border-color); opacity: 0.3;"></div>

                    <div class="section-title">ECTOSCOPIA:</div>
                    <div>${anamnesis.ectoscopia || "Ainda nÃ£o informado."}</div><br>

                    <div class="section-title">DADOS VITAIS:</div>
                    <div>${anamnesis.dados_vitais || "Ainda nÃ£o informado."}</div><br>

                    <div class="section-title">EXAME FÃSICO:</div>
                    <div style="padding-left: 10px;">
                        <div><span style="font-weight:600; opacity:0.8;">SCV:</span> ${anamnesis.exame_fisico?.scv || "NÃ£o informado"}</div>
                        <div><span style="font-weight:600; opacity:0.8;">SR:</span> ${anamnesis.exame_fisico?.sr || "NÃ£o informado"}</div>
                        <div><span style="font-weight:600; opacity:0.8;">SD:</span> ${anamnesis.exame_fisico?.sd || "NÃ£o informado"}</div>
                        ${hasValue(anamnesis.exame_fisico?.dermatologico) ? `<div><span style="font-weight:600; opacity:0.8; color:var(--highlight-color);">DermatolÃ³gico:</span> ${anamnesis.exame_fisico.dermatologico}</div>` : ''}
                    </div>
                </div>`;
            anamnesisPreview.innerHTML = previewHTML;
            if (logToFirebase && isLoggedIn && currentUser) {
                saveAnamnesisToFirestore(currentUser, anamnesis);
            }
        };

        const updateExamsResultsPreview = (logToFirebase = true) => {
            let formattedResults = '';
            if (examsResults) {
                formattedResults = examsResults.split('\n')
                    .filter(line => line.trim() !== '')
                    .map(line => {
                        if (/\((Alterado|Anormal)\)/i.test(line)) {
                            const cleanLine = line.replace(/\((Alterado|Anormal)\)/gi, '').trim();
                            return `<div class="output">${cleanLine} <span class="altered-text">(Alterado)</span></div>`;
                        }
                        return `<div class="output">${line.trim()}</div>`;
                    }).join('');
            }
            examsResultsPreview.innerHTML = `<div class="section-title">RESULTADOS DOS EXAMES:</div>${formattedResults || '<div class="info">Nenhum exame analisado ainda.</div>'}`;
            if (logToFirebase && isLoggedIn && currentUser) {
                saveExamsResultsToFirestore(currentUser, examsResults);
            }
        };

        const updateAxonEyeResultsPreview = (logToFirebase = true) => {
            let formattedResults = '';
            let imageHtml = '';
            if (temporaryImgurUploads.length > 0) {
                imageHtml = `<div class="patient-images-grid" style="margin-top: 15px;">`;
                temporaryImgurUploads.forEach(img => {
                    imageHtml += `<div class="patient-image-item"><img src="${img.link}" class="patient-image" onclick="openFullscreenModal('${img.link}')" alt="Imagem Analisada"></div>`;
                });
                imageHtml += `</div>`;
            }
            if (axonEyeResults) {
                const boldedResults = axonEyeResults.replace(/\*(.*?)\*/g, '<b>$1</b>');
                const impressionRegex = /(ImpressÃ£o DiagnÃ³stica|InterpretaÃ§Ã£o ClÃ­nica|DiagnÃ³sticos Diferenciais):\s*(.*)/i;
                let match = boldedResults.match(impressionRegex);
                if (match) {
                    const title = match[1];
                    const content = match[2].trim();
                    const preText = boldedResults.substring(0, match.index).trim();
                    const postText = boldedResults.substring(match.index + match[0].length).trim();
                    formattedResults += `<div class="output">${preText.split('\n').map(line => line.trim()).filter(line => line).join('<br>')}</div>`;
                    formattedResults += `<div class="axon-eye-title">${title}</div>`;
                    formattedResults += `<div class="output">${content}</div>`;
                    formattedResults += `<div class="output">${postText.split('\n').map(line => line.trim()).filter(line => line).join('<br>')}</div>`;
                } else {
                    formattedResults = boldedResults.split('\n').filter(line => line.trim() !== '').map(line => `<div class="output">${line.trim()}</div>`).join('');
                }
            }
            axonEyeResultsPreview.innerHTML = `<div class="section-title">ANÃLISE AXON EYE:</div>${formattedResults || '<div class="info">Nenhuma anÃ¡lise visual feita ainda.</div>'}${imageHtml}`;
            if (logToFirebase && isLoggedIn && currentUser) {
                saveAxonEyeResultsToFirestore(currentUser, axonEyeResults);
            }
        };

        const toggleMonitorView = (view, fromRemote = false) => {
            currentMonitorView = view;
            anamnesisPreview.style.display = 'none';
            examsResultsPreview.style.display = 'none';
            axonEyeResultsPreview.style.display = 'none';

            // This logic is for classic mode only
            if (!isMobile || !globalSettings.mobile2_0_enabled) {
                if (view === 'camera' && !fromRemote) {
                    cameraModal.style.display = 'flex';
                } else {
                    cameraModal.style.display = 'none';
                    stopCameraStreamOnly();
                }
            }

            toggleAnamnesisButton.classList.remove('active');
            toggleExamsButton.classList.remove('active');
            toggleAxonEyeButton.classList.remove('active');
            if (view === 'anamnesis') {
                anamnesisPreview.style.display = 'block';
                toggleAnamnesisButton.classList.add('active');
            } else if (view === 'exams') {
                examsResultsPreview.style.display = 'block';
                toggleExamsButton.classList.add('active');
            } else if (view === 'axon-eye') {
                axonEyeResultsPreview.style.display = 'block';
                toggleAxonEyeButton.classList.add('active');
            }
            if (!fromRemote && isLoggedIn && currentUser) {
                updateMonitorStateInFirestore(currentUser, { activeView: view });
            }
        };

        const incrementUserUsage = async (type) => {
            if (!currentUser || !isLoggedIn) return;
            const userRef = doc(db, "users", currentUser);
            try {
                const updateData = {};
                if (type === 'text') {
                    updateData.textRequests = increment(1);
                } else if (type === 'vision') {
                    updateData.visionRequests = increment(1);
                }
                await updateDoc(userRef, updateData);
            } catch (e) {
                console.error("Erro ao incrementar uso do usuÃ¡rio:", e);
            }
        };

        const compressImage = (base64Str, maxWidth = 1024, quality = 0.7) => {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.src = base64Str;
                img.onload = () => {
                    let { width, height } = img;
                    if (width > maxWidth) {
                        height = (maxWidth / width) * height;
                        width = maxWidth;
                    }

                    const canvas = document.createElement('canvas');
                    canvas.width = width;
                    canvas.height = height;

                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0, width, height);

                    resolve(canvas.toDataURL('image/jpeg', quality));
                };
                img.onerror = (error) => reject(error);
            });
        };

        const callOpenRouterAPI = async (prompt, images = []) => {
            const modelName = globalSettings.openRouterModel || 'x-ai/grok-4.1-fast:free';
            const apiKey = globalSettings.openRouterKey;

            appendOutput(`Conectando via OpenRouter (${modelName})...`, "info", false);

            try {
                let messages = [];

                if (images.length > 0) {
                    const contentArray = [
                        { type: "text", text: prompt }
                    ];

                    images.forEach(img => {
                        contentArray.push({
                            type: "image_url",
                            image_url: { url: img }
                        });
                    });

                    messages = [{ role: "user", content: contentArray }];
                } else {
                    messages = [{ role: "user", content: prompt }];
                }

                const response = await fetch("https://openrouter.ai/api/v1/chat/completions", {
                    method: "POST",
                    headers: {
                        "Authorization": `Bearer ${apiKey}`,
                        "Content-Type": "application/json",
                        "HTTP-Referer": window.location.href,
                        "X-Title": "Axon A.I"
                    },
                    body: JSON.stringify({
                        model: modelName,
                        messages: messages
                    })
                });

                if (response.ok) {
                    const data = await response.json();
                    const content = data.choices?.[0]?.message?.content;
                    if (content) {
                        await incrementUserUsage(images.length > 0 ? 'vision' : 'text');
                        appendOutput(`Sucesso via OpenRouter.`, "success", false);
                        return content;
                    }
                    throw new Error("Resposta vazia do OpenRouter.");
                } else {
                    const errorData = await response.json().catch(() => ({}));
                    throw new Error(errorData.error?.message || `Erro OpenRouter: ${response.status}`);
                }
            } catch (e) {
                console.error("Erro na chamada OpenRouter:", e);
                throw e;
            }
        };

        const callGroqAPI = async (prompt, images = []) => {
            const isVision = images.length > 0;
            const modelName = isVision
                ? (globalSettings.groqVisionModel || 'llama-3.2-90b-vision-preview')
                : (globalSettings.groqTextModel || 'llama-3.3-70b-versatile');

            const apiKey = globalSettings.groqKey;

            appendOutput(`Conectando via Groq (${modelName})...`, "info", false);

            try {
                let messages = [];

                if (images.length > 0) {
                    appendOutput(`Comprimindo ${images.length} imagem(ns) para envio...`, "info", false);
                    const compressedImages = await Promise.all(images.map(img => compressImage(img, 1024, 0.7)));

                    const contentArray = [
                        { type: "text", text: prompt }
                    ];

                    compressedImages.forEach(img => {
                        contentArray.push({
                            type: "image_url",
                            image_url: {
                                url: img
                            }
                        });
                    });

                    messages = [{ role: "user", content: contentArray }];
                } else {
                    messages = [{ role: "user", content: prompt }];
                }

                const response = await fetch("https://api.groq.com/openai/v1/chat/completions", {
                    method: "POST",
                    headers: {
                        "Authorization": `Bearer ${apiKey}`,
                        "Content-Type": "application/json"
                    },
                    body: JSON.stringify({
                        model: modelName,
                        messages: messages,
                        temperature: 1,
                        max_tokens: 8192,
                        top_p: 1,
                        stream: false,
                        stop: null
                    })
                });

                if (response.ok) {
                    const data = await response.json();
                    const content = data.choices?.[0]?.message?.content;
                    if (content) {
                        await incrementUserUsage(images.length > 0 ? 'vision' : 'text');
                        appendOutput(`Sucesso via Groq.`, "success", false);
                        return content;
                    }
                    throw new Error("Resposta vazia do Groq.");
                } else {
                    const errorData = await response.json().catch(() => ({}));
                    throw new Error(errorData.error?.message || `Erro Groq: ${response.status}`);
                }
            } catch (e) {
                console.error("Erro na chamada Groq:", e);
                throw e;
            }
        };

        window.toggleUserCloudAccess = async (username, shouldDisable) => {
            try {
                const userRef = doc(db, "users", username);
                await updateDoc(userRef, { isCloudDisabled: shouldDisable });
                // Optimistic update
                const userIdx = adminUsersData.findIndex(u => u.username === username);
                if (userIdx !== -1) {
                    adminUsersData[userIdx].isCloudDisabled = shouldDisable;
                    window.selectAdminUser(username); // Re-render details
                }
            } catch (e) {
                console.error("Erro ao alterar acesso cloud:", e);
                alert("Erro ao alterar acesso cloud: " + e.message);
            }
        };

        const getRandomPinataKey = () => {
            const keys = globalSettings.pinataKeys;
            if (!keys || keys.length === 0) return null;
            return keys[Math.floor(Math.random() * keys.length)];
        };

        const unpinFromPinata = async (ipfsHash) => {
            if (!globalSettings.pinataKeys || globalSettings.pinataKeys.length === 0) return false;

            for (const key of globalSettings.pinataKeys) {
                try {
                    const response = await fetch(`https://api.pinata.cloud/pinning/unpin/${ipfsHash}`, {
                        method: 'DELETE',
                        headers: {
                            'pinata_api_key': key.key,
                            'pinata_secret_api_key': key.secret
                        }
                    });
                    if (response.ok) return true;
                } catch (e) { console.error("Unpin failed with key", key, e); }
            }
            return false;
        };

        const uploadToPinata = async (file, onProgress) => {
            let keys = [];
            if (globalSettings.pinataKeys && globalSettings.pinataKeys.length > 0) {
                keys = globalSettings.pinataKeys;
            } else {
                const k = getRandomPinataKey();
                if (k) keys.push(k);
            }

            if (keys.length === 0) return Promise.reject(new Error("Nenhuma chave Pinata configurada."));

            let lastError = null;

            // Try each key
            for (const pinataKey of keys) {
                try {
                    return await new Promise((resolve, reject) => {
                        const url = `https://api.pinata.cloud/pinning/pinFileToIPFS`;
                        const data = new FormData();
                        data.append('file', file);

                        const xhr = new XMLHttpRequest();
                        xhr.upload.addEventListener("progress", (event) => {
                            if (event.lengthComputable && onProgress) {
                                const percentComplete = (event.loaded / event.total) * 100;
                                onProgress(percentComplete);
                            }
                        });

                        xhr.onload = () => {
                            if (xhr.status === 200) {
                                const result = JSON.parse(xhr.responseText);
                                resolve({ ipfsHash: result.IpfsHash, pinataKey: pinataKey });
                            } else {
                                reject(new Error(`Erro Pinata (${xhr.status}): ${xhr.statusText}`));
                            }
                        };
                        xhr.onerror = () => reject(new Error("Erro de rede no upload para Pinata."));
                        xhr.open("POST", url);
                        xhr.setRequestHeader("pinata_api_key", pinataKey.key);
                        xhr.setRequestHeader("pinata_secret_api_key", pinataKey.secret);
                        xhr.send(data);
                    });
                } catch (e) {
                    console.warn(`Upload falhou com a chave ${pinataKey.label || 'Standard'}:`, e);
                    lastError = e;
                    // Continue to next key
                }
            }

            // If all failed
            // Update UI with error badge if needed?
            const errorBadge = document.getElementById('api-error-badge');
            if (errorBadge) errorBadge.style.display = 'block'; // Assuming we create this element somewhere or user creates it?
            // User asked: "Display an exclamation badge for APIs that encounter these errors."
            // I should inject the Logic for the badge here or globally.
            // Let's assume a generic badge toggler function or ID.
            updateSystemStatus('pinata', 'error');
            throw lastError || new Error("Falha no upload com todas as chaves.");
        };

        const updateSystemStatus = (type, status) => {
            // Simple implementation
            const badge = document.getElementById('system-status-badge'); // Allow user to style this later
            if (status === 'error' && badge) {
                badge.style.display = 'flex';
                badge.title = "Erro no sistema (" + type + ")";
            }
        };

        const callGeminiAPI = async (prompt) => {
            let provider = globalSettings.apiProvider;
            if (provider === 'custom') {
                provider = globalSettings.customTextProvider || 'gemini';
            }

            if (provider === 'openrouter') {
                return await callOpenRouterAPI(prompt);
            }
            if (provider === 'groq') {
                return await callGroqAPI(prompt);
            }

            let strategyModels = [];
            let keysToTry = [];

            if (globalSettings.mode === 'manual') {
                if (globalSettings.manualTextModel && globalSettings.manualApiKey) {
                    strategyModels = [globalSettings.manualTextModel];
                    keysToTry = [globalSettings.manualApiKey];
                } else {
                    throw new Error("Modo manual ativo, mas modelo ou chave nÃ£o configurados.");
                }
            } else {
                const preferredOrder = ['gemini-2.0-flash', 'gemini-flash-lite-latest', 'gemini-2.5-flash', 'gemini-2.5-pro'];
                const availableModelNames = globalSettings.apiModels.map(m => m.name);
                const activePreferred = preferredOrder.filter(name => availableModelNames.includes(name));
                const others = availableModelNames.filter(name => !preferredOrder.includes(name));
                strategyModels = [...activePreferred, ...others];
                keysToTry = globalSettings.apiKeys;
            }

            let lastError = null;

            for (const modelName of strategyModels) {
                for (let i = 0; i < keysToTry.length; i++) {
                    const keyIndex = (currentApiKeyIndex + i) % keysToTry.length;
                    const apiKeyToTry = keysToTry[keyIndex];

                    if (!isMobile || !globalSettings.mobile2_0_enabled) {
                        appendOutput(`Tentando motor ${modelName} (Chave #${keyIndex + 1})...`, "info", false);
                    }

                    try {
                        const url = getGeminiUrl(modelName, apiKeyToTry);
                        const response = await fetch(url, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ contents: [{ parts: [{ text: prompt }] }] })
                        });

                        if (response.ok) {
                            const data = await response.json();
                            if (globalSettings.mode === 'automatic') {
                                currentApiKeyIndex = keyIndex;
                            }
                            await incrementUserUsage('text');
                            if (!isMobile || !globalSettings.mobile2_0_enabled) {
                                appendOutput(`Sucesso com motor ${modelName}.`, "success", false);
                            }
                            return data.candidates?.[0]?.content?.parts?.[0]?.text || "NÃ£o foi possÃ­vel obter uma resposta.";
                        }

                        const errorData = await response.json().catch(() => ({ error: { message: `HTTP error! status: ${response.status}` } }));
                        lastError = new Error(errorData.error?.message || `Erro desconhecido (${response.status})`);
                        console.warn(`Falha com motor ${modelName} chave ${keyIndex}: ${lastError.message}`);

                    } catch (error) {
                        lastError = error;
                        console.warn(`Falha de rede motor ${modelName} chave ${keyIndex}: ${error.message}`);
                    }
                }
            }

            console.error("Erro final na chamada da API de texto:", lastError);
            throw lastError || new Error("Todas as tentativas de chaves e motores falharam.");
        };

        const callVisionAPI = async (imageUrls, prompt) => {
            let provider = globalSettings.apiProvider;
            if (provider === 'custom') {
                provider = globalSettings.customVisionProvider || 'gemini';
            }

            if (provider === 'openrouter') {
                return await callOpenRouterAPI(prompt, imageUrls);
            }
            if (provider === 'groq') {
                return await callGroqAPI(prompt, imageUrls);
            }

            let strategyModels = [];
            let keysToTry = [];

            if (globalSettings.mode === 'manual') {
                if (globalSettings.manualVisionModel && globalSettings.manualApiKey) {
                    strategyModels = [globalSettings.manualVisionModel];
                    keysToTry = [globalSettings.manualApiKey];
                } else {
                    throw new Error("Modo manual ativo, mas modelo de visÃ£o ou chave nÃ£o configurados.");
                }
            } else {
                const preferredOrder = ['gemini-2.0-flash', 'gemini-flash-lite-latest', 'gemini-2.5-flash', 'gemini-2.5-pro'];
                const availableModelNames = globalSettings.apiModels.filter(m => m.vision).map(m => m.name);

                const activePreferred = preferredOrder.filter(name => availableModelNames.includes(name));
                const others = availableModelNames.filter(name => !preferredOrder.includes(name));

                strategyModels = [...activePreferred, ...others];
                keysToTry = globalSettings.apiKeys;
            }

            let lastError = null;

            for (const modelName of strategyModels) {
                const imageParts = imageUrls.map(url => ({ inlineData: { mimeType: 'image/jpeg', data: url.split(',')[1] } }));
                const textPart = { text: prompt };

                for (let i = 0; i < keysToTry.length; i++) {
                    const keyIndex = (currentApiKeyIndex + i) % keysToTry.length;
                    const apiKeyToTry = keysToTry[keyIndex];

                    if (!isMobile || !globalSettings.mobile2_0_enabled) {
                        appendOutput(`Tentando motor de visÃ£o ${modelName} (Chave #${keyIndex + 1})...`, "info", false);
                    }

                    try {
                        const url = getGeminiUrl(modelName, apiKeyToTry);
                        const response = await fetch(url, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ contents: [{ parts: [...imageParts, textPart] }] })
                        });

                        if (response.ok) {
                            const data = await response.json();
                            if (globalSettings.mode === 'automatic') {
                                currentApiKeyIndex = keyIndex;
                            }
                            await incrementUserUsage('vision');
                            if (!isMobile || !globalSettings.mobile2_0_enabled) {
                                appendOutput(`Sucesso com motor de visÃ£o ${modelName}.`, "success", false);
                            }
                            return data.candidates?.[0]?.content?.parts?.[0]?.text || "NÃ£o foi possÃ­vel obter uma resposta da anÃ¡lise de imagem.";
                        }

                        const errorData = await response.json().catch(() => ({ error: { message: `HTTP error! status: ${response.status}` } }));
                        lastError = new Error(errorData.error?.message || `Erro desconhecido na API de VisÃ£o (${response.status})`);
                        console.warn(`Falha visÃ£o motor ${modelName} chave ${keyIndex}: ${lastError.message}`);

                    } catch (error) {
                        lastError = error;
                        console.warn(`Falha de rede visÃ£o motor ${modelName} chave ${keyIndex}: ${error.message}`);
                    }
                }
            }

            console.error("Erro final na chamada da API de visÃ£o:", lastError);
            throw lastError || new Error("Todas as tentativas de chaves e motores de visÃ£o falharam.");
        };

        const processAnamnesisInfo = async (info) => {
            lastAnamnesisInfo = info;
            const prompt = `VocÃª Ã© um assistente mÃ©dico especialista em semiologia. Sua tarefa Ã© redigir uma anamnese mÃ©dica profissional e estruturar o exame fÃ­sico, organizando as informaÃ§Ãµes fornecidas em seÃ§Ãµes adequadas. A anamnese deve ser bem redigida, coesa e utilizar termos mÃ©dicos apropriados.

            Contexto da consulta atual (informaÃ§Ãµes existentes):
            - QP (Queixa Principal): "${anamnesis.qp || "Nenhuma"}"
            - HMA (HistÃ³ria da MolÃ©stia Atual): "${anamnesis.hma || "Nenhuma"}"
            - HP (HistÃ³ria PatolÃ³gica): "${anamnesis.hp || "Nenhuma"}"
            - HF (HistÃ³ria Familiar): "${anamnesis.hf || "Nenhuma"}"
            - HPS (HistÃ³ria Psicossocial): "${anamnesis.hps || "Nenhuma"}"
            - HGO (HistÃ³ria Gineco-obstÃ©trica): "${anamnesis.hgo || "Nenhuma"}"
            - HA (HistÃ³ria Alimentar): "${anamnesis.ha || "Nenhuma"}"
            
            - ECTOSCOPIA: "${anamnesis.ectoscopia || "Nenhuma"}"
            - DADOS VITAIS: "${anamnesis.dados_vitais || "Nenhuma"}"

            - EXAME FÃSICO:
              -- SCV (Cardiovascular): "${anamnesis.exame_fisico?.scv || "Nenhuma"}"
              -- SR (RespiratÃ³rio): "${anamnesis.exame_fisico?.sr || "Nenhuma"}"
              -- SD (Digestivo): "${anamnesis.exame_fisico?.sd || "Nenhuma"}"
              -- DermatolÃ³gico: "${anamnesis.exame_fisico?.dermatologico || "Nenhuma"}"

            Nova informaÃ§Ã£o recebida (diÃ¡logo mÃ©dico-paciente): "${info}"

            InstruÃ§Ãµes cruciais:
            1.  **Analise o contexto completo**: Considere tanto as informaÃ§Ãµes existentes quanto a "nova informaÃ§Ã£o recebida" para construir a anamnese mais precisa.
            2.  **Ordene logicamente**: Integre a nova informaÃ§Ã£o Ã  seÃ§Ã£o apropriada (QP, HMA, HP, HF, HPS, HGO, HA, Ectoscopia, Dados Vitais, Exame FÃ­sico).
            3.  **Seja Fiel ao ConteÃºdo**: NÃƒO adicione, invente ou presuma informaÃ§Ãµes que nÃ£o foram explicitamente ditas.
            4.  **Distinga os interlocutores**: Extraia APENAS as respostas e relatos do paciente ou observaÃ§Ãµes ditadas pelo mÃ©dico. Ignore perguntas.
            5.  **Atualize, nÃ£o substitua**: Integre a nova informaÃ§Ã£o Ã  seÃ§Ã£o apropriada, complementando o que jÃ¡ existe.
            6.  **Filtro Rigoroso**: Ignore saudaÃ§Ãµes e conversas nÃ£o clÃ­nicas.
            7.  **Exame FÃ­sico**:
                - Separe em SCV, SR, SD.
                - **DermatolÃ³gico**: Preencha APENAS se houver descriÃ§Ã£o explÃ­cita de lesÃµes de pele ou anexos. Caso contrÃ¡rio, deixe como string vazia.

            Formato da Resposta: Retorne EXCLUSIVAMENTE um objeto JSON com a seguinte estrutura:
            {
               "qp": "...",
               "hma": "...",
               "hp": "...",
               "hf": "...",
               "hps": "...",
               "hgo": "...",
               "ha": "... (descreva hÃ¡bitos alimentares se citados)",
               "ectoscopia": "... (estado geral, fÃ¡cies, atitude, etc)",
               "dados_vitais": "... (PA, FC, FR, Temp, SatO2 - se citados)",
               "exame_fisico": {
                   "scv": "...",
                   "sr": "...",
                   "sd": "...",
                   "dermatologico": "..." (ou vazio)
               }
            }`;
            try {
                const callTimestamp = Date.now();
                const response = await callGeminiAPI(prompt);

                if (callTimestamp < lastClearTimestamp) {
                    console.warn("Ignorando resposta da IA pois a sessÃ£o foi limpa.");
                    return;
                }

                const jsonStart = response.indexOf('{');
                const jsonEnd = response.lastIndexOf('}') + 1;
                const jsonString = response.substring(jsonStart, jsonEnd);
                const updatedAnamnesis = JSON.parse(jsonString);

                // Merge logic to ensure we don't lose sub-objects if AI sends partial
                anamnesis = {
                    qp: updatedAnamnesis.qp || anamnesis.qp || "",
                    hma: updatedAnamnesis.hma || anamnesis.hma || "",
                    hp: updatedAnamnesis.hp || anamnesis.hp || "",
                    hf: updatedAnamnesis.hf || anamnesis.hf || "",
                    hps: updatedAnamnesis.hps || anamnesis.hps || "",
                    hgo: updatedAnamnesis.hgo || anamnesis.hgo || "",
                    ha: updatedAnamnesis.ha || anamnesis.ha || "",
                    ectoscopia: updatedAnamnesis.ectoscopia || anamnesis.ectoscopia || "",
                    dados_vitais: updatedAnamnesis.dados_vitais || anamnesis.dados_vitais || "",
                    exame_fisico: {
                        scv: updatedAnamnesis.exame_fisico?.scv || anamnesis.exame_fisico?.scv || "",
                        sr: updatedAnamnesis.exame_fisico?.sr || anamnesis.exame_fisico?.sr || "",
                        sd: updatedAnamnesis.exame_fisico?.sd || anamnesis.exame_fisico?.sd || "",
                        dermatologico: updatedAnamnesis.exame_fisico?.dermatologico || anamnesis.exame_fisico?.dermatologico || ""
                    }
                };
                updateAnamnesisPreview();
                appendOutput("Anamnese e Exame FÃ­sico atualizados.", "success");
            } catch (error) {
                appendOutput(`Erro ao atualizar a anamnese: ${error.message}.`, "error");
            }
        };

        const generateDiagnosticHypotheses = async () => {
            const prompt = `Com base na anamnese: ${JSON.stringify(anamnesis)}, nos exames: ${examsResults || "Nenhum"}, e na anÃ¡lise visual: ${axonEyeResults || "Nenhuma"}, liste as hipÃ³teses diagnÃ³sticas em ordem de probabilidade. Seja tÃ©cnico e resumido. Formate palavras importantes ou tÃ­tulos com asteriscos (ex: *HipÃ³tese Principal*). Retorne apenas a lista.`;
            try {
                const response = await callGeminiAPI(prompt);
                const boldedResponse = response.replace(/\*(.*?)\*/g, '<b>$1</b>');
                const formattedDiagnosis = boldedResponse.split('\n').filter(item => item.trim()).map(item => `<div class="diagnosis-item">${item.trim()}</div>`).join('');
                appendOutput(`<div class="conduct-title">HIPÃ“TESES DIAGNÃ“STICAS:</div>${formattedDiagnosis}`, "output");
            } catch (error) {
                appendOutput(`Erro ao gerar hipÃ³teses: ${error.message}`, "error");
            }
        };

        const generateMedicalConduct = async () => {
            const prompt = `Com base na anamnese: ${JSON.stringify(anamnesis)}, exames: ${examsResults || "Nenhum"}, e anÃ¡lise visual: ${axonEyeResults || "Nenhuma"}, proponha uma conduta mÃ©dica completa. Formate palavras importantes ou tÃ­tulos com asteriscos (ex: *MedicaÃ§Ã£o Sugerida*).
Use EXATAMENTE os seguintes tÃ­tulos para cada seÃ§Ã£o, na ordem apresentada, mesmo que a seÃ§Ã£o nÃ£o tenha conteÃºdo: 
1. CONDUTA FARMACOLÃ“GICA (SUS):
2. EXAMES COMPLEMENTARES (SUS):
3. CONDUTAS NÃƒO FARMACOLÃ“GICAS (SUS):
4. RECOMENDAÃ‡Ã•ES:
Seja tÃ©cnico, objetivo e resumido.`;
            try {
                const response = await callGeminiAPI(prompt);
                const boldedResponse = response.replace(/\*(.*?)\*/g, '<b>$1</b>');
                const formattedConduct = boldedResponse
                    .replace(/(?:<[bB]>\s*)?(?:[\d\.]+\s*)?[\*#]*\s*CONDUTA\s+FARMACOLÃ“GICA(?:\s*\(SUS\))?[\s\:\*#]*(?:<\/[bB]>)?/gi, '<div class="conduct-title" data-category="CONDUTA FARMACOLÃ“GICA (SUS)">CONDUTA FARMACOLÃ“GICA (SUS): <span style="font-size: 11px; opacity: 0.7; font-weight: normal; margin-left: 5px;">(Clique para ver conduta pronta)</span></div>')
                    .replace(/(?:<[bB]>\s*)?(?:[\d\.]+\s*)?[\*#]*\s*EXAMES\s+COMPLEMENTARES(?:\s*\(SUS\))?[\s\:\*#]*(?:<\/[bB]>)?/gi, '<div class="conduct-title" data-category="EXAMES COMPLEMENTARES (SUS)">EXAMES COMPLEMENTARES (SUS): <span style="font-size: 11px; opacity: 0.7; font-weight: normal; margin-left: 5px;">(Clique para ver conduta pronta)</span></div>')
                    .replace(/(?:<[bB]>\s*)?(?:[\d\.]+\s*)?[\*#]*\s*CONDUTAS\s+NÃƒO\s+FARMACOLÃ“GICAS(?:\s*\(SUS\))?[\s\:\*#]*(?:<\/[bB]>)?/gi, '<div class="conduct-title" data-category="CONDUTAS NÃƒO FARMACOLÃ“GICAS (SUS)">CONDUTAS NÃƒO FARMACOLÃ“GICAS (SUS): <span style="font-size: 11px; opacity: 0.7; font-weight: normal; margin-left: 5px;">(Clique para ver conduta pronta)</span></div>')
                    .replace(/(?:<[bB]>\s*)?(?:[\d\.]+\s*)?[\*#]*\s*RECOMENDAÃ‡Ã•ES[\s\:\*#]*(?:<\/[bB]>)?/gi, '<div class="conduct-title" data-category="RECOMENDAÃ‡Ã•ES">RECOMENDAÃ‡Ã•ES:</div>')
                    .split('\n').map(line => {
                        const cleanedLine = line.trim().replace(/^\d+\.\s*/, '');
                        if (cleanedLine === '' || line.includes('<div')) return line;
                        return `<div class="conduct-item">${cleanedLine}</div>`;
                    }).join('');
                appendOutput(formattedConduct, "output");
            } catch (error) {
                appendOutput(`Erro ao gerar conduta: ${error.message}`, "error");
            }
        };

        const askQuestionBasedOnContext = async (question) => {
            conversationHistory.push({ role: 'user', parts: [{ text: question }] });
            const simplifiedHistory = conversationHistory.map(item => `${item.role}: ${item.parts[0].text}`).join('\n');

            const prompt = `**InstruÃ§Ã£o de Persona:** VocÃª Ã© o AXON, um assistente mÃ©dico de IA. Seu usuÃ¡rio Ã© um mÃ©dico qualificado. Responda de forma concisa, direta e tÃ©cnica, sem usar frases de cautela como "consulte um especialista" ou "isso nÃ£o Ã© um diagnÃ³stico". O mÃ©dico jÃ¡ sabe disso. Seu objetivo Ã© ser um assistente rÃ¡pido e eficiente. Use o contexto clÃ­nico fornecido para dar respostas mais relevantes. Formate palavras importantes ou tÃ­tulos com asteriscos (ex: *DiagnÃ³stico Diferencial*), que serÃ£o renderizados em negrito.

**Contexto ClÃ­nico Atual:**
- **Anamnese:** ${anamnesis && Object.values(anamnesis).some(v => v) ? JSON.stringify(anamnesis) : "Nenhuma informaÃ§Ã£o."}
- **AnÃ¡lise Visual (Axon Eye):** ${axonEyeResults || "Nenhuma informaÃ§Ã£o."}

**HistÃ³rico da Conversa:**
${simplifiedHistory}

**Pergunta do MÃ©dico:** "${question}"

Responda diretamente Ã  pergunta.`;

            try {
                const response = await callGeminiAPI(prompt);
                conversationHistory.push({ role: 'model', parts: [{ text: response }] });
                return response;
            } catch (error) {
                console.error("Erro em askQuestionBasedOnContext:", error);
                throw error;
            }
        };

        const askVisionQuestionBasedOnContext = async (question, images) => {
            const imageParts = images.map(url => ({ inlineData: { mimeType: 'image/jpeg', data: url.split(',')[1] } }));
            conversationHistory.push({ role: 'user', parts: [{ text: question }, ...imageParts] });

            const simplifiedHistory = conversationHistory.map(item => {
                const textPart = item.parts.find(p => p.text);
                return `${item.role}: ${textPart ? textPart.text : '[Imagem enviada]'}`;
            }).join('\n');

            const prompt = `**InstruÃ§Ã£o de Persona:** VocÃª Ã© o AXON, um assistente mÃ©dico de IA. Seu usuÃ¡rio Ã© um mÃ©dico qualificado. Ele enviou ${images.length} imagem(ns) junto com uma pergunta. Analise as imagens e responda de forma concisa, direta e tÃ©cnica, sem usar frases de cautela. Use o contexto clÃ­nico se for relevante. Formate palavras importantes com asteriscos (ex: *LesÃ£o sugestiva de...*).

**Contexto ClÃ­nico Atual:**
- **Anamnese:** ${anamnesis && Object.values(anamnesis).some(v => v) ? JSON.stringify(anamnesis) : "Nenhuma informaÃ§Ã£o."}
- **AnÃ¡lise Visual (Axon Eye) PrÃ©via:** ${axonEyeResults || "Nenhuma informaÃ§Ã£o."}

**HistÃ³rico da Conversa:**
${simplifiedHistory}

**Pergunta do MÃ©dico (referente Ã (s) imagem(ns) enviada(s) agora):** "${question}"

Analise a(s) imagem(ns) e responda diretamente Ã  pergunta.`;

            try {
                const response = await callVisionAPI(images, prompt);
                conversationHistory.push({ role: 'model', parts: [{ text: response }] });
                return response;
            } catch (error) {
                console.error("Erro em askVisionQuestionBasedOnContext:", error);
                throw error;
            }
        };

        const copyMonitorContent = () => {
            let contentToCopy = "";
            if (currentMonitorView === 'anamnesis') contentToCopy = anamnesisPreview.innerText;
            else if (currentMonitorView === 'exams') contentToCopy = examsResultsPreview.innerText.replace("RESULTADOS DOS EXAMES:", "").trim();
            else if (currentMonitorView === 'axon-eye') contentToCopy = axonEyeResultsPreview.innerText.replace("ANÃLISE AXON EYE:", "").trim();
            navigator.clipboard.writeText(contentToCopy).then(() => appendOutput("ConteÃºdo copiado.", "success"), () => appendOutput("Erro ao copiar.", "error"));
        };

        const checkApiStatus = async (modelName = currentAIModel) => {
            let keysToTest = [];
            let modelToTest = modelName;

            if (globalSettings.apiProvider === 'openrouter') {
                try {
                    const response = await fetch("https://openrouter.ai/api/v1/auth/key", {
                        method: "GET",
                        headers: { "Authorization": `Bearer ${globalSettings.openRouterKey}` }
                    });
                    if (response.ok) {
                        apiConnectionStatus = "Conectado (OpenRouter)";
                        apiStatus.classList.remove('status-off');
                        return true;
                    }
                    throw new Error("Chave OpenRouter invÃ¡lida");
                } catch (e) {
                    apiConnectionStatus = "Offline (OpenRouter)";
                    apiStatus.classList.add('status-off');
                    return false;
                }
            }

            if (globalSettings.apiProvider === 'groq') {
                try {
                    const response = await fetch("https://api.groq.com/openai/v1/models", {
                        method: "GET",
                        headers: { "Authorization": `Bearer ${globalSettings.groqKey}` }
                    });
                    if (response.ok) {
                        apiConnectionStatus = "Conectado (Groq)";
                        apiStatus.classList.remove('status-off');
                        return true;
                    }
                    throw new Error("Chave Groq invÃ¡lida");
                } catch (e) {
                    apiConnectionStatus = "Offline (Groq)";
                    apiStatus.classList.add('status-off');
                    return false;
                }
            }

            if (globalSettings.mode === 'manual') {
                keysToTest = [globalSettings.manualApiKey || ''];
                modelToTest = globalSettings.manualTextModel || modelName;
            } else {
                keysToTest = globalSettings.apiKeys;
            }

            if (keysToTest.length === 0 || !keysToTest[0]) {
                apiConnectionStatus = "Sem chaves configuradas";
                apiStatus.classList.add('status-off');
                return false;
            }

            const isVision = globalSettings.apiModels.find(m => m.name === modelToTest)?.vision;
            let requestBody;

            if (isVision) {
                const dummyImagePart = { inlineData: { mimeType: 'image/png', data: 'iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=' } };
                requestBody = JSON.stringify({ contents: [{ parts: [dummyImagePart, { text: "ping" }] }] });
            } else {
                requestBody = JSON.stringify({ contents: [{ parts: [{ text: "ping" }] }] });
            }

            for (let i = 0; i < keysToTest.length; i++) {
                const apiKey = keysToTest[i];
                try {
                    const url = getGeminiUrl(modelToTest, apiKey);
                    const response = await fetch(url, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: requestBody,
                        signal: AbortSignal.timeout(5000)
                    });

                    if (response.ok) {
                        apiConnectionStatus = "Conectado";
                        apiStatus.classList.remove('status-off');

                        if (globalSettings.mode === 'automatic') {
                            currentApiKeyIndex = i;
                        }
                        return true;
                    }
                } catch (error) {
                    console.warn(`Falha ao testar chave ${i} no status check: ${error.message}`);
                }
            }

            apiConnectionStatus = "Offline (Todas as chaves falharam)";
            apiStatus.classList.add('status-off');
            return false;
        };

        const initializeAIModel = async () => {
            if (isMobile && globalSettings.mobile2_0_enabled) return;
            appendOutput("Verificando status da API...", "info", false);

            if (globalSettings.mode === 'manual') {
                currentAIModel = globalSettings.manualTextModel || currentAIModel;
                currentVisionAIModel = globalSettings.manualVisionModel || currentVisionAIModel;
            } else {
                currentAIModel = 'gemini-2.0-flash';
                currentVisionAIModel = 'gemini-2.0-flash';
            }

            let textModelOK = await checkApiStatus(currentAIModel);
            let providerName = globalSettings.apiProvider.charAt(0).toUpperCase() + globalSettings.apiProvider.slice(1);
            if (globalSettings.apiProvider === 'gemini') {
                providerName = currentAIModel;
            }

            if (textModelOK) appendOutput(`Motor conectado (${providerName}).`, "success", false);
            else appendOutput(`Falha ao conectar motor: ${apiConnectionStatus}.`, "error", false);
        };

        const logInteractionToFirebase = async (username, content, type, terminal) => { try { await addDoc(collection(db, "sessions", username, "interactions"), { content, type, terminal, timestamp: new Date() }); } catch (e) { console.error("Erro no log Firebase: ", e); } };
        const saveAnamnesisToFirestore = async (username, data) => { try { await setDoc(doc(db, "sessions", username), { anamnesis: data, lastUpdated: new Date() }, { merge: true }); } catch (e) { console.error("Erro ao salvar anamnese: ", e); } };
        const saveExamsResultsToFirestore = async (username, data) => { try { await setDoc(doc(db, "sessions", username), { examsResults: data, lastUpdated: new Date() }, { merge: true }); } catch (e) { console.error("Erro ao salvar exames: ", e); } };
        const saveAxonEyeResultsToFirestore = async (username, data) => { try { await setDoc(doc(db, "sessions", username), { axonEyeResults: data, lastUpdated: new Date() }, { merge: true }); } catch (e) { console.error("Erro ao salvar Axon Eye: ", e); } };
        const updateMonitorStateInFirestore = async (username, state) => { try { await setDoc(doc(db, "sessions", username), { monitorState: { ...state, lastUpdated: new Date() } }, { merge: true }); } catch (e) { console.error("Erro ao salvar estado do monitor: ", e); } };

        const setAnalyzingStateInFirestore = async (isAnalyzing, analysisType = null) => {
            if (!isLoggedIn || !currentUser) return;
            try {
                await setDoc(doc(db, "sessions", currentUser), {
                    isAnalyzing: { status: isAnalyzing, type: analysisType }
                }, { merge: true });
            } catch (e) {
                console.error("Erro ao atualizar estado de anÃ¡lise:", e);
            }
        };

        const objectsAreEqual = (obj1, obj2) => {
            const keys1 = Object.keys(obj1);
            const keys2 = Object.keys(obj2);
            if (keys1.length !== keys2.length) return false;
            for (let key of keys1) {
                if (obj1[key] !== obj2[key]) return false;
            }
            return true;
        };

        const getDesktopInfo = () => {
            const ua = navigator.userAgent;
            let os = 'OS Desconhecido';
            let browser = 'Navegador Desconhecido';

            // OS Detection
            if (navigator.appVersion.indexOf("Win") != -1) os = "Windows";
            if (navigator.appVersion.indexOf("Mac") != -1) os = "macOS";
            if (navigator.appVersion.indexOf("X11") != -1) os = "UNIX";
            if (navigator.appVersion.indexOf("Linux") != -1) os = "Linux";

            // Browser Detection
            if (ua.toLowerCase().indexOf("axon") !== -1) {
                browser = `Axon USB App`;
            } else if (ua.indexOf("Edg/") !== -1) {
                browser = `Edge ${ua.split('Edg/')[1].split(' ')[0]}`;
            } else if (ua.indexOf("Firefox/") !== -1) {
                browser = `Firefox ${ua.split('Firefox/')[1].split(' ')[0]}`;
            } else if (ua.indexOf("Chrome/") !== -1 && ua.indexOf("Safari/") !== -1 && ua.indexOf("OPR/") === -1) {
                browser = `Chrome ${ua.split('Chrome/')[1].split(' ')[0]}`;
            } else if (ua.indexOf("Safari/") !== -1 && ua.indexOf("Chrome/") === -1) {
                browser = `Safari ${ua.split('Version/')[1].split(' ')[0]}`;
            }

            return { os, browser, userAgent: ua };
        };

        const updateMobileConnectionStatus = (desktopData) => {
            const mobileStatusEl = document.querySelector('.mobile-connection-status');
            if (!mobileStatusEl) return;

            const dot = mobileStatusEl.querySelector('.status-dot');
            const text = mobileStatusEl.querySelector('span');

            const isConnected = desktopData && desktopData.timestamp && (new Date() - desktopData.timestamp.toDate() < 30000);

            dot.classList.toggle('status-on', isConnected);
            if (isConnected) {
                const isAxon = (desktopData.userAgent && desktopData.userAgent.toLowerCase().includes('axon')) || (desktopData.browser && desktopData.browser.toLowerCase().includes('axon'));
                if (isAxon) {
                    text.innerHTML = `<span style="color: #68d391; border: 1px solid #68d391; padding: 2px 6px; border-radius: 4px; font-weight: bold; background: rgba(104, 211, 145, 0.1);">CONECTADO VIA UNIDADE AXON USB</span>`;
                } else {
                    text.textContent = `Conectado em desktop: ${desktopData.os} - ${desktopData.browser}`;
                }
            } else {
                text.textContent = 'Nenhum desktop conectado';
            }
        };

        const setupTransferListener = (username) => {
            if (unsubscribeTransfer) unsubscribeTransfer();
            const transfersRef = collection(db, "sessions", username, "transfers");
            unsubscribeTransfer = onSnapshot(transfersRef, (snapshot) => {
                snapshot.docChanges().forEach(async (change) => {
                    if (change.type === "added" || change.type === "modified") {
                        const data = change.doc.data();

                        // Ignora arquivos enviados por mim mesmo
                        if (data.senderId === deviceId) return;

                        if (data.status === 'complete') {
                            // Mostra notificaÃ§Ã£o de recebimento
                            transferNotification.style.display = 'flex';

                            // Adjust popup for mobile if needed (handled by CSS, but ensure visible logic is fine)
                            if (isMobile) {
                                transferNotification.classList.add('mobile-center');
                            }

                            if (data.type === 'pinata') {
                                transferNotificationText.textContent = `Baixando ${data.filename} via Axon Share Pro...`;
                                try {
                                    // Fetch blob from Gateway
                                    const gatewayUrl = `https://gateway.pinata.cloud/ipfs/${data.ipfsHash}`;
                                    const response = await fetch(gatewayUrl);
                                    if (!response.ok) throw new Error("Falha ao baixar do IPFS");

                                    const blob = await response.blob();
                                    const downloadUrl = window.URL.createObjectURL(blob);

                                    const link = document.createElement('a');
                                    link.href = downloadUrl;
                                    link.download = data.filename;
                                    document.body.appendChild(link);
                                    link.click();
                                    document.body.removeChild(link);
                                    window.URL.revokeObjectURL(downloadUrl);

                                    transferNotificationText.textContent = "ConcluÃ­do!";
                                    transferNotificationProgress.style.width = '100%';

                                    // Create ephemeral cleanup task or notify sender? 
                                    // Sender is cleaner. But if sender is offline?
                                    // Rule: "apÃ³s ser baixado no outro dispositivo o arquivo deve ser apagado do pinata"
                                    // Receiver triggers the unpin via a signal back or if keys allow, unpin directly.
                                    // Let's try unpinning directly since we share the keys.
                                    await unpinFromPinata(data.ipfsHash);

                                    await deleteDoc(change.doc.ref);

                                } catch (e) {
                                    console.error("Erro download Pinata:", e);
                                    transferNotificationText.textContent = "Erro no download Pro.";
                                    transferNotificationText.style.color = "var(--error-color)";
                                }
                            } else {
                                // Default Firebase Method
                                transferNotificationText.textContent = `Baixando ${data.filename}...`;
                                try {
                                    let base64Data = "";
                                    if (data.chunkCount && data.chunkCount > 0) {
                                        // Reassembling chunks
                                        const chunksRef = collection(db, "sessions", username, "transfers", change.doc.id, "chunks");
                                        const chunksSnap = await getDocs(query(chunksRef, orderBy('__name__')));

                                        const chunks = [];
                                        chunksSnap.forEach(doc => chunks.push({ id: parseInt(doc.id), data: doc.data().data }));
                                        chunks.sort((a, b) => a.id - b.id);

                                        base64Data = chunks.map(c => c.data).join('');
                                    } else {
                                        base64Data = data.data;
                                    }

                                    // Trigger Download
                                    const link = document.createElement('a');
                                    link.href = base64Data;
                                    link.download = data.filename;
                                    document.body.appendChild(link);
                                    link.click();
                                    document.body.removeChild(link);

                                    transferNotificationText.textContent = "ConcluÃ­do!";
                                    transferNotificationProgress.style.width = '100%';

                                    // Clean up Firestore
                                    await deleteDoc(change.doc.ref);
                                    if (data.chunkCount > 0) {
                                        const chunksRef = collection(db, "sessions", username, "transfers", change.doc.id, "chunks");
                                        const chunksSnap = await getDocs(chunksRef);
                                        const batch = writeBatch(db);
                                        chunksSnap.forEach(c => batch.delete(c.ref));
                                        await batch.commit();
                                    }

                                } catch (e) {
                                    console.error("Erro ao baixar arquivo:", e);
                                    transferNotificationText.textContent = "Erro no download.";
                                    transferNotificationText.style.color = "var(--error-color)";
                                }
                            }

                            setTimeout(() => {
                                transferNotification.style.display = 'none';
                                transferNotificationProgress.style.width = '0%';
                                transferNotification.classList.remove('mobile-center');
                            }, 3000);
                        }
                    }
                });
            });
        };

        const setupFirebaseListener = (username) => {
            if (unsubscribeSnapshot) unsubscribeSnapshot();
            const docRef = doc(db, "sessions", username);
            unsubscribeSnapshot = onSnapshot(docRef, (docSnap) => {
                if (docSnap.exists()) {
                    const data = docSnap.data();

                    if (isMobile && globalSettings.mobile2_0_enabled) {
                        updateMobileConnectionStatus(data.desktopConnection);
                    }

                    // Handle analysis state synchronization
                    if (data.isAnalyzing && data.isAnalyzing.status) {
                        const type = data.isAnalyzing.type;
                        const animationHTML = `
                            <div class="ai-processing-animation">
                                <div class="scanner-animation">
                                    <div class="brain-icon"><i class="fas fa-brain"></i></div>
                                    <div class="scanner-line"></div>
                                </div>
                                <span>Analisando Imagens...</span>
                            </div>`;

                        if (type === 'exams') {
                            if (currentMonitorView !== 'exams') toggleMonitorView('exams', true);
                            if (!examsResultsPreview.querySelector('.ai-processing-animation')) {
                                examsResultsPreview.innerHTML = animationHTML;
                            }
                        } else if (type === 'axon-eye') {
                            if (currentMonitorView !== 'axon-eye') toggleMonitorView('axon-eye', true);
                            if (!axonEyeResultsPreview.querySelector('.ai-processing-animation')) {
                                axonEyeResultsPreview.innerHTML = animationHTML;
                            }
                        }
                    }

                    // Always process content updates. This will replace the animation when results are ready.
                    if (data.anamnesis && !objectsAreEqual(data.anamnesis, anamnesis)) {
                        anamnesis = data.anamnesis;
                        updateAnamnesisPreview(false);
                    }
                    if (data.examsResults !== undefined && data.examsResults !== examsResults) {
                        examsResults = data.examsResults;
                        updateExamsResultsPreview(false);
                    }
                    if (data.axonEyeImages && JSON.stringify(data.axonEyeImages) !== JSON.stringify(temporaryImgurUploads)) {
                        temporaryImgurUploads = data.axonEyeImages;
                        updateAxonEyeResultsPreview(false);
                    } else if (!data.axonEyeImages && temporaryImgurUploads.length > 0) {
                        temporaryImgurUploads = [];
                        updateAxonEyeResultsPreview(false);
                    }
                    if (data.axonEyeResults !== undefined && data.axonEyeResults !== axonEyeResults) {
                        axonEyeResults = data.axonEyeResults;
                        updateAxonEyeResultsPreview(false);
                    }
                    if (data.monitorState && data.monitorState.activeView !== currentMonitorView) {
                        // Avoid view switching if an analysis is active, as it's already handled by the logic above
                        if (!data.isAnalyzing || !data.isAnalyzing.status) {
                            toggleMonitorView(data.monitorState.activeView, true);
                        }
                    }

                } else {
                    // Document does not exist. Session ended remotely or cleared.
                    if (!isMobile) { // If we are on desktop
                        if (isLoggedIn) { // Avoid multiple logout calls
                            appendOutput("SessÃ£o encerrada remotamente. Desconectando...", "info", false);
                            setTimeout(() => logoutUser(), 1500);
                        }
                        return; // Stop further processing for desktop
                    }

                    // Original mobile logic
                    if (isMobile && globalSettings.mobile2_0_enabled) {
                        updateMobileConnectionStatus(null);
                    }
                    anamnesis = { qp: "", hma: "", hp: "", hf: "", hps: "" };
                    examsResults = "";
                    axonEyeResults = "";
                    updateAnamnesisPreview(false);
                    updateExamsResultsPreview(false);
                    updateAxonEyeResultsPreview(false);
                }
            });
        };

        const checkAccessRestriction = () => {
            const overlay = document.getElementById('axon-web-access-blocked-overlay');
            const messageEl = document.getElementById('axon-web-blocked-message');

            // Elements to hide when blocked
            const header = document.querySelector('.header');
            const container = document.querySelector('.container');
            const mobileCont = document.getElementById('mobile-2-0-container');

            if (!globalSettings.axonWebDisabled) {
                if (overlay) overlay.style.display = 'none';
                // Restore visibility if previously blocked (basic restore, applySettings handles specific flex logic)
                if (header) header.style.display = 'flex';
                if (container) container.style.display = 'flex'; // Assuming default is flex
                if (mobileCont) mobileCont.style.display = 'none'; // Assuming default is none, applySettings will handle if mobile is active
                return;
            }

            const message = globalSettings.axonWebDisabledMessage || "A partir de hoje o sistema somente pode ser acessado via dipostivo Axon USB! Caso ainda nÃ£o tenha adquirido entre em contato com o suporte; (38) 998517363.";
            if (messageEl) messageEl.textContent = message;

            // Check conditions to ALLOW access
            const isPWA = window.matchMedia('(display-mode: standalone)').matches || window.navigator.standalone === true;
            const ua = navigator.userAgent.toLowerCase();
            const isAxonApp = ua.includes('axon');

            if (isPWA || isAxonApp) {
                if (overlay) overlay.style.display = 'none';
                // Don't force display here, let applySettings handle it based on Mobile/Desktop state
                // Just ensure they are NOT removed if they exist
            } else {
                if (overlay) overlay.style.display = 'flex';
                // Securely remove elements from DOM so they cannot be revealed by DevTools
                if (header) header.remove();
                if (container) container.remove();
                if (mobileCont) mobileCont.remove();

                // Also remove modals to be safe
                document.querySelectorAll('.app-modal, .mobile-menu-modal').forEach(el => el.remove());
            }
        };

        const applySettings = () => {
            checkAccessRestriction();
            if (isMobile && globalSettings.mobile2_0_enabled) {
                document.querySelector('.container').style.display = 'none';
                mobileContainer.style.display = 'flex';
                if (btnCloud) btnCloud.style.display = 'none';
            } else {
                document.querySelector('.container').style.display = 'flex';
                mobileContainer.style.display = 'none';
                if (btnCloud) btnCloud.style.display = 'flex';
            }

            // Mobile 2.0 Button Visibility (Global Rule)
            // Hides specific action buttons if Mobile 2.0 is enabled, even on Desktop
            const shouldHideActionButtons = globalSettings.mobile2_0_enabled;
            if (btnExames) btnExames.style.display = shouldHideActionButtons ? 'none' : 'flex';
            if (btnSee) btnSee.style.display = shouldHideActionButtons ? 'none' : 'flex';

            // Apply Log Suppression CSS Class
            const interactiveOutput = document.getElementById('interactive-output');
            if (interactiveOutput) {
                if (globalSettings.hideStatusMessages) {
                    interactiveOutput.classList.add('hide-technical-logs');
                } else {
                    interactiveOutput.classList.remove('hide-technical-logs');
                }
            }

            initializeAIModel();

            // Enforce Global Prescription Assistant Visibility
            const btnPrescAssist = document.getElementById('btn-prescription-assist');
            if (btnPrescAssist) {
                // Determine if we should show it based on Global Settings
                // Default to true if somehow undefined, but globalSettings shoud have it.
                const shouldShow = globalSettings.showPrescriptionAssistant !== false;

                // If Mobile 2.0 hides actions, we might want to respect that OR let this override?
                // Usually global toggle means "feature enabled/disabled".
                // If feature is disabled globally -> Hide.
                // If feature is enabled globally -> Check local/mobile context.

                if (!shouldShow) {
                    btnPrescAssist.style.display = 'none';
                } else {
                    // Feature is enabled globally.
                    // If we are NOT covering it by other logic (like mobile 2.0 hiding everything), show it.
                    // But wait, existing logic uses display: flex;
                    btnPrescAssist.style.display = 'flex';
                }
            }
        };

        const setupGlobalSettingsListener = () => {
            return new Promise((resolve) => {
                if (unsubscribeSettings) unsubscribeSettings();
                const docRef = doc(db, "settings", "global");
                let isAllocated = false;

                unsubscribeSettings = onSnapshot(docRef, (docSnap) => {
                    if (docSnap.exists()) {
                        const data = docSnap.data();
                        globalSettings = {
                            apiKeys: data.apiKeys || [...defaultApiKeys],
                            apiModels: data.apiModels || [...defaultApiModels],
                            mode: data.mode || 'automatic',
                            manualTextModel: data.manualTextModel || '',
                            manualVisionModel: data.manualVisionModel || '',
                            manualApiKey: data.manualApiKey || '',
                            apiProvider: data.apiProvider || 'gemini',
                            openRouterKey: data.openRouterKey || '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',
                            openRouterModel: data.openRouterModel || '',
                            groqKey: data.groqKey || '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',
                            groqTextModel: data.groqTextModel || 'llama-3.3-70b-versatile',
                            groqVisionModel: data.groqVisionModel || 'llama-3.2-90b-vision-preview',
                            groqAvailableModels: data.groqAvailableModels || [],
                            mobile2_0_enabled: data.mobile2_0_enabled === undefined ? isMobile : data.mobile2_0_enabled,
                            hideStatusMessages: data.hideStatusMessages || false,
                            customTextProvider: data.customTextProvider || 'gemini',
                            customVisionProvider: data.customVisionProvider || 'gemini',
                            pinataKeys: data.pinataKeys || [
                                { key: "5256cd6c1c0b4ccec3a9", secret: "afbed7932f0ebf5c50d88d04378359164aca3ae63a72e2628375dc02e4fcfb05" }
                            ],
                            supabaseUrl: data.supabaseUrl || '',
                            supabaseKey: data.supabaseKey || '',
                            supabaseBucket: data.supabaseBucket || 'axon-drive',
                            supabaseEnabled: data.supabaseEnabled || false,
                            showPrescriptionAssistant: data.showPrescriptionAssistant !== undefined ? data.showPrescriptionAssistant : true,
                            bridgePermissions: data.bridgePermissions || {
                                sendToChat: true,
                                callAI: true,
                                getAnamnesis: true,
                                callAI: true,
                                getAnamnesis: true,
                                storage: true
                            },
                            axonWebDisabled: data.axonWebDisabled || false,
                            axonWebDisabledMessage: data.axonWebDisabledMessage || "A partir de hoje o sistema somente pode ser acessado via dipostivo Axon USB! Caso ainda nÃ£o tenha adquirido entre em contato com o suporte; (38) 998517363."
                        };

                        if (adminPanelModal.style.display === 'flex') {
                            if (document.querySelector('.admin-tab-btn[data-tab="api"]').classList.contains('active')) {
                                renderAdminSettingsUI();
                            }
                            if (document.querySelector('.admin-tab-btn[data-tab="debug"]').classList.contains('active')) {
                                renderAdminDebugUI();
                            }
                        }

                        applySettings();
                        if (!isAllocated) { isAllocated = true; resolve(); }
                    } else {
                        globalSettings.mobile2_0_enabled = isMobile;
                        setDoc(docRef, globalSettings);
                        if (!isAllocated) { isAllocated = true; resolve(); }
                    }
                }, (error) => {
                    console.error("Erro ao sincronizar configuraÃ§Ãµes globais:", error);
                    if (!isAllocated) { isAllocated = true; resolve(); }
                });
            });
        };

        const registerUser = async (adminPassword, username, password) => {
            if (adminPassword !== 'admin123') return appendOutput("Senha de administrador incorreta.", "error");
            if (!username || !password) return appendOutput("Uso: /register [senha_admin] [usuÃ¡rio] [senha]", "error");
            try {
                const userRef = doc(db, "users", username);
                const docSnap = await getDoc(userRef);
                if (docSnap.exists()) appendOutput(`UsuÃ¡rio '${username}' jÃ¡ existe.`, "error");
                else { await setDoc(userRef, { password, createdAt: new Date(), textRequests: 0, visionRequests: 0, isBlocked: false, isCloudDisabled: false }); appendOutput(`UsuÃ¡rio '${username}' registrado com sucesso.`, "success"); }
            } catch (e) { appendOutput(`Erro ao registrar: ${e.message}`, "error"); }
        };
        const deleteUser = async (adminPassword, username) => {
            if (adminPassword !== 'admin123') return appendOutput("Senha de administrador incorreta.", "error");
            if (!username) return appendOutput("Uso: /delete [senha_admin] [usuÃ¡rio]", "error");
            try {
                const userRef = doc(db, "users", username);
                await deleteDoc(userRef);
                appendOutput(`UsuÃ¡rio '${username}' deletado.`, "success");
                if (currentUser === username) {
                    appendOutput("VocÃª foi desconectado.", "info");
                    logoutUser();
                }
            } catch (e) { appendOutput(`Erro ao deletar: ${e.message}`, "error"); }
        };
        const authenticateUser = async (username, password) => {
            if (username === 'ian' && password === 'ian123') return { success: true, isBlocked: false, isCloudDisabled: false };
            try {
                const userRef = doc(db, "users", username);
                const docSnap = await getDoc(userRef);
                if (docSnap.exists()) {
                    const userData = docSnap.data();
                    if (userData.password === password) {
                        return { success: true, isBlocked: userData.isBlocked || false, isCloudDisabled: userData.isCloudDisabled || false };
                    }
                }
                return { success: false };
            } catch (e) { return { success: false }; }
        };

        const isUserValid = async (username) => {
            try {
                const userRef = doc(db, "users", username);
                const docSnap = await getDoc(userRef);
                return docSnap.exists();
            } catch (e) {
                console.error("Error checking user validity:", e);
                return false;
            }
        };

        const updateBlockedUI = () => {
            const buttons = document.querySelectorAll('.action-button, .mobile-btn');
            const infoBannerBubble = document.querySelector('.info-banner .chat-bubble-info');
            const infoBannerContent = document.getElementById('info-banner-content');

            if (isUserBlocked) {
                appendOutput("Sua conta foi bloqueada! Funcionalidade indisponÃ­vel.", "highlight");
                buttons.forEach(btn => btn.classList.add('blocked-ui'));
                commandInput.disabled = true;
                if (cameraModal.style.display === 'flex') stopCamera();
                patientListModal.style.display = 'none';
                savePatientModal.style.display = 'none';
                adminPanelModal.style.display = 'none';
                chatboxModal.style.display = 'none';
                transferModal.style.display = 'none';
                if (btnCloud) btnCloud.classList.add('blocked-ui');

                if (isMobile && globalSettings.mobile2_0_enabled && infoBannerBubble && infoBannerContent) {
                    infoBannerBubble.style.backgroundColor = 'var(--altered-color)';
                    infoBannerBubble.style.color = '#1a202c'; // Dark text for yellow bg
                    infoBannerContent.innerHTML = 'Sua conta do usuÃ¡rio foi bloqueada.';
                }
            } else {
                appendOutput("Sua conta foi desbloqueada.", "success");
                buttons.forEach(btn => btn.classList.remove('blocked-ui'));
                commandInput.disabled = false;
                if (btnCloud) btnCloud.classList.remove('blocked-ui');

                if (isMobile && globalSettings.mobile2_0_enabled && infoBannerBubble && infoBannerContent) {
                    infoBannerBubble.style.backgroundColor = '';
                    infoBannerBubble.style.color = '';
                    infoBannerContent.innerHTML = `Para acesso completo, abra o Axon Web em seu computador em<a href="https://funortehub.github.io/axon" target="_blank" class="highlight-link">funortehub.github.io/axon</a>ou insira um dispositivo AXON USB.`;
                }
            }
        };

        const uploadToImgur = async (base64Image) => {
            try {
                const response = await fetch('https://api.imgur.com/3/image', {
                    method: 'POST',
                    headers: {
                        Authorization: `Client-ID ${IMGUR_CLIENT_ID}`,
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        image: base64Image.split(',')[1],
                        type: 'base64',
                        title: 'Axon Eye Analysis',
                        description: `Image uploaded by Axon A.I for user ${currentUser}`
                    }),
                });
                const data = await response.json();
                if (data.success) {
                    return { link: data.data.link, deleteHash: data.data.deletehash };
                } else {
                    throw new Error(data.data.error || 'Imgur upload failed');
                }
            } catch (error) {
                console.error("Imgur upload error:", error);
                appendOutput(`Erro ao fazer upload da imagem para o Imgur: ${error.message}`, 'error');
                return null;
            }
        };

        const deleteFromImgur = async (deleteHash) => {
            if (!deleteHash) return;
            try {
                await fetch(`https://api.imgur.com/3/image/${deleteHash}`, {
                    method: 'DELETE',
                    headers: {
                        Authorization: `Client-ID ${IMGUR_CLIENT_ID}`,
                    },
                });
            } catch (error) {
                console.error("Imgur delete error:", error);
            }
        };

        const clearTemporaryUploads = async () => {
            if (temporaryImgurUploads.length > 0) {
                appendOutput('Limpando imagens temporÃ¡rias nÃ£o salvas...', 'info');
                for (const upload of temporaryImgurUploads) {
                    await deleteFromImgur(upload.deleteHash);
                }
                temporaryImgurUploads = [];
            }
        };

        const startCamera = async (mode) => {
            // Limpa estado anterior para uma nova anÃ¡lise
            examsResults = "";
            axonEyeResults = "";
            capturedImages = [];
            examsResultsPreview.innerHTML = '<div class="info">Nenhum exame analisado ainda.</div>';
            axonEyeResultsPreview.innerHTML = '<div class="info">Nenhuma anÃ¡lise visual feita ainda.</div>';
            updateAlbumCount();
            sendExamsButton.classList.add('disabled');
            sendAxonEyeButton.classList.add('disabled');

            cameraMode = mode;
            cameraModalTitle.textContent = mode === 'exams' ? 'CÃ¢mera de Exames' : 'Axon Eye';
            sendExamsButton.style.display = mode === 'exams' ? 'flex' : 'none';
            sendAxonEyeButton.style.display = mode === 'axon-eye' ? 'flex' : 'none';

            cameraModal.style.display = 'flex';
            if (isMobile) {
                cameraModal.classList.add('fullscreen-mobile');
                document.body.style.overflow = 'hidden';
            }

            updateMonitorStateInFirestore(currentUser, { activeView: mode === 'exams' ? 'exams' : 'axon-eye' });

            try {
                if (cameraStream) {
                    cameraStream.getTracks().forEach(track => track.stop());
                }

                const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: currentCameraFacingMode, width: { ideal: 4096 }, height: { ideal: 2160 } } });

                cameraVideo.srcObject = stream;
                cameraStream = stream;

                cameraVideo.onloadedmetadata = () => {
                    cameraVideo.play().catch(e => console.error("Play failed:", e));
                };

                cameraStatus.classList.remove('status-off');
                if (!isMobile || !globalSettings.mobile2_0_enabled) {
                    appendOutput(`CÃ¢mera ativada para ${mode === 'exams' ? 'exames' : 'anÃ¡lise visual'}.`, "info");
                }

                const devices = await navigator.mediaDevices.enumerateDevices();
                if (devices.filter(d => d.kind === 'videoinput').length > 1) {
                    cameraSwitchButton.style.display = 'block';
                }

                const track = stream.getVideoTracks()[0];
                if (track && 'torch' in track.getCapabilities()) {
                    flashlightButton.style.display = 'block';
                }

            } catch (err) {
                if (!isMobile || !globalSettings.mobile2_0_enabled) {
                    appendOutput(`Erro ao acessar a cÃ¢mera: ${err.message}.`, "error");
                } else {
                    showConfirmModal(`Erro ao acessar a cÃ¢mera: ${err.message}. Tente novamente.`, () => { });
                }
                stopCamera();
            }
        };

        const stopCameraStreamOnly = () => {
            if (cameraStream) {
                if (isFlashlightOn) toggleFlashlight();
                cameraStream.getTracks().forEach(track => track.stop()); cameraVideo.srcObject = null; cameraStream = null;
            }
            cameraStatus.classList.add('status-off');
        };

        const stopCamera = () => {
            stopCameraStreamOnly();
            cameraModal.style.display = 'none';
            if (isMobile) {
                cameraModal.classList.remove('fullscreen-mobile');
                document.body.style.overflow = 'auto';
            }
            if (!isMobile || !globalSettings.mobile2_0_enabled) {
                toggleMonitorView(currentMonitorView === 'camera' ? 'anamnesis' : currentMonitorView);
            }
        };

        const cancelCamera = () => {
            updateMonitorStateInFirestore(currentUser, { activeView: 'anamnesis' });
            stopCamera();
            capturedImages = [];
            updateAlbumCount();
            sendExamsButton.classList.add('disabled');
            sendAxonEyeButton.classList.add('disabled');
        };

        const switchCamera = async () => { currentCameraFacingMode = (currentCameraFacingMode === 'user') ? 'environment' : 'user'; await startCamera(cameraMode); };
        const toggleFlashlight = async () => {
            if (!cameraStream) return;
            const track = cameraStream.getVideoTracks()[0];
            if (track && 'torch' in track.getCapabilities()) {
                try { await track.applyConstraints({ advanced: [{ torch: !isFlashlightOn }] }); isFlashlightOn = !isFlashlightOn; flashlightButton.classList.toggle('active', isFlashlightOn); } catch (err) { appendOutput("Erro ao controlar a lanterna.", "error"); }
            }
        };
        const capturePhoto = () => { if (!cameraStream) return; cameraCanvas.width = cameraVideo.videoWidth; cameraCanvas.height = cameraVideo.videoHeight; cameraCanvas.getContext('2d').drawImage(cameraVideo, 0, 0, cameraCanvas.width, cameraCanvas.height); addCapturedImage(cameraCanvas.toDataURL('image/jpeg')); };
        const handleFileUpload = (event) => { for (const file of event.target.files) { if (file.type.startsWith('image/')) { const reader = new FileReader(); reader.onload = (e) => addCapturedImage(e.target.result); reader.readAsDataURL(file); } } };
        const addCapturedImage = (imageDataURL) => { capturedImages.push(imageDataURL); updateAlbumCount(); sendExamsButton.classList.remove('disabled'); sendAxonEyeButton.classList.remove('disabled'); };
        const removeCapturedImage = (imageDataURL) => { capturedImages = capturedImages.filter(url => url !== imageDataURL); updateAlbumCount(); if (capturedImages.length === 0) { sendExamsButton.classList.add('disabled'); sendAxonEyeButton.classList.add('disabled'); } renderAlbum(); };
        const updateAlbumCount = () => { albumCount.textContent = capturedImages.length; albumButton.style.display = capturedImages.length > 0 ? 'flex' : 'none'; };
        const openAlbumModal = () => { renderAlbum(); albumModal.style.display = 'flex'; };
        const closeAlbumModal = () => { albumModal.style.display = 'none'; };
        const renderAlbum = () => {
            albumGrid.innerHTML = capturedImages.length === 0 ? '<div class="info" style="grid-column: 1 / -1; text-align: center;">Nenhuma imagem no Ã¡lbum.</div>' : '';
            capturedImages.forEach(url => {
                const item = document.createElement('div'); item.className = 'album-item';
                const img = document.createElement('img'); img.src = url; img.className = 'album-image'; img.onclick = () => openFullscreenModal(url);
                const delBtn = document.createElement('button'); delBtn.className = 'album-delete-button'; delBtn.innerHTML = '&times;'; delBtn.onclick = (e) => { e.stopPropagation(); removeCapturedImage(url); };
                item.append(img, delBtn); albumGrid.appendChild(item);
            });
        };

        window.openFullscreenModal = (imageDataURL) => {
            modalImage.src = imageDataURL;
            fullscreenModal.style.display = 'block';
        };

        modalClose.onclick = () => fullscreenModal.style.display = 'none';
        fullscreenModal.onclick = (e) => { if (e.target === fullscreenModal) fullscreenModal.style.display = 'none'; };

        const showMobileLoader = () => { if (isMobile && globalSettings.mobile2_0_enabled) mobileAnalysisLoader.style.display = 'flex'; };
        const hideMobileLoader = () => { if (isMobile && globalSettings.mobile2_0_enabled) mobileAnalysisLoader.style.display = 'none'; };


        const analyzeExams = async () => {
            const callTimestamp = Date.now();
            if (capturedImages.length === 0) return appendOutput("Nenhuma imagem de exame para analisar.", "info");

            if (!isMobile || !globalSettings.mobile2_0_enabled) {
                toggleMonitorView('exams');
            } else {
                showMobileLoader();
            }
            await setAnalyzingStateInFirestore(true, 'exams');

            try {
                const prompt = `VocÃª Ã© um assistente especialista em anÃ¡lise de exames mÃ©dicos. Sua tarefa Ã© extrair e transcrever os dados dos exames fornecidos. Siga estas regras ESTRITAMENTE:\n\n1. **Resultados Laboratoriais:** Transcreva os resultados em formato de lista. Se um valor estiver alterado, adicione "(Alterado)" ao final da linha. Exemplo: Glicose: 90 mg/dL (Alterado).\n2. **Laudos de Imagem:** Se for um laudo de texto, transcreva o texto completo, palavra por palavra, sem NENHUMA alteraÃ§Ã£o ou resumo.\n3. **Formato RÃ­gido:** NUNCA comece sua resposta com frases como "Aqui estÃ£o os resultados...", "Analisando os exames...", etc. Sua resposta DEVE comeÃ§ar DIRETAMENTE com o primeiro item do resultado. Retorne APENAS a lista de resultados ou o texto do laudo.`;

                let fullResponse = "";
                const isGroq = globalSettings.apiProvider === 'groq' || (globalSettings.apiProvider === 'custom' && globalSettings.customVisionProvider === 'groq');

                if (isGroq && capturedImages.length > 5) {
                    appendOutput(`Groq: Detectadas ${capturedImages.length} imagens. Enviando em lotes de atÃ© 5...`, "info", false);
                    const chunks = [];
                    for (let i = 0; i < capturedImages.length; i += 5) {
                        chunks.push(capturedImages.slice(i, i + 5));
                    }
                    for (let i = 0; i < chunks.length; i++) {
                        appendOutput(`Enviando lote ${i + 1}/${chunks.length}...`, "info", false);
                        const chunkResponse = await callVisionAPI(chunks[i], prompt);
                        fullResponse += chunkResponse + "\n";
                    }
                } else {
                    fullResponse = await callVisionAPI(capturedImages, prompt);
                }

                if (callTimestamp < lastClearTimestamp) {
                    console.warn("Ignorando anÃ¡lise de exames pois a sessÃ£o foi limpa.");
                    return;
                }

                await setDoc(doc(db, "sessions", currentUser), {
                    examsResults: fullResponse.trim(),
                    isAnalyzing: { status: false, type: null }
                }, { merge: true });

                if (isMobile && globalSettings.mobile2_0_enabled) {
                    showConfirmModal('AnÃ¡lise de exames concluÃ­da!', () => { }, true);
                } else {
                    appendOutput("AnÃ¡lise de exames concluÃ­da.", "success");
                }

            } catch (error) {
                if (isMobile && globalSettings.mobile2_0_enabled) {
                    showConfirmModal(`Erro ao analisar exames: ${error.message}`, () => { }, true);
                } else {
                    appendOutput(`Erro ao analisar exames: ${error.message}`, "error");
                }

                await setDoc(doc(db, "sessions", currentUser), {
                    examsResults: "",
                    isAnalyzing: { status: false, type: null }
                }, { merge: true });

            } finally {
                hideMobileLoader();
                stopCamera(); capturedImages = []; updateAlbumCount();
            }
        };

        const analyzeAxonEye = async () => {
            const callTimestamp = Date.now();
            if (capturedImages.length === 0) return appendOutput("Nenhuma imagem para anÃ¡lise visual.", "info");

            await clearTemporaryUploads();

            if (!isMobile || !globalSettings.mobile2_0_enabled) {
                toggleMonitorView('axon-eye');
            } else {
                showMobileLoader();
            }
            await setAnalyzingStateInFirestore(true, 'axon-eye');

            try {
                const currentUploads = [];
                for (const imgBase64 of capturedImages) {
                    const uploadResult = await uploadToImgur(imgBase64);
                    if (uploadResult) {
                        currentUploads.push(uploadResult);
                    }
                }

                if (currentUploads.length !== capturedImages.length) {
                    throw new Error("Falha no upload de uma ou mais imagens.");
                }

                temporaryImgurUploads = [...currentUploads];

                const prompt = `Analise as imagens e forneÃ§a uma opiniÃ£o clÃ­nica detalhada. Descreva achados, lesÃµes, ou sintomas. Ao final, inclua uma seÃ§Ã£o "ImpressÃ£o DiagnÃ³stica:" ou "InterpretaÃ§Ã£o ClÃ­nica:" com sua conclusÃ£o. Formate palavras importantes com asteriscos (ex: *LesÃ£o sugestiva de...*). Seja descritivo e clinicamente relevante.`;

                let fullResponse = "";
                let imagesForApiCall;

                // Decide the image source based on provider
                if (globalSettings.apiProvider === 'openrouter') {
                    // OpenRouter needs URLs, which we have from Imgur
                    imagesForApiCall = temporaryImgurUploads.map(upload => upload.link);
                } else {
                    // Gemini and Groq need base64 data
                    imagesForApiCall = capturedImages;
                }

                // Decide on batching
                const isGroq = globalSettings.apiProvider === 'groq' || (globalSettings.apiProvider === 'custom' && globalSettings.customVisionProvider === 'groq');

                if (isGroq && imagesForApiCall.length > 5) {
                    appendOutput(`Groq: Detectadas ${imagesForApiCall.length} imagens. Enviando em lotes de atÃ© 5...`, "info", false);
                    const chunks = [];
                    for (let i = 0; i < imagesForApiCall.length; i += 5) {
                        chunks.push(imagesForApiCall.slice(i, i + 5));
                    }
                    for (let i = 0; i < chunks.length; i++) {
                        appendOutput(`Enviando lote ${i + 1}/${chunks.length}...`, "info", false);
                        const chunkResponse = await callVisionAPI(chunks[i], prompt);
                        fullResponse += chunkResponse + "\n\n";
                    }
                } else {
                    // No batching needed
                    fullResponse = await callVisionAPI(imagesForApiCall, prompt);
                }

                if (callTimestamp < lastClearTimestamp) {
                    console.warn("Ignorando anÃ¡lise Axon Eye pois a sessÃ£o foi limpa.");
                    return;
                }

                await setDoc(doc(db, "sessions", currentUser), {
                    axonEyeResults: fullResponse.trim(),
                    axonEyeImages: [...temporaryImgurUploads],
                    isAnalyzing: { status: false, type: null }
                }, { merge: true });

                if (isMobile && globalSettings.mobile2_0_enabled) {
                    showConfirmModal('AnÃ¡lise Axon Eye concluÃ­da. Imagens prontas para salvar em um prontuÃ¡rio.', () => { }, true);
                } else {
                    appendOutput("AnÃ¡lise Axon Eye concluÃ­da. Imagens prontas para salvar.", "success");
                }

            } catch (error) {
                if (isMobile && globalSettings.mobile2_0_enabled) {
                    showConfirmModal(`Erro com Axon Eye: ${error.message}`, () => { }, true);
                } else {
                    appendOutput(`Erro com Axon Eye: ${error.message}`, "error");
                }
                await clearTemporaryUploads();

                await setDoc(doc(db, "sessions", currentUser), {
                    axonEyeResults: "",
                    isAnalyzing: { status: false, type: null }
                }, { merge: true });

            } finally {
                hideMobileLoader();
                stopCamera(); capturedImages = []; updateAlbumCount();
            }
        };

        const savePatient = async (patientName, birthDate) => {
            if (!isLoggedIn) {
                appendOutput("VocÃª precisa estar logado.", "error");
                return;
            }
            savePatientButton.disabled = true;
            savePatientFeedback.textContent = 'Salvando...';

            try {
                const patientId = `${currentUser}_${patientName.replace(/\s+/g, '_').toLowerCase()}_${birthDate.replace(/\//g, '')}`;
                const patientRef = doc(db, "patients", patientId);

                const newConsultation = {
                    date: new Date(),
                    anamnesis: { ...anamnesis },
                    examsResults,
                    axonEyeResults,
                    axonEyeImages: [...temporaryImgurUploads],
                };

                const docSnap = await getDoc(patientRef);

                if (docSnap.exists()) {
                    const existingData = docSnap.data();
                    const updatedConsultations = existingData.consultations ? [...existingData.consultations, newConsultation] : [newConsultation];
                    await updateDoc(patientRef, {
                        consultations: updatedConsultations,
                        lastUpdated: new Date()
                    });
                    appendOutput(`Nova consulta salva para '${patientName}'.`, "success");
                } else {
                    await setDoc(patientRef, {
                        patientName,
                        birthDate,
                        savedBy: currentUser,
                        createdAt: new Date(),
                        consultations: [newConsultation],
                        lastUpdated: new Date()
                    });
                    appendOutput(`Paciente '${patientName}' e primeira consulta salvos com sucesso.`, "success");
                }

                temporaryImgurUploads = [];
                closeSaveModal();
            } catch (e) {
                appendOutput(`Erro ao salvar paciente: ${e.message}`, "error");
                savePatientFeedback.textContent = `Erro: ${e.message}`;
            } finally {
                savePatientButton.disabled = false;
            }
        };

        const loadPatientList = async () => {
            if (!isLoggedIn) return appendOutput("VocÃª precisa estar logado.", "error");
            try {
                const q = query(collection(db, "patients"), where("savedBy", "==", currentUser));
                const querySnapshot = await getDocs(q);

                allPatients = [];
                querySnapshot.forEach((doc) => {
                    allPatients.push({ id: doc.id, ...doc.data() });
                });

                allPatients.sort((a, b) => {
                    const dateA = a.lastUpdated?.toDate() || a.createdAt?.toDate() || 0;
                    const dateB = b.lastUpdated?.toDate() || b.createdAt?.toDate() || 0;
                    return dateB - dateA;
                });

                patientList.innerHTML = '';
                if (allPatients.length === 0) {
                    patientList.innerHTML = '<div class="info">Nenhum paciente salvo.</div>';
                } else {
                    allPatients.forEach(p => {
                        const hasConsultations = p.consultations && p.consultations.length > 0;

                        let lastConsultDateStr = 'Nenhuma consulta registrada';
                        if (hasConsultations) {
                            const mostRecentConsult = p.consultations
                                .filter(c => c.date && c.date.toDate)
                                .sort((a, b) => b.date.toDate() - a.date.toDate())[0];
                            if (mostRecentConsult) {
                                lastConsultDateStr = mostRecentConsult.date.toDate().toLocaleString();
                            }
                        }

                        const item = document.createElement('div');
                        item.className = 'patient-item';
                        item.dataset.patientId = p.id;
                        item.innerHTML = `<div><strong>${p.patientName}</strong> - ${p.birthDate || 'N/A'}</div>
                                          <div style="font-size: 12px; color: var(--text-color); opacity: 0.7;">Ãšltima consulta: ${lastConsultDateStr}</div>
                                          <div class="patient-actions">
                                            <button class="patient-action-button delete" data-id="${p.id}"><i class="fas fa-trash"></i> Excluir</button>
                                            <button class="patient-action-button details ${!hasConsultations ? 'disabled' : ''}" data-id="${p.id}"><i class="fas fa-eye"></i> Detalhes</button>
                                            <button class="patient-action-button pdf ${!hasConsultations ? 'disabled' : ''}" data-id="${p.id}"><i class="fas fa-file-pdf"></i> PDF</button>
                                          </div>`;
                        patientList.appendChild(item);
                    });
                }

                const saveButtonFooter = patientListModal.querySelector('.patient-list-footer');
                if (saveButtonFooter) {
                    if (isMobile && globalSettings.mobile2_0_enabled) {
                        saveButtonFooter.style.display = 'none';
                    } else {
                        saveButtonFooter.style.display = 'block';
                    }
                }

                patientListModal.style.display = 'flex';
            } catch (e) {
                appendOutput(`Erro ao carregar pacientes: ${e.message}`, "error");
                console.error("Erro em loadPatientList:", e);
            }
        };

        const deletePatient = async (patientId) => {
            showConfirmModal("Tem certeza que deseja excluir este paciente e TODAS as suas consultas? A aÃ§Ã£o Ã© irreversÃ­vel.", async () => {
                try {
                    const patientRef = doc(db, "patients", patientId);
                    const docSnap = await getDoc(patientRef);

                    if (docSnap.exists()) {
                        const patientData = docSnap.data();
                        if (patientData.consultations && patientData.consultations.length > 0) {
                            appendOutput("Excluindo imagens associadas do Imgur...", "info");
                            for (const consult of patientData.consultations) {
                                if (consult.axonEyeImages && consult.axonEyeImages.length > 0) {
                                    for (const img of consult.axonEyeImages) {
                                        await deleteFromImgur(img.deleteHash);
                                    }
                                }
                            }
                        }
                    }

                    await deleteDoc(patientRef);
                    appendOutput("Paciente e todos os registros foram excluÃ­dos com sucesso.", "success");
                    await loadPatientList();
                } catch (e) {
                    appendOutput(`Erro ao excluir paciente: ${e.message}`, "error");
                }
            });
        };

        const generatePatientPDF = async (patientId) => {
            try {
                const patientSnap = await getDoc(doc(db, "patients", patientId));
                if (!patientSnap.exists()) return appendOutput("Paciente nÃ£o encontrado.", "error");

                const patient = patientSnap.data();
                if (!patient.consultations || patient.consultations.length === 0) {
                    return appendOutput("Nenhuma consulta registrada para gerar PDF.", "info");
                }

                const { jsPDF } = window.jspdf;
                const pdfDoc = new jsPDF();

                pdfDoc.setFontSize(18).text('AXON A.I - ProntuÃ¡rio MÃ©dico Completo', 105, 20, { align: 'center' });
                pdfDoc.setFontSize(14).text(`Paciente: ${patient.patientName}`, 14, 35);
                pdfDoc.setFontSize(12).text(`Data de Nascimento: ${patient.birthDate || 'N/A'}`, 14, 42);
                pdfDoc.line(14, 45, 196, 45);

                let y = 55;
                const pageHeight = pdfDoc.internal.pageSize.height;
                const addSection = (title, content, doc) => {
                    if (!content || (typeof content === 'string' && !content.trim()) || (typeof content === 'object' && Object.values(content).every(v => !v))) return;

                    if (y + 15 > pageHeight - 20) { doc.addPage(); y = 20; }
                    doc.setFontSize(12).setFont(undefined, 'bold').text(title, 14, y); y += 7;

                    const text = typeof content === 'object' ? Object.entries(content).map(([k, v]) => {
                        if (k === 'exame_fisico' && typeof v === 'object') {
                            return `EXAME FÃSICO:\n` + Object.entries(v).map(([subK, subV]) => `   - ${subK.toUpperCase()}: ${subV || 'NÃ£o informado'}`).join('\n');
                        }
                        if ((k === 'hgo' || k === 'ha') && !v) return null;
                        return `${k.toUpperCase().replace(/_/g, ' ')}: ${v || 'NÃ£o informado'}`;
                    }).filter(Boolean).join('\n') : content;

                    const splitText = doc.splitTextToSize(text, 180);

                    if (y + (splitText.length * 5) > pageHeight - 20) { doc.addPage(); y = 20; }
                    doc.setFontSize(10).setFont(undefined, 'normal').text(splitText, 14, y);
                    y += splitText.length * 5 + 5;
                };

                const sortedConsultations = [...patient.consultations]
                    .filter(c => c.date && c.date.toDate)
                    .sort((a, b) => (a.date.toDate()) - (b.date.toDate()));

                sortedConsultations.forEach((consult, index) => {
                    if (y + 20 > pageHeight - 20) { pdfDoc.addPage(); y = 20; }

                    const consultDate = consult.date ? consult.date.toDate().toLocaleString() : 'Data indisponÃ­vel';
                    pdfDoc.setFontSize(14).setFont(undefined, 'bold').text(`Consulta ${index + 1}: ${consultDate}`, 105, y, { align: 'center' });
                    y += 5;
                    pdfDoc.line(14, y, 196, y);
                    y += 10;

                    addSection('Anamnese', consult.anamnesis, pdfDoc);
                    addSection('Resultados dos Exames', consult.examsResults, pdfDoc);
                    addSection('AnÃ¡lise Visual (Axon Eye)', consult.axonEyeResults, pdfDoc);
                });

                pdfDoc.save(`prontuario_${patient.patientName.replace(/\s+/g, '_')}.pdf`);
                appendOutput(`PDF do prontuÃ¡rio completo gerado com sucesso.`, "success");

            } catch (e) { appendOutput(`Erro ao gerar PDF: ${e.message}`, "error"); console.error(e); }
        };

        const generatePDFFromCurrentSession = (patientName) => {
            if (!patientName) {
                appendOutput("Uso: /pdf [nome_do_paciente]", "error");
                return;
            }

            const { jsPDF } = window.jspdf;
            const pdfDoc = new jsPDF();

            pdfDoc.setFontSize(18).text('AXON A.I - ProntuÃ¡rio MÃ©dico', 105, 20, { align: 'center' });
            pdfDoc.setFontSize(14).text(`Paciente: ${patient.patientName}`, 14, 35);
            pdfDoc.setFontSize(12).text(`Gerado em: ${new Date().toLocaleString()}`, 14, 42);
            pdfDoc.line(14, 45, 196, 45);

            let y = 55;
            const pageHeight = pdfDoc.internal.pageSize.height;

            const addSection = (title, content) => {
                if (!content || (typeof content === 'string' && !content.trim()) || (typeof content === 'object' && Object.values(content).every(v => !v))) return;

                if (y + 15 > pageHeight - 20) { pdfDoc.addPage(); y = 20; }
                pdfDoc.setFontSize(12).setFont(undefined, 'bold').text(title, 14, y); y += 7;

                const text = typeof content === 'object' ? Object.entries(content).map(([k, v]) => {
                    if (k === 'exame_fisico' && typeof v === 'object') {
                        return `EXAME FÃSICO:\n` + Object.entries(v).map(([subK, subV]) => `   - ${subK.toUpperCase()}: ${subV || 'NÃ£o informado'}`).join('\n');
                    }
                    if ((k === 'hgo' || k === 'ha') && !v) return null;
                    return `${k.toUpperCase().replace(/_/g, ' ')}: ${v || 'NÃ£o informado'}`;
                }).filter(Boolean).join('\n') : content;

                const splitText = pdfDoc.splitTextToSize(text, 180);

                if (y + (splitText.length * 5) > pageHeight - 20) { pdfDoc.addPage(); y = 20; }
                pdfDoc.setFontSize(10).setFont(undefined, 'normal').text(splitText, 14, y);
                y += splitText.length * 5 + 5;
            };

            addSection('Anamnese', anamnesis);
            addSection('Resultados dos Exames', examsResults);
            addSection('AnÃ¡lise Visual (Axon Eye)', axonEyeResults);

            pdfDoc.save(`prontuario_atual_${patientName.replace(/\s+/g, '_')}.pdf`);
            appendOutput(`PDF da sessÃ£o atual gerado com sucesso.`, "success");
        };

        const showPatientDetails = (patient) => {
            patientDetailsTitle.textContent = `Paciente: ${patient.patientName}`;
            let detailsHTML = '';

            const addDetailSection = (title, content) => {
                if (!content || (typeof content === 'string' && !content.trim()) || (typeof content === 'object' && Object.values(content).every(v => !v))) return '';
                let body = '';
                if (title === 'ANAMNESE' && typeof content === 'object') {
                    const order = ['qp', 'hma', 'hp', 'hf', 'hps', 'hgo', 'ha', 'ectoscopia', 'dados_vitais', 'exame_fisico'];
                    body = order
                        .map(key => {
                            if (content.hasOwnProperty(key)) {
                                if (key === 'exame_fisico' && typeof content[key] === 'object') {
                                    const ef = content[key];
                                    let efHtml = '<br><strong>EXAME FÃSICO:</strong><div style="padding-left: 10px; border-left: 2px solid var(--border-color); margin-left: 5px;">';
                                    efHtml += `<div><strong>SCV:</strong> ${ef.scv || "NÃ£o informado"}</div>`;
                                    efHtml += `<div><strong>SR:</strong> ${ef.sr || "NÃ£o informado"}</div>`;
                                    efHtml += `<div><strong>SD:</strong> ${ef.sd || "NÃ£o informado"}</div>`;
                                    if (ef.dermatologico) efHtml += `<div><strong>DERMATOLÃ“GICO:</strong> ${ef.dermatologico}</div>`;
                                    efHtml += '</div><br>';
                                    return efHtml;
                                }
                                if ((key === 'hgo' || key === 'ha') && !content[key]) return ''; // Skip empty conditional fields
                                return `<strong>${key.toUpperCase()}:</strong> ${content[key] || "NÃ£o informado"}<br>`;
                            }
                            return '';
                        })
                        .join('');
                } else if (typeof content === 'object') {
                    body = Object.entries(content).map(([k, v]) => `<strong>${k.toUpperCase()}:</strong> ${v || "NÃ£o informado"}<br>`).join('');
                } else {
                    body = content.replace(/\n/g, '<br>');
                }
                return `<div class="patient-details-section"><div class="patient-details-section-title">${title}</div><div>${body}</div></div>`;
            };

            if (patient.consultations && patient.consultations.length > 0) {
                const sortedConsultations = [...patient.consultations]
                    .filter(c => c.date && c.date.toDate)
                    .sort((a, b) => b.date.toDate() - a.date.toDate());
                detailsHTML += `<div class="consultation-list">`;
                sortedConsultations.forEach((consult, index) => {
                    const consultDate = consult.date ? consult.date.toDate().toLocaleString() : 'Data indisponÃ­vel';
                    detailsHTML += `<div class="consultation-item">
                                        <div class="consultation-header">
                                            <i class="fas fa-chevron-right"></i> Consulta de ${consultDate}
                                        </div>
                                        <div class="consultation-body" style="display: none;">
                                            ${addDetailSection('ANAMNESE', consult.anamnesis)}
                                            ${addDetailSection('RESULTADOS DOS EXAMES', consult.examsResults)}
                                            ${addDetailSection('ANÃLISE VISUAL (AXON EYE)', consult.axonEyeResults)}`;
                    if (consult.axonEyeImages && consult.axonEyeImages.length > 0) {
                        detailsHTML += `<div class="patient-details-section"><div class="patient-details-section-title">IMAGENS (${consult.axonEyeImages.length})</div><div class="patient-images-grid">`;
                        consult.axonEyeImages.forEach(img => {
                            detailsHTML += `<div class="patient-image-item"><img src="${img.link}" class="patient-image" onclick="openFullscreenModal('${img.link}')" alt="Imagem do paciente"></div>`;
                        });
                        detailsHTML += `</div></div>`;
                    }
                    detailsHTML += `</div></div>`;
                });
                detailsHTML += `</div>`;
            } else {
                detailsHTML = '<div class="info">Nenhuma consulta registrada para este paciente.</div>';
            }
            patientDetailsBody.innerHTML = detailsHTML;
            patientDetailsModal.style.display = 'flex';
        };

        const openSaveModal = () => {
            savePatientNameInput.value = '';
            savePatientDobInput.value = '';
            savePatientFeedback.textContent = '';
            savePatientModal.style.display = 'flex';
            savePatientNameInput.focus();
        };

        const closeSaveModal = () => {
            savePatientModal.style.display = 'none';
        };

        const handleSuccessfulLogin = (username, isRestoredSession = false) => {
            isLoggedIn = true; currentUser = username; localStorage.setItem('axon_logged_in_user', username);
            loginModal.style.display = 'none';
            if (isRestoredSession) appendOutput(`SessÃ£o restaurada para: ${currentUser}`, "success", false);
            else appendOutput(`Login bem-sucedido. Bem-vindo, ${currentUser}.`, "success", false);

            initialMessagesContainer.style.display = 'none';

            mobileWelcomeTitle.textContent = `Bem-vindo, ${currentUser}!`;

            appendOutput("SessÃ£o pronta. Informe os dados do paciente ou use um comando.", "success");

            if (desktopHeartbeatInterval) clearInterval(desktopHeartbeatInterval);
            if (!isMobile) {
                const updateDesktopStatus = () => {
                    if (isLoggedIn && currentUser) {
                        const desktopInfo = getDesktopInfo();
                        const sessionRef = doc(db, "sessions", currentUser);
                        setDoc(sessionRef, {
                            desktopConnection: { ...desktopInfo, timestamp: new Date() }
                        }, { merge: true }).catch(e => console.error("Heartbeat failed:", e));
                    }
                };
                updateDesktopStatus();
                desktopHeartbeatInterval = setInterval(updateDesktopStatus, 15000);
            }

            if (unsubscribeUserDoc) {
                unsubscribeUserDoc();
            }
            const userRef = doc(db, "users", username);
            unsubscribeUserDoc = onSnapshot(userRef, (docSnap) => {
                if (!docSnap.exists() && isLoggedIn && currentUser === username) {
                    appendOutput("Sua conta de usuÃ¡rio foi removida. Desconectando automaticamente...", "error");
                    setTimeout(() => {
                        logoutUser();
                    }, 3000);
                } else if (docSnap.exists()) {
                    const userData = docSnap.data();
                    if (userData.isBlocked !== isUserBlocked) {
                        isUserBlocked = userData.isBlocked || false;
                        updateBlockedUI();
                    }
                    if (userData.isCloudDisabled !== isCloudDisabled) {
                        isCloudDisabled = userData.isCloudDisabled || false;
                        if (btnCloud) {
                            if (isCloudDisabled) {
                                btnCloud.classList.add('blocked-ui');
                            } else {
                                btnCloud.classList.remove('blocked-ui');
                            }
                        }
                    }
                }
            }, (error) => {
                console.error("Listener error for user document:", error);
                appendOutput("Erro de conexÃ£o ao verificar sua conta. Desconectando por seguranÃ§a.", "error");
                setTimeout(() => {
                    logoutUser();
                }, 3000);
            });

            setupFirebaseListener(currentUser);
            setupTransferListener(currentUser); // Setup P2P Transfer Listener
            if (window.axonPluginManager) window.axonPluginManager.startPluginListener();
            // setupGlobalSettingsListener(); // Moved to initApp

            axonCloud = new AxonCloud(currentUser);


            if (window.loadFreeModeData) window.loadFreeModeData();
            toggleMonitorView('anamnesis');
        };

        const searchPatients = (searchTerm) => {
            const lowerCaseSearchTerm = searchTerm.toLowerCase();
            const patientItems = patientList.querySelectorAll('.patient-item');
            let visibleCount = 0;

            patientItems.forEach(item => {
                const patientName = item.querySelector('strong')?.textContent.toLowerCase();
                if (patientName && patientName.includes(lowerCaseSearchTerm)) {
                    item.style.display = 'block';
                    visibleCount++;
                } else {
                    item.style.display = 'none';
                }
            });

            const noResultsMessage = patientList.querySelector('.info');
            if (noResultsMessage) {
                noResultsMessage.remove();
            }

            if (visibleCount === 0 && patientItems.length > 0) {
                const noResults = document.createElement('div');
                noResults.className = 'info';
                noResults.textContent = 'Nenhum paciente encontrado.';
                patientList.appendChild(noResults);
            }
        };

        const openAdminAuth = () => {
            adminAuthPass.value = '';
            adminAuthFeedback.textContent = '';
            adminAuthModal.style.display = 'flex';
            adminAuthPass.focus();
        };

        const checkAdminAuth = () => {
            if (adminAuthPass.value === 'admin123') {
                adminAuthModal.style.display = 'none';
                adminPanelModal.style.display = 'flex';
                activateAdminTab('users');
            } else {
                adminAuthFeedback.textContent = 'Senha incorreta.';
            }
        };

        const disconnectAllUsers = async () => {
            showConfirmModal(
                "Tem certeza de que deseja desconectar TODOS os usuÃ¡rios de suas sessÃµes de desktop ativas? Isso forÃ§arÃ¡ um novo login para todos.",
                async () => {
                    const feedbackEl = document.getElementById('admin-create-user-feedback') || { textContent: '', style: {} };
                    feedbackEl.textContent = 'Desconectando todos os usuÃ¡rios...';
                    feedbackEl.style.color = 'var(--prompt-color)';

                    try {
                        const sessionsRef = collection(db, "sessions");
                        const sessionsSnap = await getDocs(sessionsRef);

                        if (sessionsSnap.empty) {
                            feedbackEl.textContent = 'Nenhuma sessÃ£o ativa para desconectar.';
                            feedbackEl.style.color = 'var(--info-color)';
                            return;
                        }

                        const batch = writeBatch(db);
                        sessionsSnap.forEach(doc => {
                            batch.delete(doc.ref);
                        });
                        await batch.commit();

                        feedbackEl.textContent = `Sucesso! ${sessionsSnap.size} sessÃ£o(Ãµes) encerrada(s).`;
                        feedbackEl.style.color = 'var(--success-color)';

                    } catch (e) {
                        feedbackEl.textContent = `Erro: ${e.message}`;
                        feedbackEl.style.color = 'var(--error-color)';
                        console.error("Erro ao desconectar todos os usuÃ¡rios:", e);
                    }
                }
            );
        };



        window.createUserFromPanel = async () => {
            const usernameInput = document.getElementById('admin-new-user');
            const passwordInput = document.getElementById('admin-new-pass');
            const feedbackEl = document.getElementById('admin-create-user-feedback');

            const username = usernameInput.value.trim();
            const password = passwordInput.value.trim();

            if (!username || !password) {
                feedbackEl.textContent = "Preencha todos os campos.";
                feedbackEl.style.color = 'var(--error-color)';
                return;
            }

            feedbackEl.textContent = 'Verificando...';
            feedbackEl.style.color = 'var(--prompt-color)';

            try {
                const userRef = doc(db, "users", username);
                const docSnap = await getDoc(userRef);
                if (docSnap.exists()) {
                    feedbackEl.textContent = `UsuÃ¡rio '${username}' jÃ¡ existe.`;
                    feedbackEl.style.color = 'var(--error-color)';
                } else {
                    await setDoc(userRef, { password, createdAt: new Date(), textRequests: 0, visionRequests: 0, isBlocked: false });
                    feedbackEl.textContent = `UsuÃ¡rio '${username}' criado!`;
                    feedbackEl.style.color = 'var(--success-color)';
                    usernameInput.value = '';
                    passwordInput.value = '';
                    await loadAdminUsersData(); // Refresh list
                }
            } catch (e) {
                feedbackEl.textContent = `Erro: ${e.message}`;
                feedbackEl.style.color = 'var(--error-color)';
            }
        };

        const renderAdminSettingsUI = () => {
            const isManual = globalSettings.mode === 'manual';
            const isGoogle = globalSettings.apiProvider === 'gemini';
            const isOpenRouter = globalSettings.apiProvider === 'openrouter';
            const isGroq = globalSettings.apiProvider === 'groq';
            const isCustom = globalSettings.apiProvider === 'custom';

            const textModelsOptions = globalSettings.apiModels.map(m =>
                `<option value="${m.name}" ${globalSettings.manualTextModel === m.name ? 'selected' : ''}>${m.name}</option>`
            ).join('');

            const visionModelsOptions = globalSettings.apiModels.filter(m => m.vision).map(m =>
                `<option value="${m.name}" ${globalSettings.manualVisionModel === m.name ? 'selected' : ''}>${m.name}</option>`
            ).join('');

            const apiKeysOptions = globalSettings.apiKeys.map(key =>
                `<option value="${key}" ${globalSettings.manualApiKey === key ? 'selected' : ''}>${key}</option>`
            ).join('');

            const openRouterModelsOptions = openRouterModels.map(m =>
                `<option value="${m.name}" ${globalSettings.openRouterModel === m.name ? 'selected' : ''}>${m.name} ${m.vision ? '(+VisÃ£o)' : ''}</option>`
            ).join('');

            const groqList = globalSettings.groqAvailableModels || groqModels;

            const groqTextModelsOptions = groqList.map(m =>
                `<option value="${m.name}" ${globalSettings.groqTextModel === m.name ? 'selected' : ''}>${m.name}</option>`
            ).join('');

            const groqVisionModelsOptions = groqList.map(m =>
                `<option value="${m.name}" ${globalSettings.groqVisionModel === m.name ? 'selected' : ''}>${m.name}</option>`
            ).join('');

            let html = `
                <div class="admin-section">
                    <div class="admin-section-title">Provedor da API</div>
                    <div class="radio-group">
                        <label class="radio-label">
                            <input type="radio" name="apiProvider" value="gemini" ${isGoogle ? 'checked' : ''} onchange="window.updateProvider('gemini')"> Google Gemini (Direto)
                        </label>
                        <label class="radio-label">
                            <input type="radio" name="apiProvider" value="openrouter" ${isOpenRouter ? 'checked' : ''} onchange="window.updateProvider('openrouter')"> OpenRouter (Universal)
                        </label>
                        <label class="radio-label">
                            <input type="radio" name="apiProvider" value="groq" ${isGroq ? 'checked' : ''} onchange="window.updateProvider('groq')"> Groq (Ultra RÃ¡pido)
                        </label>
                        <label class="radio-label">
                            <input type="radio" name="apiProvider" value="custom" ${isCustom ? 'checked' : ''} onchange="window.updateProvider('custom')"> Customizado (Misto)
                        </label>
                    </div>
                </div>
            `;

            if (isCustom) {
                html += `
                <div class="admin-section">
                    <div class="admin-section-title">ConfiguraÃ§Ã£o Customizada</div>
                    
                    <label>Provedor para Tarefas de Texto:</label>
                    <select id="custom-text-provider" class="admin-input" style="width:100%; margin-bottom:10px;" onchange="window.saveManualSelection()">
                        <option value="gemini" ${globalSettings.customTextProvider === 'gemini' ? 'selected' : ''}>Google Gemini</option>
                        <option value="openrouter" ${globalSettings.customTextProvider === 'openrouter' ? 'selected' : ''}>OpenRouter</option>
                        <option value="groq" ${globalSettings.customTextProvider === 'groq' ? 'selected' : ''}>Groq</option>
                    </select>

                    <label>Provedor para Tarefas de VisÃ£o (Imagens):</label>
                    <select id="custom-vision-provider" class="admin-input" style="width:100%; margin-bottom:10px;" onchange="window.saveManualSelection()">
                        <option value="gemini" ${globalSettings.customVisionProvider === 'gemini' ? 'selected' : ''}>Google Gemini</option>
                        <option value="openrouter" ${globalSettings.customVisionProvider === 'openrouter' ? 'selected' : ''}>OpenRouter</option>
                        <option value="groq" ${globalSettings.customVisionProvider === 'groq' ? 'selected' : ''}>Groq</option>
                    </select>
                    
                    <div class="info" style="font-size: 12px; margin-top: 10px;">
                        Nota: As configuraÃ§Ãµes para cada provedor (chaves, modelos) devem ser ajustadas em suas respectivas abas. A seleÃ§Ã£o customizada apenas direciona as chamadas.
                    </div>
                </div>
                `;
            } else if (isGoogle) {
                html += `
                <div class="admin-section">
                    <div class="admin-section-title">Modo Google (Direto)</div>
                    <div class="radio-group">
                        <label class="radio-label">
                            <input type="radio" name="apiMode" value="automatic" ${!isManual ? 'checked' : ''} onchange="window.updateMode('automatic')"> AutomÃ¡tico (RotaÃ§Ã£o)
                        </label>
                        <label class="radio-label">
                            <input type="radio" name="apiMode" value="manual" ${isManual ? 'checked' : ''} onchange="window.updateMode('manual')"> Manual (Fixo)
                        </label>
                    </div>

                    <div id="manual-settings" style="display: ${isManual ? 'block' : 'none'}; margin-top: 15px;">
                        <div class="admin-section-title">SeleÃ§Ã£o Manual</div>
                        <label>Motor de Texto:</label>
                        <select id="manual-text-select" class="admin-input" style="width:100%; margin-bottom:10px;" onchange="window.saveManualSelection()">
                            <option value="">Selecione...</option>
                            ${textModelsOptions}
                        </select>
                        
                        <label>Motor de VisÃ£o:</label>
                        <select id="manual-vision-select" class="admin-input" style="width:100%; margin-bottom:10px;" onchange="window.saveManualSelection()">
                            <option value="">Selecione...</option>
                            ${visionModelsOptions}
                        </select>
                        
                        <label>Chave API:</label>
                        <select id="manual-key-select" class="admin-input" style="width:100%;" onchange="window.saveManualSelection()">
                            <option value="">Selecione...</option>
                            ${apiKeysOptions}
                        </select>
                    </div>
                </div>

                <div class="admin-section">
                    <div class="admin-section-title">Chaves de API (Google)</div>
                    <div class="admin-list" id="api-keys-list">
                        ${globalSettings.apiKeys.map((key, index) => `
                            <div class="admin-list-item">
                                <input type="text" class="admin-input" value="${key}" readonly>
                                <button class="patient-action-button delete" style="flex:0;" onclick="window.removeApiKey(${index})"><i class="fas fa-trash"></i></button>
                            </div>
                        `).join('')}
                    </div>
                    <div class="admin-list-item" style="margin-top: 10px;">
                         <input type="text" id="new-api-key" class="admin-input" placeholder="Nova chave API...">
                         <button class="patient-action-button pdf" style="flex:0;" onclick="window.addApiKey()">Adicionar</button>
                    </div>
                </div>
                `;
            } else if (isOpenRouter) {
                html += `
                <div class="admin-section">
                    <div class="admin-section-title">ConfiguraÃ§Ã£o OpenRouter</div>
                    <label>Chave de API OpenRouter:</label>
                    <input type="text" id="openrouter-key-input" class="admin-input" style="width: 100%; margin-bottom: 10px;" value="${globalSettings.openRouterKey}" onchange="window.saveManualSelection()">
                    
                    <label>Modelo (Texto e VisÃ£o):</label>
                    <select id="openrouter-model-select" class="admin-input" style="width:100%;" onchange="window.saveManualSelection()">
                        ${openRouterModelsOptions}
                    </select>
                </div>
                `;
            } else if (isGroq) {
                html += `
                <div class="admin-section">
                    <div class="admin-section-title">ConfiguraÃ§Ã£o Groq</div>
                    <label>Chave de API Groq:</label>
                    <div style="display:flex; gap:10px; margin-bottom:10px;">
                        <input type="text" id="groq-key-input" class="admin-input" style="flex:1;" value="${globalSettings.groqKey}" onchange="window.saveManualSelection()">
                        <button class="patient-action-button" id="btn-refresh-groq" style="flex:0; white-space:nowrap;" onclick="window.refreshGroqModels()">
                            <i class="fas fa-sync-alt"></i> Atualizar Modelos
                        </button>
                    </div>
                    
                    <label>Modelo de Texto:</label>
                    <select id="groq-text-model-select" class="admin-input" style="width:100%; margin-bottom:10px;" onchange="window.saveManualSelection()">
                        <option value="">Selecione...</option>
                        ${groqTextModelsOptions}
                    </select>

                    <label>Modelo de VisÃ£o:</label>
                    <select id="groq-vision-model-select" class="admin-input" style="width:100%;" onchange="window.saveManualSelection()">
                        <option value="">Selecione...</option>
                        ${groqVisionModelsOptions}
                    </select>
                </div>
                `;
            }

            if (isGoogle) {
                html += `
                <div class="admin-section">
                    <div class="admin-section-title">Motores de IA (Google)</div>
                    <div class="admin-list" id="api-models-list">
                         ${globalSettings.apiModels.map((model, index) => `
                            <div class="admin-list-item">
                                <div style="flex: 1;">
                                    <div style="font-size: 12px; font-weight: bold;">${model.name}</div>
                                    <div style="font-size: 10px; color: #888;">${model.vision ? 'VisÃ£o' : 'Texto'}</div>
                                </div>
                                <button class="patient-action-button delete" style="flex:0;" onclick="window.removeApiModel(${index})"><i class="fas fa-trash"></i></button>
                            </div>
                        `).join('')}
                    </div>
                    <div style="margin-top: 10px; border-top: 1px solid var(--border-color); padding-top: 10px;">
                        <input type="text" id="new-model-name" class="admin-input" placeholder="Nome do modelo (ex: gemini-1.5-pro)" style="width: 100%; margin-bottom: 5px;">
                        <label class="radio-label" style="font-size: 12px; margin-bottom: 10px;">
                            <input type="checkbox" id="new-model-vision"> Suporta VisÃ£o?
                        </label>
                        <button class="app-modal-button" onclick="window.addApiModel()">Adicionar Modelo</button>
                    </div>
                </div>
                `;
            }

            adminSettingsBody.innerHTML = html;
        };

        const renderAdminDebugUI = () => {
            adminDebugBody.innerHTML = `
                <div class="admin-section">
                    <div class="admin-section-title">Layout</div>
                    <div style="display: flex; align-items: center; justify-content: space-between;">
                        <span>Modo Mobile 2.0 (Interface simplificada)</span>
                        <label class="toggle-switch">
                            <input type="checkbox" id="mobile-2-0-toggle" ${globalSettings.mobile2_0_enabled ? 'checked' : ''}>
                            <span class="slider"></span>
                        </label>
                    </div>
                </div>
                <div class="admin-section" style="margin-top: 15px;">
                    <div class="admin-section-title">Assistente de PrescriÃ§Ã£o</div>
                    <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 10px;">
                        <span>Mostrar BotÃ£o Assistente</span>
                        <label class="toggle-switch">
                            <input type="checkbox" id="toggle-assist-btn-visibility">
                            <span class="slider"></span>
                        </label>
                    </div>
                     <div style="display: flex; align-items: center; justify-content: space-between;">
                        <span>Mostrar BotÃ£o Ferramentas (Plugins)</span>
                        <label class="toggle-switch">
                            <input type="checkbox" id="toggle-tools-btn-visibility">
                            <span class="slider"></span>
                        </label>
                    </div>

                </div>
                <div class="admin-section" style="margin-top: 15px;">
                    <div class="admin-section-title">Feedback e Logs</div>
                     <div style="display: flex; align-items: center; justify-content: space-between;">
                        <span>Gerenciar Logs do Terminal</span>
                        <button class="app-modal-button" onclick="window.openLogSettings()" style="width: auto; padding: 5px 15px;">Configurar</button>
                    </div>
                </div>
                <div class="admin-section" style="margin-top: 15px;">
                    <div class="admin-section-title">Controle de Acesso Axon Web</div>
                     <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 10px;">
                        <span>Desativar Acesso Web (Bloquear comum)</span>
                        <label class="toggle-switch">
                            <input type="checkbox" id="toggle-axon-web-disabled" ${globalSettings.axonWebDisabled ? 'checked' : ''}>
                            <span class="slider"></span>
                        </label>
                    </div>
                    <label style="display:block; margin-bottom:5px; font-size:12px;">Mensagem de Bloqueio:</label>
                    <textarea id="axon-web-disabled-message" class="admin-input" style="width:100%; height:80px; margin-bottom:10px;">${globalSettings.axonWebDisabledMessage || "A partir de hoje o sistema somente pode ser acessado via dipostivo Axon USB! Caso ainda nÃ£o tenha adquirido entre em contato com o suporte; (38) 998517363."}</textarea>
                    <div style="text-align:right;">
                        <button class="app-modal-button" onclick="window.saveWebLockSettings()">Salvar Mensagem e Estado</button>
                    </div>
                </div>

                <div class="admin-section" style="margin-top: 15px;">
                    <div class="admin-section-title">Backup & Restore (Firestore)</div>
                    <div style="display: flex; flex-direction: column; gap: 10px;">
                        <button class="app-modal-button" onclick="window.backupFirestore()">Baixar Backup (JSON)</button>
                        <div style="display: flex; gap: 10px; align-items: center;">
                            <input type="file" id="restore-file-input" accept=".json" style="display: none;" onchange="window.restoreFirestore(this)">
                            <button class="app-modal-button" style="background-color: var(--highlight-color);" onclick="document.getElementById('restore-file-input').click()">Restaurar Backup (JSON)</button>
                        </div>
                        <div id="backup-restore-feedback" class="app-modal-feedback" style="text-align: left; font-size: 12px;"></div>
                    </div>
                </div>
            `;
            document.getElementById('mobile-2-0-toggle').addEventListener('change', async (e) => {
                try {
                    await setDoc(doc(db, "settings", "global"), { mobile2_0_enabled: e.target.checked }, { merge: true });
                } catch (err) {
                    console.error("Erro ao salvar modo Mobile 2.0:", err);
                }
            });

            // Prescription Assistant Toggles
            // Prescription Assistant Toggles
            const toggleAssistBtn = document.getElementById('toggle-assist-btn-visibility');
            if (toggleAssistBtn) {
                // Load saved state from Global Settings
                const shouldShow = globalSettings.showPrescriptionAssistant !== false;
                toggleAssistBtn.checked = shouldShow;

                toggleAssistBtn.addEventListener('change', async (e) => {
                    try {
                        await setDoc(doc(db, "settings", "global"), { showPrescriptionAssistant: e.target.checked }, { merge: true });
                        // Local update for immediate feedback (though listener will confirm)
                        const btn = document.getElementById('btn-prescription-assist');
                        // We rely on the global listener, but immediate feedback is nice if online.
                        // But to be consistent with "Real-time", let's wait for listener or do optimistic UI?
                        // Optimistic is better for toggle responsiveness.
                        if (btn) btn.style.display = e.target.checked ? 'flex' : 'none';
                    } catch (err) {
                        console.error("Erro ao salvar visibilidade do assistente:", err);
                        // Revert toggle if failed?
                        e.target.checked = !e.target.checked;
                    }
                });
            }

            // Tools Button Toggle
            const toggleToolsBtn = document.getElementById('toggle-tools-btn-visibility');
            if (toggleToolsBtn) {
                // Set initial state without triggering listener
                toggleToolsBtn.checked = globalSettings.showToolsButton !== false;

                toggleToolsBtn.addEventListener('change', async (e) => {
                    const newState = e.target.checked;
                    try {
                        // Optimistic update of globalSettings in memory to prevent revert on re-render if it happens fast
                        globalSettings.showToolsButton = newState;

                        // Update UI immediately
                        const btn = document.getElementById('btn-tools');
                        if (btn) btn.style.display = newState ? 'flex' : 'none';

                        await setDoc(doc(db, "settings", "global"), { showToolsButton: newState }, { merge: true });
                    } catch (err) {
                        console.error("Erro ao salvar visibilidade ferramentas:", err);
                        // Revert UI
                        e.target.checked = !newState;
                        globalSettings.showToolsButton = !newState;
                        const btn = document.getElementById('btn-tools');
                        if (btn) btn.style.display = !newState ? 'flex' : 'none';
                    }
                });
            }



        };

        window.backupFirestore = async () => {
            const feedback = document.getElementById('backup-restore-feedback');
            if (feedback) feedback.textContent = "Gerando backup...";
            try {
                const settingsDoc = await getDoc(doc(db, "settings", "global"));
                const settingsData = settingsDoc.exists() ? settingsDoc.data() : {};

                const usersSnap = await getDocs(collection(db, "users"));
                const usersData = [];
                usersSnap.forEach(doc => {
                    usersData.push({ id: doc.id, data: doc.data() });
                });

                const backupData = {
                    settings: settingsData,
                    users: usersData,
                    timestamp: new Date().toISOString(),
                    version: "1.6"
                };

                const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(backupData, null, 2));
                const downloadAnchorNode = document.createElement('a');
                downloadAnchorNode.setAttribute("href", dataStr);
                downloadAnchorNode.setAttribute("download", "axon_backup_" + new Date().toISOString().slice(0, 10) + ".json");
                document.body.appendChild(downloadAnchorNode);
                downloadAnchorNode.click();
                downloadAnchorNode.remove();
                if (feedback) {
                    feedback.textContent = "Backup baixado com sucesso!";
                    feedback.style.color = "var(--success-color)";
                }
            } catch (e) {
                console.error("Erro no backup:", e);
                if (feedback) {
                    feedback.textContent = "Erro ao gerar backup: " + e.message;
                    feedback.style.color = "var(--error-color)";
                }
            }
        };

        window.restoreFirestore = async (input) => {
            const feedback = document.getElementById('backup-restore-feedback');
            if (input.files && input.files[0]) {
                const file = input.files[0];
                const reader = new FileReader();
                if (feedback) feedback.textContent = "Lendo arquivo...";

                reader.onload = async function (e) {
                    try {
                        const backupData = JSON.parse(e.target.result);
                        if (feedback) feedback.textContent = "Restaurando dados...";

                        if (backupData.settings) {
                            await setDoc(doc(db, "settings", "global"), backupData.settings, { merge: true });
                        }

                        if (backupData.users && Array.isArray(backupData.users)) {
                            for (const user of backupData.users) {
                                if (user.id && user.data) {
                                    await setDoc(doc(db, "users", user.id), user.data, { merge: true });
                                }
                            }
                        }

                        if (feedback) {
                            feedback.textContent = "RestauraÃ§Ã£o concluÃ­da com sucesso! Recarregando...";
                            feedback.style.color = "var(--success-color)";
                        }
                        setTimeout(() => window.location.reload(), 2000);

                    } catch (err) {
                        console.error("Erro na restauraÃ§Ã£o:", err);
                        if (feedback) {
                            feedback.textContent = "Erro ao restaurar: " + err.message;
                            feedback.style.color = "var(--error-color)";
                        }
                    }
                };
                reader.readAsText(file);
            }
        };

        window.updateProvider = async (provider) => {
            try {
                await setDoc(doc(db, "settings", "global"), { ...globalSettings, apiProvider: provider }, { merge: true });
            } catch (e) { console.error("Erro ao atualizar provedor:", e); }
        };

        window.updateMode = async (mode) => {
            try {
                await setDoc(doc(db, "settings", "global"), { ...globalSettings, mode }, { merge: true });
            } catch (e) { console.error("Erro ao atualizar modo:", e); }
        };

        window.saveManualSelection = async () => {
            let updates = {};

            if (globalSettings.apiProvider === 'gemini') {
                const textModel = document.getElementById('manual-text-select')?.value;
                const visionModel = document.getElementById('manual-vision-select')?.value;
                const apiKey = document.getElementById('manual-key-select')?.value;
                updates = {
                    manualTextModel: textModel,
                    manualVisionModel: visionModel,
                    manualApiKey: apiKey
                };
            } else if (globalSettings.apiProvider === 'openrouter') {
                const orKey = document.getElementById('openrouter-key-input')?.value;
                const orModel = document.getElementById('openrouter-model-select')?.value;
                updates = {
                    openRouterKey: orKey,
                    openRouterModel: orModel
                };
            } else if (globalSettings.apiProvider === 'groq') {
                const groqKey = document.getElementById('groq-key-input')?.value;
                const groqTextModel = document.getElementById('groq-text-model-select')?.value;
                const groqVisionModel = document.getElementById('groq-vision-model-select')?.value;
                updates = {
                    groqKey: groqKey,
                    groqTextModel: groqTextModel,
                    groqVisionModel: groqVisionModel
                };
            } else if (globalSettings.apiProvider === 'custom') {
                const textProvider = document.getElementById('custom-text-provider')?.value;
                const visionProvider = document.getElementById('custom-vision-provider')?.value;
                updates = {
                    customTextProvider: textProvider,
                    customVisionProvider: visionProvider
                };
            }

            try {
                await setDoc(doc(db, "settings", "global"), {
                    ...globalSettings,
                    ...updates
                }, { merge: true });
            } catch (e) { console.error("Erro ao salvar seleÃ§Ã£o manual:", e); }
        };

        window.openLogSettings = () => {
            const modal = document.getElementById('log-settings-modal');
            const toggle = document.getElementById('modal-hide-status-toggle');
            if (modal && toggle) {
                toggle.checked = globalSettings.hideStatusMessages || false;
                modal.style.display = 'flex';
            }
        };

        window.toggleLogSuppression = async (isChecked) => {
            try {
                // Optimistic UI update
                globalSettings.hideStatusMessages = isChecked;
                applySettings(); // Immediately applies CSS class

                await setDoc(doc(db, "settings", "global"), {
                    hideStatusMessages: isChecked
                }, { merge: true });
            } catch (e) {
                console.error("Erro ao salvar configuraÃ§Ã£o de log:", e);
                // Revert if error
                globalSettings.hideStatusMessages = !isChecked;
                applySettings();
            }
        };

        window.refreshGroqModels = async () => {
            const apiKey = document.getElementById('groq-key-input').value;
            if (!apiKey) { alert("Insira a chave API do Groq primeiro."); return; }

            const btn = document.getElementById('btn-refresh-groq');
            const originalContent = btn.innerHTML;
            btn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Buscando...';
            btn.disabled = true;

            try {
                const headers = { "Content-Type": "application/json" };
                if (apiKey) { // Use the input API key for the request
                    headers['Authorization'] = `Bearer ${apiKey}`;
                }

                const response = await fetch("https://api.groq.com/openai/v1/models", {
                    method: "GET",
                    headers: headers
                });

                if (!response.ok) throw new Error(`Erro: ${response.status} ${response.statusText}`);

                const data = await response.json();

                // Process models
                const models = data.data.map(m => ({
                    name: m.id,
                    vision: m.id.includes('vision') || m.id.includes('llama-3.2') // Simple heuristic
                })).sort((a, b) => a.name.localeCompare(b.name));

                await setDoc(doc(db, "settings", "global"), {
                    ...globalSettings,
                    groqAvailableModels: models
                }, { merge: true });

                alert("Modelos atualizados com sucesso!");
                // The onSnapshot will trigger re-render

            } catch (e) {
                console.error(e);
                alert("Erro ao buscar modelos: " + e.message);
            } finally {
                btn.innerHTML = originalContent;
                btn.disabled = false;
            }
        };

        window.saveWebLockSettings = async () => {
            const toggle = document.getElementById('toggle-axon-web-disabled');
            const messageInput = document.getElementById('axon-web-disabled-message');
            if (!toggle || !messageInput) return;

            const isDisabled = toggle.checked;
            const message = messageInput.value;

            try {
                await setDoc(doc(db, "settings", "global"), {
                    axonWebDisabled: isDisabled,
                    axonWebDisabledMessage: message
                }, { merge: true });
                appendOutput("ConfiguraÃ§Ãµes de restriÃ§Ã£o Web salvas.", "success");
            } catch (e) {
                console.error("Erro ao salvar restriÃ§Ã£o web:", e);
                appendOutput("Erro ao salvar restriÃ§Ã£o.", "error");
            }
        };

        window.addApiKey = async () => {
            const input = document.getElementById('new-api-key');
            const newKey = input.value.trim();
            if (newKey) {
                const newKeys = [...globalSettings.apiKeys, newKey];
                try {
                    await setDoc(doc(db, "settings", "global"), { ...globalSettings, apiKeys: newKeys }, { merge: true });
                    input.value = '';
                } catch (e) { console.error("Erro ao adicionar chave:", e); }
            }
        };

        window.removeApiKey = async (index) => {
            if (globalSettings.apiKeys.length <= 1) {
                alert("Ã‰ necessÃ¡rio ter pelo menos uma chave de API.");
                return;
            }
            const newKeys = globalSettings.apiKeys.filter((_, i) => i !== index);
            try {
                await setDoc(doc(db, "settings", "global"), { ...globalSettings, apiKeys: newKeys }, { merge: true });
            } catch (e) { console.error("Erro ao remover chave:", e); }
        };

        window.addApiModel = async () => {
            const nameInput = document.getElementById('new-model-name');
            const visionInput = document.getElementById('new-model-vision');
            const name = nameInput.value.trim();
            if (name) {
                const newModel = { id: Date.now(), name, vision: visionInput.checked };
                const newModels = [...globalSettings.apiModels, newModel];
                try {
                    await setDoc(doc(db, "settings", "global"), { ...globalSettings, apiModels: newModels }, { merge: true });
                    nameInput.value = '';
                    visionInput.checked = false;
                } catch (e) { console.error("Erro ao adicionar modelo:", e); }
            }
        };

        window.removeApiModel = async (index) => {
            if (globalSettings.apiModels.length <= 1) {
                alert("Ã‰ necessÃ¡rio ter pelo menos um modelo.");
                return;
            }
            const newModels = globalSettings.apiModels.filter((_, i) => i !== index);
            try {
                await setDoc(doc(db, "settings", "global"), { ...globalSettings, apiModels: newModels }, { merge: true });
            } catch (e) { console.error("Erro ao remover modelo:", e); }
        };

        const loadAdminUsersData = async () => {
            try {
                const usersSnap = await getDocs(collection(db, "users"));
                const users = [];

                const patientsSnap = await getDocs(collection(db, "patients"));
                const savedCounts = {};
                patientsSnap.forEach(doc => {
                    const data = doc.data();
                    if (data.savedBy) {
                        savedCounts[data.savedBy] = (savedCounts[data.savedBy] || 0) + 1;
                    }
                });

                usersSnap.forEach(doc => {
                    const userData = doc.data();
                    users.push({
                        username: doc.id,
                        ...userData,
                        savedCount: savedCounts[doc.id] || 0
                    });
                });

                users.sort((a, b) => b.savedCount - a.savedCount);
                adminUsersData = users;
                renderAdminUsersList(users);

            } catch (e) {
                console.error("Erro ao carregar usuÃ¡rios:", e);
                adminUsersList.innerHTML = `<div class="error">Erro ao carregar dados: ${e.message}</div>`;
            }
        };

        const renderAdminUsersList = (users) => {
            if (users.length === 0) {
                adminUsersList.innerHTML = '<div class="info">Nenhum usuÃ¡rio encontrado.</div>';
                return;
            }

            adminUsersList.innerHTML = users.map(user => `
                <div class="user-list-item" onclick="window.selectAdminUser('${user.username}')" id="user-item-${user.username}">
                    <div>
                        <span class="user-name" style="${user.isBlocked ? 'text-decoration: line-through; color: #666;' : ''}">${user.username}</span>
                        <div style="font-size: 10px; color: #666;">Registrado em: ${user.createdAt ? user.createdAt.toDate().toLocaleDateString() : 'N/A'}</div>
                    </div>
                    <div style="display: flex; gap: 5px; align-items:center;">
                        ${user.isBlocked ? '<span class="analytics-badge" style="color: #ffcc00; border: 1px solid #ffcc00; padding:2px 5px; border-radius:10px;">Bloqueado</span>' : ''}
                        <span class="analytics-badge ${user.savedCount > 0 ? 'analytics-high' : ''}" style="border: 1px solid; padding:2px 5px; border-radius:10px;">${user.savedCount} Pacientes</span>
                    </div>
                </div>
            `).join('');
        };

        window.selectAdminUser = async (username) => {
            document.querySelectorAll('.user-list-item').forEach(el => el.classList.remove('selected'));
            const selectedEl = document.getElementById(`user-item-${username}`);
            if (selectedEl) selectedEl.classList.add('selected');

            const user = adminUsersData.find(u => u.username === username);
            if (!user) return;

            adminUserDetails.innerHTML = '<div class="info">Carregando detalhes e imagens...</div>';

            try {
                const patientsQuery = query(collection(db, "patients"), where("savedBy", "==", username));
                const patientsSnap = await getDocs(patientsQuery);

                let images = [];
                let consultationsLast7Days = 0;
                const oneWeekAgo = new Date();
                oneWeekAgo.setDate(oneWeekAgo.getDate() - 7);

                patientsSnap.forEach(doc => {
                    const pData = doc.data();
                    if (pData.consultations) {
                        pData.consultations.forEach(c => {
                            if (c.date && c.date.toDate() > oneWeekAgo) consultationsLast7Days++;
                            if (c.axonEyeImages && c.axonEyeImages.length > 0) {
                                c.axonEyeImages.forEach(img => images.push(img.link));
                            }
                        });
                    }
                });

                const dailyAvg = (consultationsLast7Days / 7).toFixed(1);

                let imagesHtml = '';
                if (images.length > 0) {
                    imagesHtml = `
                        <div class="user-detail-header" style="margin-top: 20px;">
                            <div class="user-detail-label">IMAGENS ENVIADAS Ã€ IA (HistÃ³rico)</div>
                        </div>
                        <div class="admin-user-images">
                            ${images.map(src => `<img src="${src}" class="admin-user-img" onclick="window.openFullscreenModal('${src}')">`).join('')}
                        </div>
                    `;
                } else {
                    imagesHtml = '<div class="info" style="margin-top: 15px;">Nenhuma imagem salva encontrada.</div>';
                }

                adminUserDetails.innerHTML = `
                    <div class="user-detail-header">
                        <h3 style="color: var(--prompt-color); margin-bottom: 5px;">${user.username} ${user.isBlocked ? '(BLOQUEADO)' : ''}</h3>
                        <span style="font-size: 12px; color: #888;">ID: ${user.username}</span>
                    </div>
                    
                    <div class="user-detail-row">
                        <span class="user-detail-label">SENHA</span>
                        <span class="user-detail-value" style="font-family: monospace;">${user.password || '****'}</span>
                    </div>

                    <div class="user-detail-row">
                        <span class="user-detail-label">DATA DE REGISTRO</span>
                        <span class="user-detail-value">${user.createdAt ? user.createdAt.toDate().toLocaleString() : 'Desconhecida'}</span>
                    </div>

                     <div class="user-detail-row" style="margin-top: 15px;">
                         <span class="user-detail-label">AÃ‡Ã•ES DA CONTA</span>
                         <div style="display: flex; margin-top: 5px; gap: 10px; flex-wrap: wrap;">
                             <button class="patient-action-button" style="flex: 1;" onclick="window.toggleBlockUser('${user.username}', ${!user.isBlocked})">
                                ${user.isBlocked ? '<i class="fas fa-unlock"></i> Desbloquear' : '<i class="fas fa-ban"></i> Bloquear'}
                             </button>
                             <button class="patient-action-button" style="flex: 1;" onclick="window.toggleUserCloudAccess('${user.username}', ${!user.isCloudDisabled})">
                                ${user.isCloudDisabled ? '<i class="fas fa-cloud"></i> Ativar Cloud' : '<i class="fas fa-cloud-slash"></i> Desativar Cloud'}
                             </button>
                             <button class="patient-action-button delete" style="flex: 1;" onclick="window.deleteUserFromPanel('${user.username}')">
                                <i class="fas fa-trash"></i> Excluir UsuÃ¡rio
                             </button>
                         </div>
                    </div>

                    <div class="usage-stats-box">
                        <div class="user-detail-label" style="color: var(--highlight-color);">ESTATÃSTICAS DE USO (API)</div>
                        <div style="display: flex; gap: 20px; margin-top: 5px; flex-wrap: wrap;">
                            <div>
                                <div style="font-size: 20px; font-weight: bold;">${user.textRequests || 0}</div>
                                <div style="font-size: 10px;">RequisiÃ§Ãµes de Texto</div>
                            </div>
                             <div>
                                <div style="font-size: 20px; font-weight: bold;">${user.visionRequests || 0}</div>
                                <div style="font-size: 10px;">RequisiÃ§Ãµes de VisÃ£o</div>
                            </div>
                            <div>
                                <div style="font-size: 20px; font-weight: bold;">${user.savedCount}</div>
                                <div style="font-size: 10px;">Total Pacientes Salvos</div>
                            </div>
                            <div>
                                <div style="font-size: 20px; font-weight: bold;">${consultationsLast7Days}</div>
                                <div style="font-size: 10px;">Consultas (Ãšlt. 7 dias)</div>
                            </div>
                            <div>
                                <div style="font-size: 20px; font-weight: bold;">${dailyAvg}</div>
                                <div style="font-size: 10px;">MÃ©dia DiÃ¡ria (Semana)</div>
                            </div>
                        </div>
                    </div>

                    ${imagesHtml}
                `;

            } catch (e) {
                console.error("Erro ao carregar detalhes do usuÃ¡rio:", e);
                adminUserDetails.innerHTML = `<div class="error">Erro ao carregar detalhes: ${e.message}</div>`;
            }
        };

        window.toggleBlockUser = async (username, shouldBlock) => {
            try {
                const userRef = doc(db, "users", username);
                await updateDoc(userRef, { isBlocked: shouldBlock });
                const userIdx = adminUsersData.findIndex(u => u.username === username);
                if (userIdx !== -1) {
                    adminUsersData[userIdx].isBlocked = shouldBlock;
                    renderAdminUsersList(adminUsersData);
                    window.selectAdminUser(username);
                }
            } catch (e) {
                alert(`Erro ao alterar status de bloqueio: ${e.message}`);
            }
        };

        window.deleteUserFromPanel = async (username) => {
            showConfirmModal(`Tem certeza que deseja excluir o usuÃ¡rio '${username}' permanentemente?`, async () => {
                try {
                    const userRef = doc(db, "users", username);
                    await deleteDoc(userRef);
                    adminUsersData = adminUsersData.filter(u => u.username !== username);
                    renderAdminUsersList(adminUsersData);
                    adminUserDetails.innerHTML = '<div class="info" style="margin-top: 20px;">UsuÃ¡rio excluÃ­do. Selecione outro.</div>';
                } catch (e) {
                    alert(`Erro ao excluir usuÃ¡rio: ${e.message}`);
                }
            });
        };

        const openPrescriptionHelper = async (category) => {
            prescriptionHelperTitle.textContent = `Assistente de PrescriÃ§Ã£o: ${category}`;
            prescriptionHelperBody.innerHTML = `<div class="info">Gerando sugestÃµes personalizadas para o paciente...</div>`;
            prescriptionHelperModal.style.display = 'flex';

            try {
                const templates = await generateContextualTemplates(category);

                let contentHTML = '';
                if (templates && templates.length > 0) {
                    templates.forEach((template, index) => {
                        const templateId = `template-${category.replace(/\s/g, '-')}-${index}`;
                        contentHTML += `
                            <div class="prescription-template-item">
                                <div class="prescription-template-header">
                                    <div class="prescription-template-title">${template.title}</div>
                                    <button class="prescription-template-copy-btn" data-template-id="${templateId}">
                                        <i class="fas fa-copy"></i> Copiar
                                    </button>
                                </div>
                                <div class="prescription-template-text" id="${templateId}">${template.text}</div>
                            </div>
                        `;
                    });
                } else {
                    contentHTML = `<div class="info">Nenhuma sugestÃ£o relevante encontrada para o quadro clÃ­nico atual.</div>`;
                }

                prescriptionHelperBody.innerHTML = contentHTML;

            } catch (error) {
                console.error(`Error generating contextual templates for ${category}:`, error);
                prescriptionHelperBody.innerHTML = `<div class="error">Erro ao gerar sugestÃµes: ${error.message}</div>`;
            }
        };

        const generateContextualTemplates = async (category) => {
            let instruction = '';
            let format_example = '';
            switch (category) {
                case 'CONDUTA FARMACOLÃ“GICA (SUS)':
                    instruction = "Gere atÃ© 3 prescriÃ§Ãµes de medicamentos (padrÃ£o SUS) pertinentes ao quadro clÃ­nico.";
                    format_example = `O texto ('text') de cada prescriÃ§Ã£o deve seguir EXATAMENTE este formato multi-linha:
USO ORAL:
[NOME DO MEDICAMENTO] [DOSAGEM] ---------------- [QUANTIDADE/DURAÃ‡ÃƒO]
[INSTRUÃ‡Ã•ES DE USO (ex: TOMAR 01 COMPRIMIDO AO DIA)]`;
                    break;
                case 'EXAMES COMPLEMENTARES (SUS)':
                    instruction = "Gere atÃ© 3 solicitaÃ§Ãµes de exames (padrÃ£o SUS) pertinentes, com justificativa clÃ­nica.";
                    format_example = `O texto ('text') de cada solicitaÃ§Ã£o deve seguir EXATAMENTE este formato multi-linha:
SOLICITO:
- [NOME DO EXAME 1]
- [NOME DO EXAME 2]
JUSTIFICATIVA: [Justificativa clÃ­nica concisa]`;
                    break;
                case 'CONDUTAS NÃƒO FARMACOLÃ“GICAS (SUS)':
                    instruction = "Gere atÃ© 3 condutas nÃ£o farmacolÃ³gicas pertinentes, focando em encaminhamentos para especialistas.";
                    format_example = `O texto ('text') de cada encaminhamento deve seguir EXATAMENTE este formato multi-linha:
Ã€ [ESPECIALIDADE]:
ENCAMINHO O PACIENTE [NOME DO PACIENTE AQUI], COM [DIAGNÃ“STICO/SINTOMAS PRINCIPAIS].
GRATO.`;
                    break;
                case 'RECOMENDAÃ‡Ã•ES':
                    instruction = "Gere atÃ© 3 recomendaÃ§Ãµes ou atestados pertinentes para a situaÃ§Ã£o do paciente.";
                    format_example = `O texto ('text') deve ser claro, objetivo e pronto para uso, como um atestado ou uma recomendaÃ§Ã£o formal.`;
                    break;
                default:
                    return [];
            }

            const prompt = `VocÃª Ã© um assistente mÃ©dico especialista em gerar documentos clÃ­nicos. Com base no quadro clÃ­nico do paciente, siga a instruÃ§Ã£o fornecida.

**Quadro ClÃ­nico do Paciente:**
- Anamnese: ${JSON.stringify(anamnesis)}
- Resultados de Exames PrÃ©vios: ${examsResults || "Nenhum"}
- AnÃ¡lise Visual (Axon Eye): ${axonEyeResults || "Nenhum"}

**InstruÃ§Ã£o EspecÃ­fica:**
${instruction}

**Regras de FormataÃ§Ã£o (ObrigatÃ³rio):**
1. Crie solicitaÃ§Ãµes que faÃ§am sentido clÃ­nico com o quadro apresentado.
2. Formate a resposta como um array JSON de objetos. Cada objeto deve ter as chaves 'title' e 'text'.
3. O 'title' deve ser um resumo curto da sugestÃ£o (ex: "Metformina para DM2", "Encaminhamento Ã  Cardiologia").
4. ${format_example}
5. Se nenhuma sugestÃ£o for clinicamente justificÃ¡vel, retorne um array JSON vazio: [].

**Retorne APENAS o array JSON, sem nenhum texto ou formataÃ§Ã£o adicional.**`;

            try {
                const response = await callGeminiAPI(prompt);
                const jsonStart = response.indexOf('[');
                const jsonEnd = response.lastIndexOf(']') + 1;
                if (jsonStart === -1 || jsonEnd === 0) {
                    console.error("No JSON array found in response:", response);
                    return [];
                }
                const jsonString = response.substring(jsonStart, jsonEnd);
                return JSON.parse(jsonString);
            } catch (error) {
                console.error("Failed to parse AI response for templates:", error);
                throw new Error("A IA retornou uma resposta em formato invÃ¡lido.");
            }
        };

        const closePrescriptionHelper = () => {
            prescriptionHelperModal.style.display = 'none';
        };

        const openChatbox = () => {
            chatboxMessages.innerHTML = '';
            // Populate with existing history
            conversationHistory.forEach(msg => {
                const textPart = msg.parts.find(p => p.text);
                const imageParts = msg.parts.filter(p => p.inlineData);
                appendChatMessage(textPart.text, msg.role, false, imageParts.map(p => `data:${p.inlineData.mimeType};base64,${p.inlineData.data}`));
            });

            if (conversationHistory.length === 0) {
                appendChatMessage(`OlÃ¡ Dr(a). ${currentUser}! Como posso te ajudar hoje?`, 'model');
            }

            chatboxModal.style.display = 'flex';
            chatboxInput.focus();
        };

        const closeChatbox = () => {
            chatboxModal.style.display = 'none';
        };

        const showConfirmModal = (message, onConfirm, isAlert = false) => {
            const modal = document.getElementById('custom-confirm-modal');
            const text = document.getElementById('confirm-modal-text');
            const btnYes = document.getElementById('confirm-btn-yes');
            const btnNo = document.getElementById('confirm-btn-no');

            text.textContent = message;

            if (isAlert) {
                btnYes.style.display = 'none';
                btnNo.textContent = 'OK';
            } else {
                btnYes.style.display = 'inline-block';
                btnNo.textContent = 'Cancelar';
            }

            modal.style.display = 'flex';

            return new Promise((resolve) => {
                btnYes.onclick = () => {
                    modal.style.display = 'none';
                    if (onConfirm) onConfirm();
                    resolve(true);
                };
                btnNo.onclick = () => {
                    modal.style.display = 'none';
                    resolve(false);
                };
            });
        };

        const appendChatMessage = (message, sender, isTyping = false, images = []) => {
            const messageWrapper = document.createElement('div');
            messageWrapper.className = `chat-message ${sender}`;

            const avatar = document.createElement('div');
            avatar.className = 'chat-avatar';
            avatar.innerHTML = sender === 'user' ? '<i class="fas fa-user-circle"></i>' : '<i class="fas fa-robot"></i>';

            const bubble = document.createElement('div');
            bubble.className = 'message-bubble';

            if (isTyping) {
                bubble.classList.add('typing');
                bubble.innerHTML = '<span class="dot"></span><span class="dot"></span><span class="dot"></span>';
            } else {
                let contentHTML = message.replace(/\*(.*?)\*/g, '<b>$1</b>');
                if (images.length > 0) {
                    images.forEach(imgSrc => {
                        contentHTML += `<img src="${imgSrc}" class="chat-image-attachment" onclick="window.openFullscreenModal('${imgSrc}')">`;
                    });
                }
                bubble.innerHTML = contentHTML;
            }

            messageWrapper.appendChild(avatar);
            messageWrapper.appendChild(bubble);
            chatboxMessages.appendChild(messageWrapper);
            chatboxMessages.scrollTop = chatboxMessages.scrollHeight;

            return bubble;
        };

        const handleChatImageUpload = (event) => {
            chatImagePreviews.innerHTML = '';
            chatImagesToSend = [];
            const files = Array.from(event.target.files);

            files.forEach((file, index) => {
                if (file.type.startsWith('image/')) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        const imageDataURL = e.target.result;
                        chatImagesToSend.push(imageDataURL);

                        const previewItem = document.createElement('div');
                        previewItem.className = 'chat-preview-item';
                        previewItem.innerHTML = `
                            <img src="${imageDataURL}" alt="Preview">
                            <button class="chat-preview-delete" onclick="window.removeChatPreviewImage(${index})">&times;</button>
                        `;
                        chatImagePreviews.appendChild(previewItem);
                    };
                    reader.readAsDataURL(file);
                }
            });
            event.target.value = ''; // Reset input
        };

        window.removeChatPreviewImage = (indexToRemove) => {
            chatImagesToSend.splice(indexToRemove, 1);
            chatImagePreviews.innerHTML = ''; // Re-render
            chatImagesToSend.forEach((imageDataURL, index) => {
                const previewItem = document.createElement('div');
                previewItem.className = 'chat-preview-item';
                previewItem.innerHTML = `
                    <img src="${imageDataURL}" alt="Preview">
                    <button class="chat-preview-delete" onclick="window.removeChatPreviewImage(${index})">&times;</button>
                `;
                chatImagePreviews.appendChild(previewItem);
            });
        };

        const sendChatMessage = async () => {
            const question = chatboxInput.value.trim();
            if (!question && chatImagesToSend.length === 0) return;

            appendChatMessage(question, 'user', false, chatImagesToSend);
            chatboxInput.value = '';
            chatboxInput.disabled = true;
            chatboxSendBtn.disabled = true;
            chatboxUploadBtn.disabled = true;
            chatImagePreviews.innerHTML = '';

            const images = [...chatImagesToSend];
            chatImagesToSend = [];

            const typingBubble = appendChatMessage('', 'model', true);

            try {
                let response;
                if (images.length > 0) {
                    response = await askVisionQuestionBasedOnContext(question || "Analise esta(s) imagem(ns).", images);
                } else {
                    response = await askQuestionBasedOnContext(question);
                }

                const formattedResponse = response.replace(/\*(.*?)\*/g, '<b>$1</b>');

                typingBubble.innerHTML = formattedResponse;
                typingBubble.classList.remove('typing');

            } catch (error) {
                typingBubble.innerHTML = `Desculpe, ocorreu um erro: ${error.message}`;
                typingBubble.style.color = 'var(--error-color)';
                typingBubble.classList.remove('typing');
            } finally {
                chatboxInput.disabled = false;
                chatboxSendBtn.disabled = false;
                chatboxUploadBtn.disabled = false;
                chatboxInput.focus();
            }
        };

        adminUserSearch.addEventListener('input', (e) => {
            const term = e.target.value.toLowerCase();
            const filtered = adminUsersData.filter(u => u.username.toLowerCase().includes(term));
            renderAdminUsersList(filtered);
        });

        adminPanelClose.addEventListener('click', () => adminPanelModal.style.display = 'none');

        adminTabButtons.forEach(btn => {
            btn.addEventListener('click', (e) => {
                const tabName = e.currentTarget.dataset.tab;
                activateAdminTab(tabName);
            });
        });

        const activateAdminTab = (tabName) => {
            document.querySelectorAll('.admin-tab-content').forEach(c => c.style.display = 'none');
            document.querySelectorAll('.admin-tab-btn').forEach(b => b.classList.remove('active'));

            document.getElementById(`tab-${tabName}`).style.display = 'block';
            document.querySelector(`.admin-tab-btn[data-tab="${tabName}"]`).classList.add('active');

            if (tabName === 'users') loadAdminUsersData();
            if (tabName === 'api') renderAdminSettingsUI();
            if (tabName === 'debug') renderAdminDebugUI();
            if (tabName === 'axon-drive') renderAdminAxonDrive();
            if (tabName === 'bridge') renderAdminBridgeUI();
        };

        const validatePinataKey = async (apiKey, apiSecret) => {
            try {
                const response = await fetch('https://api.pinata.cloud/data/testAuthentication', {
                    method: 'GET',
                    headers: {
                        'pinata_api_key': apiKey,
                        'pinata_secret_api_key': apiSecret
                    }
                });
                return response.ok;
            } catch (e) {
                console.error("Erro na validaÃ§Ã£o da chave Pinata:", e);
                return false;
            }
        };

        window.addPinataKey = async () => {
            const keyInput = document.getElementById('new-pinata-key');
            const secretInput = document.getElementById('new-pinata-secret');
            const jwtInput = document.getElementById('new-pinata-jwt');

            const key = keyInput.value.trim();
            const secret = secretInput.value.trim();
            const jwt = jwtInput.value.trim();

            if (!key || !secret) {
                showConfirmModal("Por favor, insira a API Key e a Secret Key.", null, true);
                return;
            }

            const btn = document.getElementById('btn-add-pinata-key');
            const originalText = btn.innerHTML;
            btn.textContent = "Validando...";
            btn.disabled = true;

            const isValid = await validatePinataKey(key, secret);

            if (isValid) {
                const newKeyObj = { key, secret, jwt, addedAt: new Date().toISOString() };
                const currentKeys = globalSettings.pinataKeys || [];
                const updatedKeys = [...currentKeys, newKeyObj];

                try {
                    await setDoc(doc(db, "settings", "global"), { pinataKeys: updatedKeys }, { merge: true });
                    keyInput.value = '';
                    secretInput.value = '';
                    jwtInput.value = '';
                    showConfirmModal("Chave adicionada com sucesso! (+1GB)", null, true);
                    renderAdminAxonDrive();
                } catch (e) {
                    showConfirmModal("Erro ao salvar chave: " + e.message, null, true);
                }
            } else {
                showConfirmModal("Chave invÃ¡lida! Verifique suas credenciais no Pinata.", null, true);
            }

            btn.innerHTML = originalText;
            btn.disabled = false;
        };

        window.adminRenameFile = async (id, pathRef, currentName) => {
            const modal = document.getElementById('custom-input-modal');
            const titleEl = document.getElementById('custom-input-title');
            const inputEl = document.getElementById('custom-input-field');
            const confirmBtn = document.getElementById('custom-input-confirm');
            const cancelBtn = document.getElementById('custom-input-cancel');

            titleEl.textContent = "Renomear Arquivo";
            inputEl.value = currentName;
            modal.style.display = 'flex';
            inputEl.focus();

            confirmBtn.onclick = async () => {
                const newName = inputEl.value.trim();
                if (newName && newName !== currentName) {
                    try {
                        const parts = pathRef.split('/');
                        // Ensure minimal path length (collection/doc)
                        if (parts.length >= 2) {
                            const docRef = doc(db, ...parts);
                            await updateDoc(docRef, { name: newName });
                            renderAdminAxonDrive();
                        }
                        modal.style.display = 'none';
                    } catch (e) {
                        alert("Erro ao renomear: " + e.message);
                    }
                } else {
                    modal.style.display = 'none';
                }
            };

            cancelBtn.onclick = () => modal.style.display = 'none';
        }

        window.adminOpenFile = async (name, mimeType, ipfsHash, pathRef) => {
            const previewModal = document.getElementById('file-preview-modal');
            const previewContent = document.getElementById('preview-content');
            const previewTitle = document.getElementById('preview-title');
            const downloadBtn = document.getElementById('preview-download-btn');

            previewContent.innerHTML = '';
            previewTitle.textContent = name;
            const fileUrl = `https://gateway.pinata.cloud/ipfs/${ipfsHash}`;

            // Fix: Override default link behavior to force download via blob
            downloadBtn.onclick = async (e) => {
                e.preventDefault();
                downloadBtn.innerHTML = "Baixando...";
                try {
                    const response = await fetch(fileUrl);
                    if (!response.ok) throw new Error("Erro na rede");
                    const blob = await response.blob();
                    const downloadUrl = window.URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = downloadUrl;
                    a.download = name;
                    document.body.appendChild(a);
                    a.click();
                    a.remove();
                    window.URL.revokeObjectURL(downloadUrl);
                    downloadBtn.innerHTML = '<i class="fas fa-download"></i> Baixar';
                } catch (err) {
                    alert("Erro no download: " + err.message);
                    downloadBtn.innerHTML = '<i class="fas fa-download"></i> Baixar';
                }
            };
            // Keep href for right-click 'Save As' fallback
            downloadBtn.href = fileUrl;
            downloadBtn.download = name;

            if (mimeType && mimeType.startsWith('image/')) {
                const img = document.createElement('img');
                img.src = fileUrl;
                previewContent.appendChild(img);
                previewModal.style.display = 'flex';
            } else if (mimeType && mimeType.startsWith('video/')) {
                const video = document.createElement('video');
                video.src = fileUrl;
                video.controls = true;
                previewContent.appendChild(video);
                previewModal.style.display = 'flex';
            } else if (mimeType && mimeType.includes('pdf')) {
                const iframe = document.createElement('iframe');
                iframe.src = fileUrl;
                previewContent.appendChild(iframe);
                previewModal.style.display = 'flex';
            } else if (name.endsWith('.txt') || (mimeType && mimeType.includes('text'))) {
                const modal = document.getElementById('text-editor-modal');
                const textarea = document.getElementById('text-editor-textarea');
                const title = document.getElementById('text-editor-title');
                const saveBtn = document.getElementById('text-editor-save');
                const closeBtn = document.getElementById('text-editor-close');
                const status = document.getElementById('text-editor-status');

                title.textContent = `Editando (Admin): ${name}`;
                textarea.value = "Carregando...";
                status.textContent = "";

                modal.style.display = 'flex';

                try {
                    const response = await fetch(fileUrl);
                    if (!response.ok) throw new Error("Falha ao carregar arquivo.");
                    const text = await response.text();
                    textarea.value = text;
                } catch (e) {
                    textarea.value = "";
                    status.textContent = "Erro: " + e.message;
                }

                saveBtn.onclick = async () => {
                    const newContent = textarea.value;
                    status.textContent = "Salvando...";
                    try {
                        const blob = new Blob([newContent], { type: 'text/plain' });
                        const file = new File([blob], name, { type: 'text/plain' });
                        const uploadResult = await uploadToPinata(file);

                        const parts = pathRef.split('/');
                        if (parts.length >= 2) {
                            const docRef = doc(db, ...parts);
                            await updateDoc(docRef, {
                                ipfsHash: uploadResult.ipfsHash,
                                pinataKey: uploadResult.pinataKey,
                                size: file.size,
                                lastModified: new Date()
                            });

                            status.textContent = "Salvo com sucesso!";
                            status.style.color = "var(--success-color)";
                            setTimeout(() => {
                                status.textContent = "";
                                renderAdminAxonDrive();
                            }, 2000);
                        }
                    } catch (e) {
                        status.textContent = "Erro ao salvar: " + e.message;
                        status.style.color = "var(--error-color)";
                    }
                };
                closeBtn.onclick = () => modal.style.display = 'none';

            } else {
                window.open(fileUrl, '_blank');
            }
        };

        window.renderAdminBridgeUI = () => {
            const bridgeBody = document.getElementById('admin-bridge-body');
            if (!bridgeBody) return;

            const permissions = [
                { key: 'sendToChat', label: 'Enviar para Chat (/ask)' },
                { key: 'callAI', label: 'Solicitar AnÃ¡lise de IA (Texto/VisÃ£o)' },
                { key: 'getAnamnesis', label: 'Ler Anamnese e Exames' },
                { key: 'storage', label: 'Armazenamento (Pinata/IPFS)' }
            ];

            if (!globalSettings.bridgePermissions) {
                globalSettings.bridgePermissions = {
                    sendToChat: true,
                    callAI: true,
                    getAnamnesis: true,
                    storage: true
                };
            }

            let html = '';
            permissions.forEach(p => {
                const isEnabled = globalSettings.bridgePermissions[p.key] !== false; // Default true
                html += `
                    <div style="display:flex; justify-content:space-between; align-items:center; background:var(--input-bg); padding:10px; margin-bottom:10px; border-radius:8px; border:1px solid var(--border-color);">
                        <span class="admin-bridge-label" style="font-weight:500;">${p.label} <code style="font-size:10px; opacity:0.6; margin-left:5px">${p.key}</code></span>
                        <label class="toggle-switch">
                            <input type="checkbox" ${isEnabled ? 'checked' : ''} onchange="window.toggleBridgePermission('${p.key}', this.checked)">
                            <span class="slider round"></span>
                        </label>
                    </div>
                `;
            });

            bridgeBody.innerHTML = html;
        };

        window.toggleBridgePermission = async (key, value) => {
            if (!globalSettings.bridgePermissions) globalSettings.bridgePermissions = {};
            globalSettings.bridgePermissions[key] = value;

            try {
                await setDoc(doc(db, "settings", "global"), { bridgePermissions: globalSettings.bridgePermissions }, { merge: true });
                appendOutput(`PermissÃ£o Bridge '${key}' alterada para ${value}`, "info");
            } catch (e) {
                console.error("Erro ao salvar permissÃ£o Bridge:", e);
                appendOutput("Erro ao salvar permissÃ£o.", "error");
            }
        };

        // Admin Axon Drive State
        let adminDriveCurrentView = 'users'; // 'users' or 'files'
        let adminDriveSelectedUser = null;
        let adminDriveAllFiles = []; // Cache for current render

        window.renderAdminAxonDrive = async () => {
            try {
                const settingsSnap = await getDoc(doc(db, "settings", "global"));
                if (settingsSnap.exists()) globalSettings = { ...globalSettings, ...settingsSnap.data() };
            } catch (e) { console.error("Error fetching settings:", e); }

            let totalUsed = 0;
            let totalFilesCount = 0;
            let keyCount = (globalSettings.pinataKeys && globalSettings.pinataKeys.length > 0) ? globalSettings.pinataKeys.length : 1;
            let totalLimit = keyCount * 1024 * 1024 * 1024;

            const usageText = document.getElementById('admin-pinata-usage-text');
            const usagePercent = document.getElementById('admin-pinata-usage-percent');
            const usageBar = document.getElementById('admin-pinata-usage-bar');
            const fileList = document.getElementById('admin-pinata-file-list');
            const keyList = document.getElementById('admin-pinata-key-list');

            // Add Styles for clickable folders if not present
            if (!document.getElementById('admin-drive-styles')) {
                const style = document.createElement('style');
                style.id = 'admin-drive-styles';
                style.innerHTML = `
                    .admin-drive-folder {
                        display: flex;
                        align-items: center;
                        padding: 10px;
                        border-bottom: 1px solid var(--border-color);
                        cursor: pointer;
                        transition: background-color 0.2s;
                    }
                    .admin-drive-folder:hover {
                        background-color: var(--button-hover-bg);
                    }
                    .admin-drive-file {
                        display: flex;
                        align-items: center;
                        padding: 8px;
                        border-bottom: 1px solid var(--border-color);
                        gap: 10px;
                    }
                `;
                document.head.appendChild(style);
            }

            const btnAddKey = document.getElementById('btn-add-pinata-key');
            if (btnAddKey) {
                const newBtn = btnAddKey.cloneNode(true);
                btnAddKey.parentNode.replaceChild(newBtn, btnAddKey);
                newBtn.addEventListener('click', window.addPinataKey);
                newBtn.className = "patient-action-button details";
                newBtn.style.width = "auto";
                newBtn.style.padding = "6px 12px";
                newBtn.style.color = "white"; // Force white color
                newBtn.innerHTML = '<i class="fas fa-plus"></i> Adicionar (+1GB)';
            }

            // **Global File Manager Logic**
            const allFiles = [];

            // Default keys check
            const defaultKeys = [{
                key: "5256cd6c1c0b4ccec3a9",
                secret: "afbed7932f0ebf5c50d88d04378359164aca3ae63a72e2628375dc02e4fcfb05",
                jwt: "afbed7932f0ebf5c50d88d04378359164aca3ae63a72e2628375dc02e4fcfb05",
                addedAt: new Date().toISOString()
            }];

            if ((!globalSettings.pinataKeys || globalSettings.pinataKeys.length === 0)) {
                globalSettings.pinataKeys = defaultKeys;
                setDoc(doc(db, "settings", "global"), { pinataKeys: defaultKeys }, { merge: true }).catch(console.error);
            }

            keyCount = globalSettings.pinataKeys ? globalSettings.pinataKeys.length : 1;
            totalLimit = keyCount * 1024 * 1024 * 1024;

            try {
                const filesSnapshot = await getDocs(query(collectionGroup(db, 'files')));
                filesSnapshot.forEach(doc => {
                    const data = doc.data();
                    const userId = doc.ref.parent.parent ? doc.ref.parent.parent.id : 'Desconhecido';
                    if (data.size && data.provider !== 'supabase') totalUsed += data.size;
                    allFiles.push({ ...data, id: doc.id, path: doc.ref.path, origin: 'Cloud', user: userId });
                });
                totalFilesCount = allFiles.length; // Count files

                // Fetch transfers if needed
                const transfersSnapshot = await getDocs(query(collectionGroup(db, 'transfers')));
                transfersSnapshot.forEach(doc => {
                    const data = doc.data();
                    // Just count pinata files here to avoid double counting if logic changes, but assuming transfers are separate
                    const userId = doc.ref.parent.parent ? doc.ref.parent.parent.id : 'Desconhecido';
                    if (data.size && (data.type === 'file' || data.type === 'pinata')) {
                        totalUsed += data.size;
                        totalFilesCount++;
                        allFiles.push({ ...data, id: doc.id, path: doc.ref.path, origin: 'Share', user: userId });
                    }
                });

            } catch (e) {
                fileList.innerHTML = `<div class="error">Erro ao carregar arquivos globais: ${e.message}</div>`;
                return;
            }

            adminDriveAllFiles = allFiles; // Cache

            // Re-render Progress
            const percent = totalLimit > 0 ? Math.min((totalUsed / totalLimit) * 100, 100).toFixed(1) : 0;
            const gbUsed = (totalUsed / (1024 * 1024 * 1024)).toFixed(2);
            const gbTotal = (totalLimit / (1024 * 1024 * 1024)).toFixed(0);

            // Update Status Text with File Count
            if (usageText) usageText.innerHTML = `${gbUsed} GB / ${gbTotal} GB <span style="font-size:12px; margin-left:10px; opacity:0.8;">(${totalFilesCount} arquivos)</span>`;
            if (usagePercent) usagePercent.textContent = `${percent}%`;
            if (usageBar) usageBar.style.width = `${percent}%`;


            // Render Logic depending on View
            fileList.innerHTML = '';

            if (adminDriveCurrentView === 'users') {
                // Group by User
                const userMap = {};
                allFiles.forEach(f => {
                    if (!userMap[f.user]) userMap[f.user] = { count: 0, size: 0, user: f.user };
                    userMap[f.user].count++;
                    userMap[f.user].size += (f.size || 0);
                });

                const users = Object.values(userMap).sort((a, b) => b.size - a.size);

                if (users.length === 0) {
                    fileList.innerHTML = '<div style="padding:10px;text-align:center;opacity:0.5;">Nenhum usuÃ¡rio com arquivos.</div>';
                } else {
                    users.forEach(u => {
                        const div = document.createElement('div');
                        div.className = 'admin-drive-folder';
                        div.innerHTML = `
                            <div style="width:30px; text-align:center;"><i class="fas fa-folder" style="color:#ecc94b; font-size:18px;"></i></div>
                            <div style="flex:1;">
                                <div style="font-weight:bold;">${u.user}</div>
                                <div style="font-size:11px; opacity:0.7;">${u.count} arquivos</div>
                            </div>
                            <div style="font-size:12px;">${(u.size / 1024 / 1024).toFixed(2)} MB</div>
                            <div style="margin-left:10px; opacity:0.5;"><i class="fas fa-chevron-right"></i></div>
                        `;
                        div.addEventListener('click', () => {
                            adminDriveSelectedUser = u.user;
                            adminDriveCurrentView = 'files';
                            renderAdminAxonDrive(); // Re-render
                        });
                        fileList.appendChild(div);
                    });
                }

            } else if (adminDriveCurrentView === 'files') {
                // Header with Back Button
                const header = document.createElement('div');
                header.style.cssText = "display:flex; align-items:center; padding:10px; border-bottom:1px solid var(--border-color); background:rgba(0,0,0,0.1); margin-bottom:10px;";
                header.innerHTML = `
                    <button class="patient-action-button" style="width:auto; padding:5px 10px; margin-right:10px;" id="admin-drive-back">
                        <i class="fas fa-arrow-left"></i>
                    </button>
                    <div style="font-weight:bold;">Arquivos de: ${adminDriveSelectedUser}</div>
                `;
                fileList.appendChild(header);
                // Bind click after append
                fileList.querySelector('#admin-drive-back').onclick = () => {
                    adminDriveCurrentView = 'users';
                    adminDriveSelectedUser = null;
                    renderAdminAxonDrive();
                };

                const userFiles = allFiles.filter(f => f.user === adminDriveSelectedUser).sort((a, b) => b.size - a.size);

                if (userFiles.length === 0) {
                    const empty = document.createElement('div');
                    empty.innerHTML = '<div style="padding:20px; text-align:center;">Nenhum arquivo encontrado.</div>';
                    fileList.appendChild(empty);
                } else {
                    userFiles.forEach(file => {
                        const div = document.createElement('div');
                        div.className = 'admin-drive-file'; // Use new class

                        const icon = file.type === 'folder' ? '<i class="fas fa-folder" style="color:#ecc94b"></i>' : '<i class="fas fa-file" style="color:var(--text-color)"></i>';

                        div.innerHTML = `
                            <div style="width:30px; text-align:center;">${icon}</div>
                            <div style="flex:1; overflow:hidden;">
                                <div style="font-weight:bold; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">${file.name}</div>
                                <div style="font-size:10px; opacity:0.7;">${file.origin}</div>
                            </div>
                            <div style="font-size:12px; white-space:nowrap;">${(file.size / 1024 / 1024).toFixed(2)} MB</div>
                            <div style="display:flex; gap:5px;">
                                ${file.link || file.ipfsHash ? `<button class="patient-action-button" onclick="window.adminOpenFile('${file.name}', '${file.mimeType}', '${file.ipfsHash}', '${file.path}')" title="Abrir"><i class="fas fa-eye"></i></button>` : ''}
                                <button class="patient-action-button" onclick="window.adminRenameFile('${file.id}', '${file.path}', '${file.name}')" title="Renomear"><i class="fas fa-edit"></i></button>
                                 ${file.link || file.ipfsHash ? `<button class="patient-action-button" onclick="window.adminDownloadFile('${file.name}', '${file.ipfsHash}')" title="Download"><i class="fas fa-download"></i></button>` : ''}
                                <button class="patient-action-button delete" onclick="window.adminDeleteFile('${file.id}', '${file.path}', '${file.ipfsHash}')" title="Excluir"><i class="fas fa-trash"></i></button>
                            </div>
                         `;
                        fileList.appendChild(div);
                    });
                }
            }


            if (keyList) {
                keyList.innerHTML = '';
                const keysToDisplay = globalSettings.pinataKeys || [];
                if (keysToDisplay.length === 0) {
                    keyList.innerHTML = '<div style="padding:10px;opacity:0.5;">Nenhuma chave registrada.</div>';
                } else {
                    keysToDisplay.forEach((k, index) => {
                        const kDiv = document.createElement('div');
                        kDiv.className = 'key-item';
                        kDiv.style.display = 'flex';
                        kDiv.style.alignItems = 'center';
                        kDiv.style.background = 'rgba(0,0,0,0.1)';
                        kDiv.style.padding = '10px';
                        kDiv.style.marginBottom = '5px';
                        kDiv.style.borderRadius = '8px';

                        kDiv.innerHTML = `
                            <div style="flex:1;">
                                <div style="font-weight:bold;">Chave ${index + 1}</div>
                                <div style="font-family:monospace; opacity:0.7; font-size:12px;">${k.key.substring(0, 8)}...${k.key.substring(k.key.length - 4)}</div>
                            </div>
                            <button class="patient-action-button delete" onclick="window.removePinataKey(${index})">Remover</button>
                         `;
                        keyList.appendChild(kDiv);
                    });
                }
            }
            // Supabase Logic
            const sbToggle = document.getElementById('admin-supabase-toggle');
            const sbUrl = document.getElementById('admin-supabase-url');
            const sbKey = document.getElementById('admin-supabase-key');
            const sbBucket = document.getElementById('admin-supabase-bucket');
            const sbFileList = document.getElementById('admin-supabase-file-list');
            const sbUsageText = document.getElementById('admin-supabase-usage-text');
            const sbUsageBar = document.getElementById('admin-supabase-usage-bar');
            const sbUsagePercent = document.getElementById('admin-supabase-usage-percent');

            if (sbToggle) sbToggle.checked = globalSettings.supabaseEnabled || false;
            if (sbUrl) sbUrl.value = globalSettings.supabaseUrl || '';
            if (sbKey) sbKey.value = globalSettings.supabaseKey || '';
            if (sbBucket) sbBucket.value = globalSettings.supabaseBucket || 'axon-drive';

            // Supabase Files
            const sbFiles = allFiles.filter(f => f.provider === 'supabase');
            const sbTotalSize = sbFiles.reduce((acc, f) => acc + (f.size || 0), 0);

            // Mock limit or just show usage
            const sbLimit = 500 * 1024 * 1024; // 500MB Free Tier Estimate
            const sbPercent = sbLimit > 0 ? Math.min((sbTotalSize / sbLimit) * 100, 100).toFixed(1) : 0;

            if (sbUsageText) sbUsageText.innerHTML = `${(sbTotalSize / 1024 / 1024).toFixed(2)} MB / 500 MB <span style="font-size:10px; opacity:0.6;">(Est. Free Tier)</span>`;
            if (sbUsagePercent) sbUsagePercent.textContent = `${sbPercent}%`;
            if (sbUsageBar) sbUsageBar.style.width = `${sbPercent}%`;

            if (sbFileList) {
                sbFileList.innerHTML = '';
                if (sbFiles.length === 0) {
                    sbFileList.innerHTML = '<div style="padding:10px;text-align:center;opacity:0.5;">Nenhum arquivo no Supabase.</div>';
                } else {
                    // Group by User
                    const sbUserMap = {};
                    sbFiles.forEach(f => {
                        if (!sbUserMap[f.user]) sbUserMap[f.user] = [];
                        sbUserMap[f.user].push(f);
                    });

                    Object.keys(sbUserMap).sort().forEach(user => {
                        const uDiv = document.createElement('div');
                        uDiv.style.cssText = "background:rgba(255,255,255,0.05); padding:8px 10px; margin-top:10px; border-radius:4px; font-weight:bold; font-size:12px; color:#3ecf8e; display:flex; align-items:center; gap:5px;";
                        uDiv.innerHTML = `<i class="fas fa-user-circle"></i> ${user}`;
                        sbFileList.appendChild(uDiv);

                        sbUserMap[user].forEach(file => {
                            const div = document.createElement('div');
                            div.className = 'admin-drive-file';
                            div.style.marginLeft = '10px';
                            div.style.borderLeft = '2px solid rgba(62, 207, 142, 0.3)';
                            div.innerHTML = `
                                 <div style="width:30px; text-align:center;"><i class="fas fa-file" style="color:var(--text-color)"></i></div>
                                 <div style="flex:1; overflow:hidden;">
                                     <div style="font-weight:bold; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">${file.name}</div>
                                     <div style="font-size:10px; opacity:0.7;">${new Date(file.createdAt.seconds * 1000).toLocaleDateString()}</div>
                                 </div>
                                 <div style="font-size:12px; margin-right:10px;">${(file.size / 1024 / 1024).toFixed(2)} MB</div>
                                 <div style="display:flex; gap:5px;">
                                     <button class="patient-action-button" onclick="window.open('${file.url}', '_blank')" title="Abrir"><i class="fas fa-eye"></i></button>
                                      <button class="patient-action-button delete" onclick="window.adminDeleteFile('${file.id}', '${file.path}', null, '${file.provider}', '${file.supabasePath}')" title="Excluir"><i class="fas fa-trash"></i></button>
                                 </div>
                            `;
                            sbFileList.appendChild(div);
                        });
                    });
                }
            }
        };

        window.toggleSupabase = async (value) => {
            globalSettings.supabaseEnabled = value;
            try {
                await setDoc(doc(db, "settings", "global"), { supabaseEnabled: value }, { merge: true });
                appendOutput(`IntegraÃ§Ã£o Supabase ${value ? 'ativada' : 'desativada'}.`, "success");
            } catch (e) {
                appendOutput("Erro ao salvar configuraÃ§Ã£o.", "error");
            }
        };

        window.saveSupabaseConfig = async () => {
            const url = document.getElementById('admin-supabase-url').value;
            const key = document.getElementById('admin-supabase-key').value;
            const bucket = document.getElementById('admin-supabase-bucket').value || 'axon-drive';

            if (!url || !key) {
                alert("Por favor, preencha URL e Chave.");
                return;
            }

            // Validate
            appendOutput("Validando credenciais do Supabase...", "info");
            try {
                // Try listing buckets to validate Key
                const testUrl = `${url}/storage/v1/bucket`;
                const response = await fetch(testUrl, {
                    method: 'GET',
                    headers: { 'Authorization': `Bearer ${key}`, 'apikey': key }
                });

                if (!response.ok) {
                    const err = await response.text();
                    alert(`Credenciais InvÃ¡lidas! Erro: ${response.status} - ${response.statusText}`);
                    appendOutput(`Erro de validaÃ§Ã£o Supabase: ${err}`, "error");
                    return;
                }

                // Success
                globalSettings.supabaseUrl = url;
                globalSettings.supabaseKey = key;
                globalSettings.supabaseBucket = bucket;

                await setDoc(doc(db, "settings", "global"), {
                    supabaseUrl: url,
                    supabaseKey: key,
                    supabaseBucket: bucket
                }, { merge: true });
                appendOutput("Credenciais Supabase validadas e salvas com sucesso!", "success");
                alert("Sucesso! Credenciais do Supabase validadas e salvas.");
                renderAdminAxonDrive();
            } catch (e) {
                appendOutput(`Erro ao validar/salvar: ${e.message}`, "error");
                alert("Erro ao conectar com Supabase. Verifique a URL.");
            }
        };

        window.adminDownloadFile = async (name, ipfsHash) => {
            try {
                const url = `https://gateway.pinata.cloud/ipfs/${ipfsHash}`;
                const response = await fetch(url);
                if (!response.ok) throw new Error("Erro na rede ao tentar baixar.");
                const blob = await response.blob();
                const downloadUrl = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = downloadUrl;
                a.download = name;
                document.body.appendChild(a);
                a.click();
                a.remove();
                window.URL.revokeObjectURL(downloadUrl);
            } catch (e) {
                alert("Erro ao iniciar download: " + e.message);
            }
        };

        window.adminDeleteFile = async (id, pathRef, ipfsHash, provider, supabasePath) => {
            showConfirmModal("Apagar arquivo permanentemente?", async () => {
                try {
                    // Update specific list based on provider or just re-render
                    // Ideally check tab? But re-render handles it.

                    if (provider === 'supabase' && supabasePath) {
                        await deleteFromSupabase(supabasePath);
                    } else if (ipfsHash) {
                        await unpinFromPinata(ipfsHash);
                    }

                    const parts = pathRef.split('/');
                    if (parts.length >= 2) {
                        const docRef = doc(db, ...parts);
                        await deleteDoc(docRef);
                    }

                    renderAdminAxonDrive();
                } catch (e) {
                    alert("Erro ao deletar: " + e.message);
                    renderAdminAxonDrive();
                }
            });
        };


        window.removePinataKey = async (index) => {
            showConfirmModal("Remover esta chave API? O armazenamento total serÃ¡ reduzido.", async () => {
                const keys = [...(globalSettings.pinataKeys || [])];
                keys.splice(index, 1);
                await setDoc(doc(db, "settings", "global"), { pinataKeys: keys }, { merge: true });
                renderAdminAxonDrive();
            });
        };

        // Fix Terminal Input
        const fixTerminalInput = () => {
            const input = document.getElementById('command-input');
            if (input) {
                input.disabled = false;
                input.focus();
                // Ensure z-index is correct if it was hidden
                input.style.zIndex = '10';
                input.style.position = 'relative';
            }
        };
        // Call it occasionally or on click
        document.addEventListener('click', (e) => {
            if (e.target.closest('.terminal')) fixTerminalInput();
        });
        // Also call on init
        setTimeout(fixTerminalInput, 1000);

        const processCommand = async (command) => {
            if (isUserBlocked) {
                appendOutput("Sua conta foi bloqueada! Funcionalidade indisponÃ­vel.", "highlight");
                commandInput.value = '';
                return;
            }

            const parts = command.trim().split(' ');
            const mainCmd = parts[0].toLowerCase();
            const isCommand = mainCmd.startsWith('/');

            if (!isLoggedIn) {
                appendOutput("Por favor, faÃ§a o login para continuar.", "error");
                commandInput.value = '';
                return;
            }

            if (!isCommand) {
                await processAnamnesisInfo(command);
                commandInput.value = '';
                return;
            }

            if (!validCommands.some(vc => mainCmd === vc.split(' ')[0])) {
                appendOutput(`Comando '${mainCmd}' nÃ£o existe. Digite /help para ver os comandos disponÃ­veis.`, "error");
                commandInput.value = '';
                return;
            }

            switch (mainCmd) {
                case '/exit': logoutUser(); break;
                case '/clear':
                    await performSessionClear();

                    break;
                case '/hear':
                    if (parts[1] === 'on') toggleListening();
                    else if (parts[1] === 'off') stopListening();
                    else appendOutput("Uso: /hear on|off", "error");
                    break;
                case '/hd':
                    appendOutput("Gerando hipÃ³teses diagnÃ³sticas...", "info");
                    await generateDiagnosticHypotheses();
                    break;
                case '/cd':
                    appendOutput("Gerando conduta mÃ©dica...", "info");
                    await generateMedicalConduct();
                    break;
                case '/copy': copyMonitorContent(); break;
                case '/ia':
                    const questionIA = command.substring(3).trim();
                    if (!questionIA) { appendOutput("Uso: /ia [pergunta]", "error"); break; }
                    appendOutput("Processando sua pergunta...", "info");
                    try {
                        const response = await callGeminiAPI(`Responda de forma objetiva Ã  pergunta mÃ©dica: "${questionIA}"`);
                        appendOutput(response.replace(/\*(.*?)\*/g, '<b>$1</b>'), "output");
                    } catch (error) { appendOutput(`Erro ao consultar a IA: ${error.message}`, "error"); }
                    break;
                case '/ask':
                    const questionAsk = command.substring(4).trim();
                    if (!questionAsk) { appendOutput("Uso: /ask [pergunta contextual]", "error"); break; }
                    appendOutput("Processando pergunta contextual...", "info");
                    try {
                        const response = await askQuestionBasedOnContext(questionAsk);
                        const formattedResponse = response.replace(/\*(.*?)\*/g, '<b>$1</b>');
                        appendOutput(`Pergunta: ${questionAsk}<br>Resposta: ${formattedResponse}`, "output");
                    } catch (error) {
                        appendOutput(`Erro ao processar pergunta: ${error.message}`, "error");
                    }
                    break;
                case '/api-set': openAdminAuth(); break;
                case '/api':
                    const currentText = globalSettings.mode === 'manual' ? (globalSettings.manualTextModel || 'NÃ£o definido') : currentAIModel;
                    const currentVision = globalSettings.mode === 'manual' ? (globalSettings.manualVisionModel || 'NÃ£o definido') : currentVisionAIModel;
                    const modeLabel = globalSettings.mode === 'manual' ? 'Manual (Fixo)' : 'AutomÃ¡tico (RotaÃ§Ã£o)';
                    appendOutput(`Status da API: ${apiConnectionStatus}\nModo: ${modeLabel}\nMotor de Texto Atual: ${currentText}\nMotor de VisÃ£o Atual: ${currentVision}`, "info");
                    break;
                case '/register':
                    const [, adminPassReg, newUser, newPass] = parts;
                    await registerUser(adminPassReg, newUser, newPass);
                    break;
                case '/delete':
                    const [, adminPassDel, userToDel] = parts;
                    await deleteUser(adminPassDel, userToDel);
                    break;
                case '/users':
                    if (parts[1] === 'admin123') {
                        adminPanelModal.style.display = 'flex';
                        activateAdminTab('users');
                    } else { appendOutput("Senha de administrador incorreta.", "error"); }
                    break;
                case '/help': appendOutput(`Comandos: ${validCommands.join(', ')}`, "info"); break;
                case '/exames': await startCamera('exams'); break;
                case '/see': await startCamera('axon-eye'); break;
                case '/load': await loadPatientList(); break;
                case '/pdf':
                    const patientName = command.substring(4).trim();
                    generatePDFFromCurrentSession(patientName);
                    break;
                default: appendOutput(`Comando '${mainCmd}' nÃ£o reconhecido.`, "error");
            }
            commandInput.value = '';
        };

        commandInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') processCommand(commandInput.value); });
        monitorCopyBtn.addEventListener('click', copyMonitorContent);
        logoutButton.addEventListener('click', logoutUser);
        settingsButton.addEventListener('click', openAdminAuth);
        themeToggleButton.addEventListener('click', toggleTheme);
        disconnectAllUsersBtn.addEventListener('click', disconnectAllUsers);

        captureButton.addEventListener('click', capturePhoto);
        uploadButton.addEventListener('click', () => fileInput.click());
        fileInput.addEventListener('change', handleFileUpload);
        sendExamsButton.addEventListener('click', analyzeExams);
        sendAxonEyeButton.addEventListener('click', analyzeAxonEye);
        cancelCameraButton.addEventListener('click', cancelCamera);
        cameraSwitchButton.addEventListener('click', switchCamera);
        flashlightButton.addEventListener('click', toggleFlashlight);
        cameraCloseBtn.addEventListener('click', cancelCamera);
        toggleAnamnesisButton.addEventListener('click', () => toggleMonitorView('anamnesis'));
        toggleExamsButton.addEventListener('click', () => toggleMonitorView('exams'));
        toggleAxonEyeButton.addEventListener('click', () => toggleMonitorView('axon-eye'));
        albumButton.addEventListener('click', openAlbumModal);
        albumModalClose.addEventListener('click', closeAlbumModal);
        albumModal.addEventListener('click', (e) => { if (e.target === albumModal) closeAlbumModal(); });

        const checkBlockedAndExecute = (callback) => {
            if (isUserBlocked) {
                if (isMobile && globalSettings.mobile2_0_enabled) {
                    showConfirmModal("Sua conta do usuÃ¡rio foi bloqueada.", () => { }, true);
                } else {
                    appendOutput("Sua conta foi bloqueada! Funcionalidade indisponÃ­vel.", "highlight");
                }
            } else {
                callback();
            }
        }

        btnExames.addEventListener('click', () => checkBlockedAndExecute(() => processCommand('/exames')));
        btnSee.addEventListener('click', () => checkBlockedAndExecute(() => processCommand('/see')));
        btnHd.addEventListener('click', () => checkBlockedAndExecute(() => processCommand('/hd')));
        btnCd.addEventListener('click', () => checkBlockedAndExecute(() => processCommand('/cd')));

        // Prescription Assistant Logic
        const btnPrescAssist = document.getElementById('btn-prescription-assist');
        const prescModal = document.getElementById('prescription-modal');
        const btnGeneratePresc = document.getElementById('btn-generate-prescription');
        // btn-show-med-info removed
        const medInfoModal = document.getElementById('med-info-modal');

        if (btnPrescAssist && prescModal) {
            btnPrescAssist.addEventListener('click', (e) => {
                e.stopPropagation();
                prescModal.style.display = 'flex';
            });
        }

        if (btnGeneratePresc) {
            btnGeneratePresc.addEventListener('click', async () => {
                const query = document.getElementById('presc-input').value;
                const age = document.getElementById('presc-age').value;
                const weight = document.getElementById('presc-weight').value;
                const source = document.querySelector('input[name="presc-source"]:checked').value;

                if (!query) {
                    alert("Por favor, digite a doenÃ§a ou medicaÃ§Ã£o.");
                    return;
                }

                const resultArea = document.getElementById('presc-result-area');
                const output = document.getElementById('presc-text-output'); // Not used directly now, we render list

                resultArea.style.display = 'block';
                // Clear previous
                const resultContainer = document.getElementById('presc-list-container');
                resultContainer.innerHTML = '<div style="text-align:center; padding: 20px;">Gerando prescriÃ§Ãµes... <i class="fas fa-spinner fa-spin"></i></div>';

                // Construct Prompt
                const prompt = `Atue como um Assistente de PrescriÃ§Ã£o MÃ©dica SÃªnior.
                O mÃ©dico solicitou assistÃªncia para: "${query}".
                
                Dados do Paciente:
                - Idade: ${age || 'NÃ£o informado'}
                - Peso: ${weight || 'NÃ£o informado'}
                
                PreferÃªncia: ${source === 'sus' ? 'Priorizar SUS' : 'Todas as opÃ§Ãµes'}.
                
                TAREFA CRÃTICA:
                   1. Gere 2 ou 3 opÃ§Ãµes de receita mÃ©dica para este caso.
                2. O texto da receita DEVE ser TOTALMENTE EM CAIXA ALTA (UPPERCASE).
                3. TODA RECEITA DEVE INICIAR ESTRITAMENTE COM A VIA DE ADMINISTRAÃ‡ÃƒO (EX: "USO ORAL:", "USO TÃ“PICO:", "USO OFTÃLMICO:", ETC).
                4. O formato de cada receita deve ser:
                   VIA DE ADMINISTRAÃ‡ÃƒO
                   NOME MEDICAMENTO + CONCENTRAÃ‡ÃƒO + APRESENTAÃ‡ÃƒO ---------------- USO (CONTÃNUO OU QUANTIDADE TOTAL)
                   POSOLOGIA (COMO TOMAR).

                   IMPORTANTE: SE O USO FOR TEMPORÃRIO, SUBSTITUA "USO TEMPORÃRIO" PELA QUANTIDADE TOTAL (EX: "01 FRASCO", "30 COMPRIMIDOS", "01 CAIXA"). SE FOR CONTÃNUO, MANTENHA "USO CONTÃNUO".
                   
                   Exemplo 1 (ContÃ­nuo):
                   USO ORAL:
                   LOSARTANA 50 MG COMPRIMIDO ---------------------------- USO CONTÃNUO
                   TOMAR 01 COMPRIMIDO PELA MANHÃƒ.

                   Exemplo 2 (TemporÃ¡rio):
                   USO ORAL:
                   AMOXICILINA 500 MG CÃPSULA ---------------------------- 21 CÃPSULAS
                   TOMAR 01 CÃPSULA DE 8 EM 8 HORAS POR 7 DIAS.
                   
                5. ForneÃ§a alertas separados.

                FORMATO DE RESPOSTA JSON RETORNE APENAS O JSON:
                {
                    "prescriptions": [
                        "TEXTO DA RECEITA 1...",
                        "TEXTO DA RECEITA 2..."
                    ],
                    "info": "<h1>InformaÃ§Ãµes</h1>..."
                }
                `;

                try {
                    let responseText = "";
                    if (typeof callGeminiAPI === 'function') {
                        responseText = await callGeminiAPI(prompt, null, true);
                    } else {
                        responseText = await callGeminiAPI(prompt + "\n\nResponda estritamente em JSON.");
                    }

                    // Parse JSON
                    let data = { prescriptions: [], info: "Sem info." };
                    try {
                        const jsonMatch = responseText.match(/\{[\s\S]*\}/);
                        if (jsonMatch) {
                            data = JSON.parse(jsonMatch[0]);
                        } else {
                            // Fallback if structured failed
                            data = { prescriptions: [responseText], info: "Verifique o texto." };
                        }
                    } catch (e) {
                        data = { prescriptions: ["Erro na geraÃ§Ã£o."], info: "Falha no parse." };
                    }

                    // Render List
                    resultContainer.innerHTML = '';

                    if (data.prescriptions && Array.isArray(data.prescriptions)) {
                        data.prescriptions.forEach((text, idx) => {
                            const card = document.createElement('div');
                            card.className = 'prescription-suggestion-card';
                            card.innerHTML = `
                                <button class="suggestion-copy-btn" onclick="window.copyToClipboard(this)">Copiar</button>
                                <div class="prescription-suggestion-text">${text}</div>
                            `;
                            resultContainer.appendChild(card);
                        });
                    } else if (data.prescription) { // Legacy single
                        const card = document.createElement('div');
                        card.className = 'prescription-suggestion-card';
                        card.innerHTML = `
                                <button class="suggestion-copy-btn" onclick="window.copyToClipboard(this)">Copiar</button>
                                <div class="prescription-suggestion-text">${data.prescription}</div>
                            `;
                        resultContainer.appendChild(card);
                    }

                    // Setup info button
                    window.currentMedInfo = data.info;

                } catch (e) {
                    resultContainer.innerHTML = `<div style="color:red">Erro: ${e.message}</div>`;
                }
            });
        }

        window.copyToClipboard = (btn) => {
            const text = btn.nextElementSibling.innerText;
            navigator.clipboard.writeText(text).then(() => {
                const original = btn.textContent;
                btn.textContent = "Copiado!";
                setTimeout(() => btn.textContent = original, 2000);
            });
        }

        btnRecords.addEventListener('click', () => checkBlockedAndExecute(() => processCommand('/load')));
        btnClear.addEventListener('click', () => checkBlockedAndExecute(() => resetSession()));
        btnMic.addEventListener('click', () => checkBlockedAndExecute(() => processCommand(isListening ? '/hear off' : '/hear on')));
        btnSaveFromList.addEventListener('click', () => {
            if (isUserBlocked) {
                appendOutput("Sua conta foi bloqueada! Funcionalidade indisponÃ­vel.", "highlight");
                patientListModal.style.display = 'none';
                return;
            }
            patientListModal.style.display = 'none';
            openSaveModal();
        });

        // Transfer Logic
        const CHUNK_SIZE = 900 * 1024; // 900KB safe limit for Firestore

        const uploadFileP2P = async (file) => {
            if (!isLoggedIn) {
                transferStatus.textContent = "Erro: UsuÃ¡rio nÃ£o logado.";
                transferStatus.style.color = "var(--error-color)";
                return;
            }

            // Reset UI
            transferStatus.style.color = "var(--text-color)";
            transferProgressBar.style.display = 'block';
            transferProgressFill.style.width = '0%';
            transferProgressFill.classList.remove('pro-mode');

            // 10MB Limit for Pinata
            const isLargeFile = file.size > 10 * 1024 * 1024;

            if (isLargeFile) {
                transferStatus.textContent = "Modo Axon Share Pro ativado (Pinata)...";
                transferProgressFill.classList.add('pro-mode');

                // Show pro mode text below bar
                const proText = document.createElement('div');
                proText.id = 'pro-mode-text';
                proText.innerText = "Modo de compartilhamento Axon Share Pro ativado.";
                proText.style.fontSize = "10px";
                proText.style.color = "#4299e1";
                proText.style.marginTop = "5px";
                proText.style.textAlign = "center";

                if (!document.getElementById('pro-mode-text')) {
                    transferProgressBar.parentNode.appendChild(proText);
                }

                try {
                    const uploadResult = await uploadToPinata(file, (progress) => {
                        transferProgressFill.style.width = `${progress}%`;
                    });
                    const ipfsHash = uploadResult.ipfsHash;

                    // Create record in Firestore to signal receiver
                    await addDoc(collection(db, "sessions", currentUser, "transfers"), {
                        filename: file.name,
                        fileSize: file.size,
                        senderId: deviceId,
                        status: "complete", // Ready for download
                        type: 'pinata',
                        ipfsHash: ipfsHash,
                        pinataKey: uploadResult.pinataKey, // Save key metadata
                        timestamp: new Date()
                    });

                    transferStatus.textContent = "Arquivo enviado com sucesso!";
                    transferStatus.style.color = "var(--success-color)";

                } catch (err) {
                    console.error("Pinata Upload Error:", err);
                    transferStatus.textContent = "Erro Axon Share Pro: " + err.message;
                    transferStatus.style.color = "var(--error-color)";
                }

            } else {
                // Legacy / Small File Logic
                const proText = document.getElementById('pro-mode-text');
                if (proText) proText.remove();

                transferStatus.textContent = "Lendo arquivo...";
                transferProgressFill.style.width = '10%';

                const reader = new FileReader();
                reader.onload = async (e) => {
                    const base64Data = e.target.result;
                    const totalSize = base64Data.length;

                    transferStatus.textContent = "Enviando...";
                    transferProgressFill.style.width = '30%';

                    try {
                        if (totalSize < CHUNK_SIZE) {
                            await addDoc(collection(db, "sessions", currentUser, "transfers"), {
                                filename: file.name,
                                fileSize: file.size,
                                senderId: deviceId,
                                status: "complete",
                                chunkCount: 0,
                                data: base64Data,
                                timestamp: new Date()
                            });
                        } else {
                            const transferRef = await addDoc(collection(db, "sessions", currentUser, "transfers"), {
                                filename: file.name,
                                fileSize: file.size,
                                senderId: deviceId,
                                status: "uploading",
                                chunkCount: Math.ceil(totalSize / CHUNK_SIZE),
                                timestamp: new Date()
                            });

                            const chunksCollectionRef = collection(db, "sessions", currentUser, "transfers", transferRef.id, "chunks");
                            const batch = writeBatch(db);
                            let chunkIndex = 0;

                            for (let start = 0; start < totalSize; start += CHUNK_SIZE) {
                                const end = Math.min(start + CHUNK_SIZE, totalSize);
                                const chunkData = base64Data.slice(start, end);
                                const chunkDocRef = doc(chunksCollectionRef, chunkIndex.toString());
                                batch.set(chunkDocRef, { data: chunkData });
                                chunkIndex++;
                            }
                            await batch.commit();
                            await updateDoc(transferRef, { status: "complete" });
                        }

                        transferProgressFill.style.width = '100%';
                        transferStatus.textContent = "Arquivo enviado com sucesso!";
                        transferStatus.style.color = "var(--success-color)";
                    } catch (err) {
                        console.error("Upload error:", err);
                        transferStatus.textContent = "Erro no envio: " + err.message;
                        transferStatus.style.color = "var(--error-color)";
                    }
                };
                reader.readAsDataURL(file);
            }

            // Cleanup UI after delay
            setTimeout(() => {
                if (transferStatus.textContent.includes("sucesso")) {
                    transferModal.style.display = 'none';
                    transferProgressBar.style.display = 'none';
                    transferProgressFill.style.width = '0%';
                    transferStatus.textContent = '';
                    const proText = document.getElementById('pro-mode-text');
                    if (proText) proText.remove();
                }
            }, 3000);
        };

        const handleTransferFileSelect = async (e) => {
            const files = e.target.files;
            if (files.length > 0) {
                for (let i = 0; i < files.length; i++) {
                    await uploadFileP2P(files[i]);
                    // Add small delay between uploads to avoid race conditions or UI flickering
                    if (i < files.length - 1) await new Promise(r => setTimeout(r, 1000));
                }
            }
        };

        const handleTransferDrop = async (e) => {
            e.preventDefault();
            transferDropZone.classList.remove('dragover');
            if (e.dataTransfer.files.length > 0) {
                for (let i = 0; i < e.dataTransfer.files.length; i++) {
                    await uploadFileP2P(e.dataTransfer.files[i]);
                    if (i < e.dataTransfer.files.length - 1) await new Promise(r => setTimeout(r, 1000));
                }
            }
        };

        btnTransferFile.addEventListener('click', () => {
            checkBlockedAndExecute(() => {
                transferModal.style.display = 'flex';
            });
        });

        btnCloud.addEventListener('click', () => {
            checkBlockedAndExecute(() => {
                // Mobile 2.0 Check for visibility (redundant if hidden by CSS/hide logic)
                if (isMobile && globalSettings.mobile2_0_enabled) return;

                if (isCloudDisabled) {
                    showConfirmModal("Ops! vocÃª nÃ£o tem acesso aos recusos de armazenamento em nuvem da Axon.", () => { }, true); // True to hide cancel button (make it an alert)
                    return;
                }

                if (axonCloud) {
                    document.getElementById('axon-cloud-modal').style.display = 'flex';
                    axonCloud.render();
                } else {
                    appendOutput("Erro: MÃ³dulo de Nuvem nÃ£o inicializado.", "error");
                }
            });
        });

        // Hide Cloud Button on Mobile 2.0 Init
        const updateMobileVisibility = () => {
            const btnTools = document.getElementById('btn-tools');
            if (isMobile && globalSettings.mobile2_0_enabled) {
                if (btnCloud) btnCloud.style.display = 'none';
                if (btnTools) btnTools.style.display = 'none';
            } else {
                if (btnCloud) btnCloud.style.display = 'flex';
                if (btnTools) btnTools.style.display = 'flex';
            }
        };
        // Call it initially and potentially on listeners if settings change (not implemented here but good to have)

        transferModalClose.addEventListener('click', () => transferModal.style.display = 'none');
        transferDropZone.addEventListener('click', () => transferFileInput.click());
        transferFileInput.addEventListener('change', handleTransferFileSelect);

        transferDropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            transferDropZone.classList.add('dragover');
        });
        transferDropZone.addEventListener('dragleave', () => transferDropZone.classList.remove('dragover'));
        transferDropZone.addEventListener('drop', handleTransferDrop);


        // Mobile 2.0 Button Listeners
        mobileBtnExames.addEventListener('click', () => checkBlockedAndExecute(() => startCamera('exams')));
        mobileBtnSee.addEventListener('click', () => checkBlockedAndExecute(() => startCamera('axon-eye')));
        mobileBtnRecords.addEventListener('click', () => checkBlockedAndExecute(loadPatientList));
        mobileBtnChat.addEventListener('click', () => checkBlockedAndExecute(openChatbox));
        chatboxCloseBtn.addEventListener('click', closeChatbox);
        chatboxSendBtn.addEventListener('click', sendChatMessage);
        chatboxInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') sendChatMessage(); });
        chatboxUploadBtn.addEventListener('click', () => chatFileInput.click());
        chatFileInput.addEventListener('change', handleChatImageUpload);
        chatboxNewChatBtn.addEventListener('click', () => {
            showConfirmModal("Deseja iniciar uma nova conversa? O histÃ³rico atual serÃ¡ perdido.", () => {
                conversationHistory = [];
                chatboxMessages.innerHTML = '';
                openChatbox();
            });
        });

        adminAuthClose.addEventListener('click', () => adminAuthModal.style.display = 'none');
        adminAuthButton.addEventListener('click', checkAdminAuth);
        adminAuthPass.addEventListener('keydown', (e) => { if (e.key === 'Enter') checkAdminAuth(); });

        patientListModal.addEventListener('click', (e) => {
            const target = e.target;
            const deleteButton = target.closest('.delete');
            const pdfButton = target.closest('.pdf');
            const detailsButton = target.closest('.details');

            if (deleteButton) {
                checkBlockedAndExecute(() => deletePatient(deleteButton.dataset.id));
            } else if (pdfButton && !pdfButton.classList.contains('disabled')) {
                checkBlockedAndExecute(() => generatePatientPDF(pdfButton.dataset.id));
            } else if (detailsButton && !detailsButton.classList.contains('disabled')) {
                const patientId = detailsButton.dataset.id;
                const patientData = allPatients.find(p => p.id === patientId);
                if (patientData) showPatientDetails(patientData);
            }
        });

        patientDetailsModal.addEventListener('click', (e) => {
            const header = e.target.closest('.consultation-header');
            if (header) {
                const body = header.nextElementSibling;
                const icon = header.querySelector('i');
                const isVisible = body.style.display === 'block';
                body.style.display = isVisible ? 'none' : 'block';
                icon.classList.toggle('fa-chevron-down', !isVisible);
                icon.classList.toggle('fa-chevron-right', isVisible);
            }
        });

        patientListClose.addEventListener('click', () => patientListModal.style.display = 'none');
        patientDetailsClose.addEventListener('click', () => patientDetailsModal.style.display = 'none');
        patientSearchInput.addEventListener('input', (e) => searchPatients(e.target.value));

        loginModalButton.addEventListener('click', async () => {
            const username = loginModalUser.value.trim(), password = loginModalPass.value.trim();
            if (!username || !password) return loginModalFeedback.textContent = "Preencha todos os campos.";
            loginModalFeedback.textContent = "Verificando..."; loginModalButton.disabled = true;

            const authResult = await authenticateUser(username, password);

            if (authResult.success) {
                if (authResult.isBlocked) {
                    loginModalFeedback.style.color = '#ffcc00';
                    loginModalFeedback.textContent = "Sua conta foi bloqueada!";
                    loginModalButton.disabled = false;
                } else {
                    loginModalFeedback.style.color = 'var(--success-color)'; loginModalFeedback.textContent = "Sucesso!";
                    setTimeout(() => handleSuccessfulLogin(username, false), 500);
                }
            } else {
                loginModalFeedback.style.color = 'var(--error-color)'; loginModalFeedback.textContent = "UsuÃ¡rio ou senha incorretos.";
                loginModalButton.disabled = false;
            }
        });
        loginModalPass.addEventListener('keydown', (e) => { if (e.key === 'Enter') loginModalButton.click(); });

        savePatientModalClose.addEventListener('click', closeSaveModal);
        savePatientButton.addEventListener('click', () => {
            const name = savePatientNameInput.value.trim();
            const dob = savePatientDobInput.value.trim();
            if (!name || !dob) return savePatientFeedback.textContent = 'Preencha todos os campos.';
            savePatient(name, dob);
        });
        savePatientDobInput.addEventListener('input', (e) => {
            let value = e.target.value.replace(/\D/g, '').slice(0, 8);
            if (value.length > 4) value = `${value.slice(0, 2)}/${value.slice(2, 4)}/${value.slice(4)}`;
            else if (value.length > 2) value = `${value.slice(0, 2)}/${value.slice(2)}`;
            e.target.value = value;
        });
        savePatientDobInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') savePatientButton.click(); });

        prescriptionHelperClose.addEventListener('click', closePrescriptionHelper);
        prescriptionHelperModal.addEventListener('click', (e) => {
            if (e.target === prescriptionHelperModal) {
                closePrescriptionHelper();
            }
        });

        prescriptionHelperBody.addEventListener('click', (e) => {
            const copyBtn = e.target.closest('.prescription-template-copy-btn');
            if (copyBtn) {
                const templateId = copyBtn.dataset.templateId;
                const templateTextElement = document.getElementById(templateId);
                if (templateTextElement) {
                    const templateText = templateTextElement.textContent;
                    navigator.clipboard.writeText(templateText).then(() => {
                        const originalText = copyBtn.innerHTML;
                        copyBtn.innerHTML = '<i class="fas fa-check"></i> Copiado!';
                        copyBtn.style.backgroundColor = 'var(--success-color)';
                        setTimeout(() => {
                            copyBtn.innerHTML = originalText;
                            copyBtn.style.backgroundColor = '';
                        }, 2000);
                    });
                }
            }
        });

        interactiveOutput.addEventListener('click', (e) => {
            const conductTitle = e.target.closest('.conduct-title');
            if (conductTitle && conductTitle.dataset.category) {
                openPrescriptionHelper(conductTitle.dataset.category);
            }
        });

        const uploadToSupabase = async (file) => {
            if (!globalSettings.supabaseUrl || !globalSettings.supabaseKey) {
                throw new Error("Credenciais do Supabase nÃ£o configuradas.");
            }

            const cleanName = file.name.replace(/[^a-zA-Z0-9.-]/g, '_');
            const path = `${currentUser}/${Date.now()}_${cleanName}`;
            const bucket = globalSettings.supabaseBucket || 'axon-drive'; // Default to axon-drive
            const url = `${globalSettings.supabaseUrl}/storage/v1/object/${bucket}/${path}`;

            const headers = {
                'Authorization': `Bearer ${globalSettings.supabaseKey}`,
                'apikey': globalSettings.supabaseKey
            };
            // Try to guess content type or default to octet-stream
            // Supabase sometimes requires strict types or just detects it.
            // if (file.type) headers['Content-Type'] = file.type; 

            const response = await fetch(url, {
                method: 'POST',
                headers: headers,
                body: file
            });

            if (!response.ok) {
                let errDetail = '';
                try {
                    const errJson = await response.json();
                    errDetail = JSON.stringify(errJson);
                    if (errJson.error === 'Bucket not found') {
                        errDetail += " (Verifique se o Bucket existe no Supabase)";
                    }
                } catch (e) {
                    errDetail = await response.text();
                }

                throw new Error(`Erro Supabase: ${response.status} - ${errDetail}`);
            }

            const data = await response.json();

            return {
                path: path,
                fullPath: data.Key,
                url: `${globalSettings.supabaseUrl}/storage/v1/object/public/${bucket}/${path}`,
                provider: 'supabase'
            };
        };

        const deleteFromSupabase = async (pathRef) => {
            if (!globalSettings.supabaseUrl || !globalSettings.supabaseKey) return;
            const bucket = globalSettings.supabaseBucket || 'axon-drive';
            const url = `${globalSettings.supabaseUrl}/storage/v1/object/${bucket}/${pathRef}`;

            try {
                const response = await fetch(url, {
                    method: 'DELETE',
                    headers: {
                        'Authorization': `Bearer ${globalSettings.supabaseKey}`,
                        'apikey': globalSettings.supabaseKey
                    }
                });

                if (!response.ok) {
                    console.error("Supabase Delete Error:", await response.text());
                } else {
                    console.log("Supabase File Deleted:", pathRef);
                }
            } catch (e) {
                console.error("Supabase Delete Exception:", e);
            }
        };

        const renameInSupabase = async (oldPath, newPath) => {
            if (!globalSettings.supabaseUrl || !globalSettings.supabaseKey) return;
            const bucket = globalSettings.supabaseBucket || 'axon-drive';
            const url = `${globalSettings.supabaseUrl}/storage/v1/object/move`;

            try {
                const response = await fetch(url, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${globalSettings.supabaseKey}`,
                        'apikey': globalSettings.supabaseKey,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        bucketId: bucket,
                        sourceKey: oldPath,
                        destinationKey: newPath
                    })
                });
                if (!response.ok) console.error("Supabase Move Error:", await response.text());
                else console.log("Supabase File Renamed");
            } catch (e) {
                console.error("Supabase Move Exception:", e);
            }
        };

        const updateSupabaseFile = async (item, content) => {
            if (!globalSettings.supabaseUrl || !globalSettings.supabaseKey) throw new Error("Credenciais ausentes");
            const bucket = globalSettings.supabaseBucket || 'axon-drive';
            const path = item.supabasePath;
            const url = `${globalSettings.supabaseUrl}/storage/v1/object/${bucket}/${path}`;

            const response = await fetch(url, {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${globalSettings.supabaseKey}`,
                    'apikey': globalSettings.supabaseKey,
                    'x-upsert': 'true',
                    'Content-Type': 'text/plain;charset=UTF-8'
                },
                body: content
            });

            if (!response.ok) {
                const err = await response.text();
                console.error("Supabase Save Error:", err);
                throw new Error(err);
            }
        };

        class AxonCloud {
            constructor(username) {
                this.username = username;
                this.currentPath = [];
                this.files = [];
                this.filteredFiles = [];
                this.storageUsed = 0;
                this.filterType = 'all';
                this.unsubscribe = null;
                this.clipboard = null;
                this.handleKeyDown = this.handleKeyDown.bind(this);
                this.init();
            }


            async init() {
                const filesRef = collection(db, "users", this.username, "files");
                this.unsubscribe = onSnapshot(filesRef, (snapshot) => {
                    this.files = [];
                    this.storageUsed = 0;
                    snapshot.forEach(doc => {
                        const data = doc.data();
                        this.files.push({ id: doc.id, ...data });
                        if (data.size) this.storageUsed += data.size;
                    });
                    this.updateStorageUI();
                    this.render();
                });

                this.setupUI();
            }

            setupUI() {
                this.grid = document.getElementById('cloud-grid');
                this.breadcrumb = document.getElementById('cloud-breadcrumb');
                this.sidebarItems = document.querySelectorAll('.cloud-sidebar-item');
                this.uploadBtn = document.getElementById('cloud-btn-upload');
                this.newFolderBtn = document.getElementById('cloud-btn-new-folder');
                this.refreshBtn = document.getElementById('cloud-btn-refresh');
                this.dropZone = document.getElementById('cloud-drop-zone');
                this.searchInput = document.getElementById('cloud-search');
                this.contextMenu = document.getElementById('cloud-context-menu');
                this.bgContextMenu = document.getElementById('cloud-bg-context-menu');

                document.removeEventListener('keydown', this.handleKeyDown);
                document.addEventListener('keydown', this.handleKeyDown);

                // Sidebar
                this.sidebarItems.forEach(item => {
                    item.addEventListener('click', () => {
                        this.sidebarItems.forEach(i => i.classList.remove('active'));
                        item.classList.add('active');
                        this.filterType = item.dataset.target;
                        this.render();
                    });
                });

                // Buttons
                if (this.uploadBtn) {
                    let cloudInput = document.getElementById('cloud-file-input');
                    if (!cloudInput) {
                        cloudInput = document.createElement('input');
                        cloudInput.type = 'file';
                        cloudInput.id = 'cloud-file-input';
                        cloudInput.style.display = 'none';
                        cloudInput.multiple = true;
                        document.body.appendChild(cloudInput);
                        cloudInput.addEventListener('change', (e) => this.handleUpload(e.target.files));
                    }
                    this.uploadBtn.onclick = () => cloudInput.click();
                }
                if (this.newFolderBtn) this.newFolderBtn.onclick = () => this.createNewFolder();
                if (this.refreshBtn) this.refreshBtn.onclick = () => this.render();

                if (this.searchInput) {
                    this.searchInput.addEventListener('input', (e) => this.render(e.target.value));
                }

                // Drag & Drop on Zone
                if (this.dropZone) {
                    this.dropZone.ondragover = (e) => {
                        e.preventDefault();
                        this.dropZone.style.borderColor = 'var(--highlight-color)';
                        this.dropZone.style.background = 'rgba(66, 153, 225, 0.1)';
                    };
                    this.dropZone.ondragleave = (e) => {
                        this.dropZone.style.borderColor = '';
                        this.dropZone.style.background = '';
                    };
                    this.dropZone.ondrop = (e) => {
                        e.preventDefault();
                        this.dropZone.style.borderColor = '';
                        this.dropZone.style.background = '';
                        if (e.dataTransfer.files.length > 0) this.handleUpload(e.dataTransfer.files);
                    };
                }

                // Global Click to close Context Menus
                document.addEventListener('click', () => {
                    if (this.contextMenu) this.contextMenu.style.display = 'none';
                    if (this.bgContextMenu) this.bgContextMenu.style.display = 'none';
                });

                // Grid Right Click (Background)
                this.grid.oncontextmenu = (e) => {
                    if (e.target === this.grid) {
                        e.preventDefault();
                        if (this.bgContextMenu) {
                            this.bgContextMenu.style.display = 'block';
                            this.bgContextMenu.style.left = `${e.pageX}px`;
                            this.bgContextMenu.style.top = `${e.pageY}px`;
                        }
                    }
                };

                // Bind Context Menu Actions
                document.getElementById('ctx-open').onclick = () => this.handleContextAction('open');
                document.getElementById('ctx-download').onclick = () => this.handleContextAction('download');
                document.getElementById('ctx-copy').onclick = () => this.handleContextAction('copy');
                document.getElementById('ctx-rename').onclick = () => this.handleContextAction('rename');
                document.getElementById('ctx-move').onclick = () => this.handleContextAction('move');
                document.getElementById('ctx-delete').onclick = () => this.handleContextAction('delete');

                document.getElementById('ctx-bg-new-folder').onclick = () => this.createNewFolder();
                document.getElementById('ctx-bg-new-text').onclick = () => this.createNewTextFile();
                document.getElementById('ctx-bg-paste').onclick = () => this.handleContextAction('paste');
                document.getElementById('ctx-bg-upload').onclick = () => document.getElementById('cloud-file-input').click();

                // Locking Context Menu
                const ctxLock = document.getElementById('ctx-lock');
                if (ctxLock) ctxLock.onclick = () => this.handleContextAction('lock');
                else {
                    // Inject if not exists (fallback) - Direct append to container as div
                    const ctxMenu = document.getElementById('cloud-context-menu');
                    if (ctxMenu) {
                        const div = document.createElement('div');
                        div.id = 'ctx-lock';
                        div.className = 'context-menu-item';
                        div.innerHTML = '<i class="fas fa-lock"></i> Trancar/Destrancar';
                        div.onclick = () => this.handleContextAction('lock');
                        ctxMenu.appendChild(div);
                    }
                }
            }

            updateStorageUI() {
                let totalLimit = globalSettings.pinataKeys ? globalSettings.pinataKeys.length * 1024 * 1024 * 1024 : 1024 * 1024 * 1024;
                const percent = Math.min((this.storageUsed / totalLimit) * 100, 100);
                const bar = document.getElementById('cloud-storage-bar');
                const text = document.getElementById('cloud-storage-text');
                if (bar) bar.style.width = `${percent}%`;
                if (text) text.textContent = `${this.formatBytes(this.storageUsed)} / ${this.formatBytes(totalLimit)}`;
            }

            isFolderLocked(folderId) {
                if (!folderId || folderId === 'root') return false;
                const folder = this.files.find(f => f.id === folderId);
                if (!folder) return false;
                if (folder.isLocked) return true;
                return this.isFolderLocked(folder.parent);
            }

            render(searchTerm = "") {
                if (!this.grid) return;
                this.grid.innerHTML = '';
                this.updateBreadcrumb();

                const currentParentId = this.currentPath.length > 0 ? this.currentPath[this.currentPath.length - 1].id : 'root';

                // Base items for 'all' view (current folder only)
                let items = this.files.filter(f => f.parent === currentParentId);

                // For type filters, we search globally but MUST respect locked folders logic
                if (this.filterType !== 'all') {
                    // Filter helper
                    const isVisible = (f) => !this.isFolderLocked(f.parent);

                    if (this.filterType === 'images') {
                        items = this.files.filter(f => f.mimeType && f.mimeType.startsWith('image/') && isVisible(f));
                    } else if (this.filterType === 'videos') {
                        items = this.files.filter(f => f.mimeType && f.mimeType.startsWith('video/') && isVisible(f));
                    } else if (this.filterType === 'docs') {
                        items = this.files.filter(f => f.mimeType && (f.mimeType.includes('pdf') || f.mimeType.includes('text')) && isVisible(f));
                    }
                }

                if (searchTerm) {
                    items = this.files.filter(f => f.name.toLowerCase().includes(searchTerm.toLowerCase()));
                }

                items.forEach(item => {
                    const el = document.createElement('div');
                    el.className = 'cloud-item';
                    el.draggable = true;
                    el.dataset.id = item.id; // Added ID for lookups
                    el.dataset.type = item.type;

                    let icon = 'fa-file';
                    if (item.type === 'folder') icon = 'fa-folder';
                    else if (item.mimeType?.startsWith('image')) icon = 'fa-file-image';
                    else if (item.mimeType?.startsWith('video')) icon = 'fa-file-video';
                    else if (item.mimeType?.includes('pdf')) icon = 'fa-file-pdf';

                    // Lock Icon
                    let lockIcon = '';
                    if (item.isLocked) {
                        lockIcon = '<i class="fas fa-lock" style="color:var(--error-color); font-size: 10px; margin-left: 5px;" title="Protegido por senha"></i>';
                    }

                    el.innerHTML = `
                        <div class="cloud-item-icon"><i class="fas ${icon}"></i></div>
                        <div class="cloud-item-name">${item.name} ${lockIcon}</div>
                    `;

                    // Drag Events for Move
                    el.ondragstart = (e) => {
                        e.dataTransfer.setData('text/plain', JSON.stringify({ id: item.id, type: item.type }));
                        el.style.opacity = '0.5';
                    };
                    el.ondragend = () => el.style.opacity = '1';

                    if (item.type === 'folder') {
                        el.ondragover = (e) => { e.preventDefault(); el.style.background = 'var(--highlight-color)'; };
                        el.ondragleave = () => { el.style.background = ''; };
                        el.ondrop = (e) => {
                            e.preventDefault();
                            el.style.background = '';
                            const data = e.dataTransfer.getData('text/plain');
                            if (data) {
                                const draggedItem = JSON.parse(data);
                                if (draggedItem.id !== item.id) {
                                    this.moveItem(draggedItem.id, item.id);
                                }
                            }
                        };
                    }

                    el.onclick = () => {
                        document.querySelectorAll('.cloud-item').forEach(i => i.classList.remove('selected'));
                        el.classList.add('selected');
                        el.classList.add('selected');
                        this.selectedItem = item;
                    };

                    // For keyboard nav to work, we need to update selectedItem when selection changes via keyboard.
                    // But keyboard handler relies on DOM.
                    // So I need to reverse lookup item from DOM ID. 
                    // I will do that in handleKeyDown using dataset.id


                    el.ondblclick = () => {
                        if (item.type === 'folder') {
                            this.verifyLockedFolderAccess(item, () => {
                                this.currentPath.push({ id: item.id, name: item.name });
                                this.render();
                            });
                        } else {
                            this.openPreview(item);
                        }
                    };

                    el.oncontextmenu = (e) => {
                        e.preventDefault();
                        document.querySelectorAll('.cloud-item').forEach(i => i.classList.remove('selected'));
                        el.classList.add('selected');
                        this.selectedItem = item;


                        // Update Lock Context label dynamically
                        const ctxLockItem = document.getElementById('ctx-lock');
                        if (ctxLockItem) {
                            if (item.isLocked) ctxLockItem.innerHTML = '<i class="fas fa-lock-open"></i> Destrancar';
                            else ctxLockItem.innerHTML = '<i class="fas fa-lock"></i> Trancar';
                        }

                        if (this.contextMenu) {
                            this.contextMenu.style.display = 'block';
                            this.contextMenu.style.left = `${e.pageX}px`;
                            this.contextMenu.style.top = `${e.pageY}px`;
                        }
                    };

                    this.grid.appendChild(el);
                });
            }

            updateBreadcrumb() {
                if (!this.breadcrumb) return;
                this.breadcrumb.innerHTML = '';

                const home = document.createElement('div');
                home.className = 'cloud-breadcrumb-item';
                home.innerHTML = '<i class="fas fa-home"></i> InÃ­cio';
                home.onclick = () => {
                    this.currentPath = [];
                    this.render();
                };
                this.breadcrumb.appendChild(home);

                this.currentPath.forEach((step, index) => {
                    const divider = document.createElement('span');
                    divider.innerHTML = '<i class="fas fa-chevron-right" style="font-size: 10px; opacity: 0.5; margin: 0 5px;"></i>';
                    this.breadcrumb.appendChild(divider);

                    const item = document.createElement('div');
                    item.className = 'cloud-breadcrumb-item';
                    item.textContent = step.name;
                    item.onclick = () => {
                        this.currentPath = this.currentPath.slice(0, index + 1);
                        this.render();
                    };
                    this.breadcrumb.appendChild(item);
                });
            }

            async createNewFolder() {
                this.showCustomInput("Nova Pasta", (name) => {
                    const currentParentId = this.currentPath.length > 0 ? this.currentPath[this.currentPath.length - 1].id : 'root';
                    addDoc(collection(db, "users", this.username, "files"), {
                        name: name,
                        type: 'folder',
                        parent: currentParentId,
                        createdAt: new Date(),
                        size: 0
                    }).catch(e => appendOutput("Erro ao criar pasta: " + e.message, "error"));
                });
            }

            async createNewTextFile() {
                this.showCustomInput("Nome do Arquivo (sem .txt)", (name) => {
                    const fileName = name.endsWith('.txt') ? name : `${name}.txt`;
                    // Open a simple editor? For now just empty file or prompt content.
                    // User asked for "Notepad-like". 
                    // Let's ask for content in a standard prompt for simplicity or create empty and open it.
                    // Creating empty is better.
                    const currentParentId = this.currentPath.length > 0 ? this.currentPath[this.currentPath.length - 1].id : 'root';

                    // Helper to upload text as file
                    const blob = new Blob([""], { type: 'text/plain' });
                    const file = new File([blob], fileName, { type: 'text/plain' });

                    this.handleUpload([file]);
                });
            }


            async handleUpload(fileList) {
                const currentParentId = this.currentPath.length > 0 ? this.currentPath[this.currentPath.length - 1].id : 'root';

                // Show notification with animation
                const notification = document.createElement('div');
                notification.className = 'notification-popup';
                notification.innerHTML = `
                    <div style="font-weight:bold; color:var(--highlight-color); display:flex; align-items:center; gap:5px;"><i class="fas fa-cloud-upload-alt"></i> Upload Iniciado</div>
                    <div style="font-size:12px;">Enviando ${fileList.length} arquivo(s)...</div>
                `;
                document.body.appendChild(notification);
                notification.style.display = 'flex';
                if (window.innerWidth <= 768) notification.classList.add('mobile-center');

                // Sequential upload better for status/errors
                for (const file of Array.from(fileList)) {
                    try {
                        let uploadResult = null;
                        let provider = 'pinata';
                        const LIMIT_50MB = 50 * 1024 * 1024;

                        // Check Supabase Preference
                        // Ensure loose type check matches boolean or string 'true'
                        const isSupabaseEnabled = (globalSettings.supabaseEnabled === true || globalSettings.supabaseEnabled === 'true');

                        if (isSupabaseEnabled && file.size < LIMIT_50MB && globalSettings.supabaseUrl && globalSettings.supabaseKey) {
                            try {
                                uploadResult = await uploadToSupabase(file);
                                provider = 'supabase';
                            } catch (sbErr) {
                                console.warn("Supabase upload failed, falling back to Pinata:", sbErr);
                                appendOutput(`Aviso: Upload p/ Supabase falhou (${sbErr.message}). Usando Pinata.`, "info");
                                // Fallback
                                uploadResult = await uploadToPinata(file);
                                provider = 'pinata';
                            }
                        } else {
                            if (isSupabaseEnabled && file.size < LIMIT_50MB) {
                                console.warn("Supabase enabled but missing credentials.");
                            }
                            uploadResult = await uploadToPinata(file);
                            provider = 'pinata';
                        }

                        // Prepare Metadata
                        const fileData = {
                            name: file.name,
                            type: 'file',
                            parent: currentParentId,
                            createdAt: new Date(),
                            size: file.size,
                            mimeType: file.type,
                            provider: provider
                        };

                        if (provider === 'supabase') {
                            fileData.supabasePath = uploadResult.path;
                            fileData.supabaseFullPath = uploadResult.fullPath;
                            fileData.url = uploadResult.url;
                        } else {
                            fileData.ipfsHash = uploadResult.ipfsHash;
                            fileData.pinataKey = uploadResult.pinataKey;
                        }

                        await addDoc(collection(db, "users", this.username, "files"), fileData);

                    } catch (e) {
                        appendOutput(`Erro no upload de ${file.name}: ${e.message}`, "error");
                    }
                }

                setTimeout(() => {
                    notification.innerHTML = `<div style="font-weight:bold; color:var(--success-color);"><i class="fas fa-check"></i> Upload ConcluÃ­do</div>`;
                    setTimeout(() => notification.remove(), 2000);
                }, 2000); // Fake delay for UX if quick, real reporting above
            }

            async moveItem(itemId, targetFolderId) {
                try {
                    await updateDoc(doc(db, "users", this.username, "files", itemId), { parent: targetFolderId });
                    // No need to re-render, onSnapshot will trigger
                } catch (e) { console.error("Move error", e); }
            }

            showErrorModal(message) {
                // Reuse showConfirmModal logic but simplified, or create a specific one.
                // Using alert for simplicity if custom modal overhead is high, but user asked for pop-up.
                // Let's use showConfirmModal with a single callback that does nothing, effectively an OK button loop or just hide cancel button?
                // Actually, let's implement a quick custom "Alert" modal using the existing structure or inject one.
                // Reusing showConfirmModal is easiest if we can tweak it.
                // Or just showCustomConfirm with no cancel action? 

                // Let's try to inject a simple alert modal structure similar to notification but persistent until clicked.
                const overlay = document.createElement('div');
                overlay.className = 'custom-modal';
                overlay.style.display = 'flex';
                overlay.style.zIndex = '9999';

                const content = document.createElement('div');
                content.className = 'custom-modal-content';
                content.style.border = '1px solid var(--error-color)';

                content.innerHTML = `
                    <div class="custom-modal-title" style="color:var(--error-color)"><i class="fas fa-exclamation-triangle"></i> Erro</div>
                    <div style="color:var(--text-color); margin-bottom:10px;">${message}</div>
                    <div class="custom-modal-actions">
                        <button class="app-modal-button" id="btn-err-ok">OK</button>
                    </div>
                `;

                overlay.appendChild(content);
                document.body.appendChild(overlay);

                document.getElementById('btn-err-ok').onclick = () => overlay.remove();
            }

            verifyLockedFolderAccess(item, callback) {
                if (!item) return;
                // If it's a file, check parent? For now, requirement implies locking folders prevents access/action on folder itself.
                // But does it prevent deleting a file inside a locked folder? 
                // The current structure tracks "isLocked" on the folder item. 
                // If the item itself is the folder being acted upon (rename, delete, move), we check it.

                if (item.type === 'folder' && item.isLocked) {
                    this.showCustomInput("Esta pasta estÃ¡ trancada. Digite a senha:", (password) => {
                        if (password === item.lockPassword) {
                            callback();
                        } else {
                            this.showErrorModal("Senha incorreta! Acesso negado.");
                        }
                    });
                } else {
                    callback();
                }
            }

            async handleContextAction(action) {
                if (!this.selectedItem && action !== 'paste') return;
                const item = this.selectedItem;

                if (action === 'open') {
                    if (item.type === 'folder') {
                        this.verifyLockedFolderAccess(item, () => {
                            this.currentPath.push({ id: item.id, name: item.name });
                            this.render();
                        });
                    } else {
                        this.openPreview(item);
                    }
                } else if (action === 'move') {
                    this.verifyLockedFolderAccess(item, () => {
                        this.showFolderSelection((targetFolderId) => {
                            if (targetFolderId && targetFolderId !== item.id) {
                                this.moveItem(item.id, targetFolderId);
                            }
                        });
                    });
                } else if (action === 'download') {
                    if (item.type === 'folder') {
                        this.verifyLockedFolderAccess(item, async () => {
                            if (typeof JSZip === 'undefined') {
                                appendOutput("Erro: Biblioteca JSZip nÃ£o carregada.", "error");
                                return;
                            }

                            appendOutput(`Preparando download da pasta "${item.name}"...`, "info");
                            const zip = new JSZip();
                            let fileCount = 0;

                            // Recursive function to add files/folders
                            const processFolder = async (folderId, zipFolder) => {
                                // Find children
                                const children = this.files.filter(f => f.parent === folderId);

                                for (const child of children) {
                                    if (child.type === 'folder') {
                                        const newZipFolder = zipFolder.folder(child.name);
                                        await processFolder(child.id, newZipFolder);
                                    } else {
                                        if (child.ipfsHash) {
                                            try {
                                                const url = `https://gateway.pinata.cloud/ipfs/${child.ipfsHash}`;
                                                const response = await fetch(url);
                                                if (response.ok) {
                                                    const blob = await response.blob();
                                                    zipFolder.file(child.name, blob);
                                                    fileCount++;
                                                }
                                            } catch (e) {
                                                console.warn(`Skipped ${child.name}:`, e);
                                            }
                                        }
                                    }
                                }
                            };

                            try {
                                const rootZip = zip.folder(item.name);
                                await processFolder(item.id, rootZip);

                                if (fileCount === 0) {
                                    appendOutput("A pasta estÃ¡ vazia ou os arquivos nÃ£o puderam ser baixados.", "error");
                                    return;
                                }

                                appendOutput("Gerando arquivo ZIP...", "info");
                                const content = await zip.generateAsync({ type: "blob" });
                                const downloadUrl = window.URL.createObjectURL(content);
                                const link = document.createElement('a');
                                link.href = downloadUrl;
                                link.download = `${item.name}.zip`;
                                document.body.appendChild(link);
                                link.click();
                                document.body.removeChild(link);
                                window.URL.revokeObjectURL(downloadUrl);
                                appendOutput("Download da pasta concluÃ­do!", "success");

                            } catch (e) {
                                appendOutput(`Erro ao criar ZIP: ${e.message}`, "error");
                            }
                        });
                        return;
                    }

                    if (!item.ipfsHash) {
                        appendOutput("Erro: Hash IPFS nÃ£o encontrado para este arquivo.", "error");
                        return;
                    }

                    const url = `https://gateway.pinata.cloud/ipfs/${item.ipfsHash}`;
                    appendOutput(`Iniciando download de ${item.name}...`, "info");

                    try {
                        // Attempt Fetch first to preserve filename
                        const response = await fetch(url);
                        if (!response.ok) throw new Error(`Status ${response.status}`);
                        const blob = await response.blob();
                        const downloadUrl = window.URL.createObjectURL(blob);
                        const link = document.createElement('a');
                        link.href = downloadUrl;
                        link.download = item.name;
                        document.body.appendChild(link);
                        link.click();
                        document.body.removeChild(link);
                        window.URL.revokeObjectURL(downloadUrl);
                        appendOutput("Download concluÃ­do.", "success");
                    } catch (e) {
                        console.warn("Fetch download failed, trying fallback:", e);
                        // Fallback: Direct link (works even if CORS blocks fetch)
                        try {
                            const link = document.createElement('a');
                            link.href = url;
                            link.download = item.name;
                            link.target = "_blank"; // Force new tab if download attribute ignored
                            document.body.appendChild(link);
                            link.click();
                            document.body.removeChild(link);
                            appendOutput("Download iniciado (Link Direto).", "success");
                        } catch (errFallback) {
                            appendOutput(`Erro ao baixar arquivo: ${errFallback.message}`, "error");
                        }
                    }
                } else if (action === 'delete') {
                    this.verifyLockedFolderAccess(item, () => {
                        this.showCustomConfirm(`Excluir ${item.name}?`, async () => {
                            if (item.provider === 'supabase' && item.supabasePath) {
                                await deleteFromSupabase(item.supabasePath);
                            } else if (item.type === 'file' && item.ipfsHash) {
                                await unpinFromPinata(item.ipfsHash);
                            }
                            await deleteDoc(doc(db, "users", this.username, "files", item.id));
                        });
                    });
                } else if (action === 'rename') {
                    this.verifyLockedFolderAccess(item, () => {
                        this.showCustomInput("Renomear", async (newName) => {
                            if (newName && newName !== item.name) {
                                let updates = { name: newName };
                                // Supabase Rename
                                if (item.provider === 'supabase' && item.supabasePath) {
                                    // Construct new path: keep folder structure, replace filename in path?
                                    // Usually supabasePath = user/timestamp_filename
                                    // We can just replace the filename part, but timestamp ensures uniqueness.
                                    // Simpler: Just rename in metadata OR try to rename file in bucket.
                                    // User wants bucket change.
                                    // Let's keep timestamp but change name suffix.
                                    const parts = item.supabasePath.split('_');
                                    // Reconstruct prefix
                                    const prefix = parts[0]; // "user/timestamp" (wait, timestamp is likely part 1 if format is "user/timestamp_name")
                                    // Actually path construction was: `${currentUser}/${Date.now()}_${cleanName}`
                                    // So it splits by _. 
                                    // If name has underscores, split might be complex.
                                    // Safer: Replace last part or just use a new clean name with SAME timestamp prefix if possible, or just NEW path.

                                    // Let's use the folder path (parent directory) + new name?
                                    // But supabasePath is just a key.
                                    // Let's just create a new key: `currentUser/Date.now()_newName` (new timestamp to be safe)
                                    // But Move requires known source.
                                    // Destination can be anything.
                                    // Let's make destination: `currentUser/${Date.now()}_${newName.replace(/[^a-zA-Z0-9.-]/g, '_')}`

                                    const cleanName = newName.replace(/[^a-zA-Z0-9.-]/g, '_');
                                    const newPath = `${this.username}/${Date.now()}_${cleanName}`;

                                    await renameInSupabase(item.supabasePath, newPath);

                                    updates.supabasePath = newPath;
                                    updates.supabaseFullPath = `${globalSettings.supabaseBucket || 'axon-drive'}/${newPath}`;
                                    // Update URL too? 
                                    // Yes, URL changes.
                                    updates.url = `${globalSettings.supabaseUrl}/storage/v1/object/public/${globalSettings.supabaseBucket || 'axon-drive'}/${newPath}`;
                                }

                                await updateDoc(doc(db, "users", this.username, "files", item.id), updates);
                            }
                        }, item.name);
                    });
                } else if (action === 'copy') {
                    // Copying a locked folder? Maybe check access before copying?
                    this.verifyLockedFolderAccess(item, () => {
                        this.clipboard = { action: 'copy', item: item };
                        this.contextMenu.style.display = 'none';
                    });
                } else if (action === 'paste') {
                    if (this.clipboard) {
                        const currentParentId = this.currentPath.length > 0 ? this.currentPath[this.currentPath.length - 1].id : 'root';
                        const { item } = this.clipboard;

                        if (this.clipboard.action === 'copy') {
                            const newItem = { ...item };
                            delete newItem.id;

                            await addDoc(collection(db, "users", this.username, "files"), {
                                ...newItem,
                                name: `CÃ³pia de ${item.name}`,
                                parent: currentParentId,
                                createdAt: new Date()
                            });
                        }
                    }
                } else if (action === 'lock') {
                    if (!this.selectedItem) return;
                    if (this.selectedItem.type !== 'folder') {
                        return this.showErrorModal("Apenas pastas podem ser trancadas.");
                    }

                    if (this.selectedItem.isLocked) {
                        // UNLOCK FLOW
                        this.showCustomInput("Digite a senha para destrancar:", async (password) => {
                            if (password === this.selectedItem.lockPassword) {
                                await updateDoc(doc(db, "users", this.username, "files", this.selectedItem.id), {
                                    isLocked: false,
                                    lockPassword: null
                                });
                                appendOutput("Pasta destrancada.", "success");
                            } else {
                                this.showErrorModal("Senha incorreta.");
                            }
                        });
                    } else {
                        // LOCK FLOW
                        this.showCustomInput("Crie uma senha para esta pasta:", async (password) => {
                            if (!password) return;
                            await updateDoc(doc(db, "users", this.username, "files", this.selectedItem.id), {
                                isLocked: true,
                                lockPassword: password
                            });
                            appendOutput("Pasta trancada com sucesso.", "success");
                        });
                    }
                }

                if (this.contextMenu) this.contextMenu.style.display = 'none';
                if (this.bgContextMenu) this.bgContextMenu.style.display = 'none';
            }

            handleKeyDown(e) {
                const modal = document.getElementById('axon-cloud-modal');
                if (!modal || modal.style.display === 'none') return;

                // Ignore if creating/renaming (input focused in custom modal)
                if (document.getElementById('custom-input-modal').style.display === 'flex') return;
                // Ignore if text editor is open
                if (document.getElementById('text-editor-modal').style.display === 'flex') return;

                if (e.key === 'Escape') {
                    modal.style.display = 'none';
                    return;
                }

                // Ignore if user is typing in an input (e.g. search bar, free mode, terminal)
                if (['INPUT', 'TEXTAREA'].includes(e.target.tagName) || e.target.isContentEditable) return;

                if (e.ctrlKey && (e.key === 'c' || e.key === 'C')) {
                    if (this.selectedItem) {
                        this.handleContextAction('copy');
                        // Visual feedback?
                    }
                    return;
                }

                if (e.ctrlKey && (e.key === 'v' || e.key === 'V')) {
                    this.handleContextAction('paste');
                    return;
                }

                if (e.key === 'Delete') {
                    if (this.selectedItem) this.handleContextAction('delete');
                    return;
                }

                if (e.key === 'Enter') {
                    if (this.selectedItem) {
                        if (this.selectedItem.type === 'folder') {
                            if (this.selectedItem.isLocked) {
                                this.showCustomInput("Esta pasta estÃ¡ trancada. Digite a senha:", (password) => {
                                    if (password === this.selectedItem.lockPassword) {
                                        this.currentPath.push({ id: this.selectedItem.id, name: this.selectedItem.name });
                                        this.render();
                                    } else {
                                        appendOutput("Senha incorreta! Acesso negado.", "error");
                                    }
                                });
                                return;
                            }
                            this.currentPath.push({ id: this.selectedItem.id, name: this.selectedItem.name });
                            this.render();
                        } else {
                            this.openPreview(this.selectedItem);
                        }
                    }
                    return;
                }

                const items = Array.from(document.querySelectorAll('.cloud-item'));
                if (items.length === 0) return;

                let selectedIndex = items.findIndex(el => el.classList.contains('selected'));

                if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
                    e.preventDefault();
                    if (selectedIndex === -1) {
                        selectedIndex = 0;
                    } else {
                        const gridStyle = window.getComputedStyle(this.grid);
                        const gridCols = gridStyle.getPropertyValue('grid-template-columns').split(' ').length || 1;
                        // Note: split(' ').length might not work if it returns "repeat(...)" or auto-fill. 
                        // Better to estimate based on item width and container width.
                        const itemWidth = items[0].offsetWidth + 20; // + gap approx
                        const containerWidth = this.grid.clientWidth;
                        const cols = Math.floor(containerWidth / itemWidth) || 1;

                        if (e.key === 'ArrowRight') selectedIndex = Math.min(items.length - 1, selectedIndex + 1);
                        else if (e.key === 'ArrowLeft') selectedIndex = Math.max(0, selectedIndex - 1);
                        else if (e.key === 'ArrowDown') selectedIndex = Math.min(items.length - 1, selectedIndex + cols);
                        else if (e.key === 'ArrowUp') selectedIndex = Math.max(0, selectedIndex - cols);
                    }

                    // Update selection
                    items.forEach(i => i.classList.remove('selected'));
                    items[selectedIndex].classList.add('selected');
                    items[selectedIndex].scrollIntoView({ block: 'nearest' });

                    // Update selectedItem from DOM
                    const newSelectedEl = items[selectedIndex];
                    const newId = newSelectedEl.dataset.id;
                    this.selectedItem = this.files.find(f => f.id === newId);
                }
            }

            showCustomInput(title, callback, defaultValue = "") {
                const modal = document.getElementById('custom-input-modal');
                const titleEl = document.getElementById('custom-input-title');
                const inputEl = document.getElementById('custom-input-field');
                const confirmBtn = document.getElementById('custom-input-confirm');
                const cancelBtn = document.getElementById('custom-input-cancel');

                titleEl.textContent = title;
                inputEl.value = defaultValue;
                modal.style.display = 'flex';
                inputEl.focus();

                confirmBtn.onclick = () => {
                    if (inputEl.value.trim()) {
                        callback(inputEl.value.trim());
                        modal.style.display = 'none';
                    }
                };
                cancelBtn.onclick = () => modal.style.display = 'none';
            }

            showCustomConfirm(text, onYes) {
                // Use the modal I just added in HTML
                // But wait, I added 'custom-confirm-modal' (existing) OR 'custom-confirm-modal-axon' ??? 
                // The existing code has 'custom-confirm-modal'.
                // My new HTML has 'custom-confirm-modal-axon' ?? NO, I used 'custom-confirm-modal' in existing HTML?
                // Let's use the existing 'showConfirmModal' function if possible, or adapt.
                // The existing 'showConfirmModal' returns a Promise.

                // Reuse existing global function
                showConfirmModal(text, onYes);
            }

            async showFolderSelection(callback) {
                const modal = document.getElementById('select-folder-modal');
                const listContainer = document.getElementById('folder-list-container');
                const cancelBtn = document.getElementById('select-folder-cancel');

                // Get all folders
                const folders = this.files.filter(f => f.type === 'folder');

                listContainer.innerHTML = '';

                // Add Root option
                const rootEl = document.createElement('div');
                rootEl.style.padding = '10px';
                rootEl.style.cursor = 'pointer';
                rootEl.style.borderBottom = '1px solid var(--border-color)';
                rootEl.innerHTML = '<i class="fas fa-home"></i> Raiz (InÃ­cio)';
                rootEl.onmouseover = () => rootEl.style.background = 'var(--button-hover-bg)';
                rootEl.onmouseout = () => rootEl.style.background = '';
                rootEl.onclick = () => {
                    callback('root');
                    modal.style.display = 'none';
                };
                listContainer.appendChild(rootEl);

                folders.forEach(folder => {
                    const el = document.createElement('div');
                    el.style.padding = '10px';
                    el.style.cursor = 'pointer';
                    el.style.borderBottom = '1px solid var(--border-color)';
                    el.innerHTML = `<i class="fas fa-folder"></i> ${folder.name}`;
                    el.onmouseover = () => el.style.background = 'var(--button-hover-bg)';
                    el.onmouseout = () => el.style.background = '';
                    el.onclick = () => {
                        callback(folder.id);
                        modal.style.display = 'none';
                    };
                    listContainer.appendChild(el);
                });

                modal.style.display = 'flex';
                cancelBtn.onclick = () => modal.style.display = 'none';
            }

            formatBytes(bytes, decimals = 2) {
                if (bytes === 0) return '0 Bytes';
                const k = 1024;
                const dm = decimals < 0 ? 0 : decimals;
                const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];
                const i = Math.floor(Math.log(bytes) / Math.log(k));
                return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
            }

            async openPreview(item) {
                const previewModal = document.getElementById('file-preview-modal');
                const previewContent = document.getElementById('preview-content');
                const previewTitle = document.getElementById('preview-title');
                const downloadBtn = document.getElementById('preview-download-btn');

                // Reset content
                previewContent.innerHTML = '';
                previewTitle.textContent = item.name;

                let fileUrl = '';
                if (item.provider === 'supabase' && item.url) {
                    fileUrl = item.url;
                } else if (item.ipfsHash) {
                    fileUrl = `https://gateway.pinata.cloud/ipfs/${item.ipfsHash}`;
                } else {
                    appendOutput("Erro: URL do arquivo nÃ£o encontrada.", "error");
                    return;
                }

                // Direct Download Handlers for Preview
                downloadBtn.onclick = async (e) => {
                    e.preventDefault();
                    downloadBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';
                    try {
                        const response = await fetch(fileUrl);
                        if (!response.ok) throw new Error("Falha ao baixar.");
                        const blob = await response.blob();
                        const downloadUrl = window.URL.createObjectURL(blob);
                        const link = document.createElement('a');
                        link.href = downloadUrl;
                        link.download = item.name;
                        document.body.appendChild(link);
                        link.click();
                        document.body.removeChild(link);
                        window.URL.revokeObjectURL(downloadUrl);
                        downloadBtn.innerHTML = '<i class="fas fa-download"></i>';
                    } catch (err) {
                        alert("Erro no download: " + err.message);
                        downloadBtn.innerHTML = '<i class="fas fa-download"></i>';
                    }
                };
                downloadBtn.href = "#"; // Disable default link

                if (item.mimeType && item.mimeType.startsWith('image/')) {
                    const img = document.createElement('img');
                    img.src = fileUrl;
                    previewContent.appendChild(img);
                    previewModal.style.display = 'flex';
                } else if (item.mimeType && item.mimeType.startsWith('video/')) {
                    const video = document.createElement('video');
                    video.src = fileUrl;
                    video.controls = true;
                    previewContent.appendChild(video);
                    previewModal.style.display = 'flex';
                } else if (item.mimeType && item.mimeType.includes('pdf')) {
                    const iframe = document.createElement('iframe');
                    iframe.src = fileUrl; // Pinata Gateway can render PDFs usually
                    // Alternatively use pdf.js if needed, but iframe is a good start
                    previewContent.appendChild(iframe);
                    previewModal.style.display = 'flex';
                } else if (item.name.endsWith('.txt') || (item.mimeType && item.mimeType.includes('text'))) {
                    this.openTextEditor(item);
                } else {
                    // Fallback for others
                    appendOutput(`NÃ£o Ã© possÃ­vel visualizar este arquivo. Iniciando download...`, "info");
                    downloadBtn.click();
                }
            }

            async openTextEditor(item) {
                const modal = document.getElementById('text-editor-modal');
                const textarea = document.getElementById('text-editor-textarea');
                const title = document.getElementById('text-editor-title');
                const saveBtn = document.getElementById('text-editor-save');
                const closeBtn = document.getElementById('text-editor-close');
                const status = document.getElementById('text-editor-status');

                title.textContent = `Editando: ${item.name}`;
                textarea.value = "Carregando...";
                status.textContent = "";

                modal.style.display = 'flex';

                let fileUrl = '';
                if (item.provider === 'supabase' && item.url) {
                    fileUrl = item.url;
                } else if (item.ipfsHash) {
                    fileUrl = `https://gateway.pinata.cloud/ipfs/${item.ipfsHash}`;
                }

                if (item.provider === 'supabase') {
                    fileUrl += (fileUrl.includes('?') ? '&' : '?') + 't=' + Date.now();
                }

                try {
                    const response = await fetch(fileUrl);
                    if (!response.ok) throw new Error("Falha ao carregar arquivo de texto.");
                    const text = await response.text();
                    textarea.value = text;
                } catch (e) {
                    textarea.value = "";
                    status.textContent = "Erro ao carregar conteÃºdo.";
                    console.error(e);
                }

                saveBtn.onclick = async () => {
                    const newContent = textarea.value;
                    status.textContent = "Salvando...";
                    try {
                        await this.saveTextFile(item, newContent);
                        status.textContent = "Salvo com sucesso!";
                        status.style.color = "var(--success-color)";
                        setTimeout(() => status.textContent = "", 3000);
                    } catch (e) {
                        status.textContent = "Erro ao salvar: " + e.message;
                        status.style.color = "var(--error-color)";
                    }
                };

                closeBtn.onclick = () => {
                    modal.style.display = 'none';
                };
            }

            async saveTextFile(item, content) {
                // 1. Create Blob/File
                const blob = new Blob([content], { type: 'text/plain' });
                const file = new File([blob], item.name, { type: 'text/plain' });

                if (item.provider === 'supabase') {
                    await updateSupabaseFile(item, content);
                    await updateDoc(doc(db, "users", this.username, "files", item.id), {
                        size: new Blob([content]).size,
                        lastModified: new Date()
                    });
                    return;
                }

                // 2. Upload to Pinata
                const uploadResult = await uploadToPinata(file);

                // 3. Update Firestore
                await updateDoc(doc(db, "users", this.username, "files", item.id), {
                    ipfsHash: uploadResult.ipfsHash,
                    pinataKey: uploadResult.pinataKey,
                    size: file.size,
                    lastModified: new Date()
                });

                // 4. Clean up old file (optional, depends on policy, here we just orphan it safely)
                // We could call unpinFromPinata(item.ipfsHash) if we want to save space and have the keys.
                // NOTE: We do not have the old pinataKey stored in the item doc explicitly in previous versions? 
                // Wait, we DO store pinataKey in the doc now (see line 7555).
                if (item.pinataKey && item.ipfsHash) {
                    // Try to unpin old
                    // However, we need to pass the specific key used for that file.
                    // The uploadToPinata function uses a random key.
                    // If we stored the key object or just the keys... 
                    // The doc stores `pinataKey` object: { key: '...', secret: '...' }
                    // So we can unpin.

                    // But wait, unpinFromPinata iterates ALL global keys. 
                    // Let's just use unpinFromPinata(item.ipfsHash). It tries all keys.
                    // Or improves unpinFromPinata to take a specific key if known?
                    // For now, let's just trigger unpinFromPinata(item.ipfsHash).
                    unpinFromPinata(item.ipfsHash);
                }
            }
        }

        const initApp = async () => {
            // Initialize settings FIRST to ensure listeners and preferences (like log suppression) are active
            await setupGlobalSettingsListener();

            const savedTheme = localStorage.getItem('theme');
            const systemPrefersLight = window.matchMedia('(prefers-color-scheme: light)').matches;
            if (savedTheme) {
                setTheme(savedTheme);
            } else {
                setTheme(systemPrefersLight ? 'light' : 'dark');
            }

            adminPanelModal.addEventListener('click', (e) => {
                const formContainer = document.getElementById('create-user-form-container');
                if (!formContainer) return;

                if (e.target.closest('#toggle-create-user-form')) {
                    formContainer.style.display = 'block';
                }
                if (e.target.closest('#close-create-user-form')) {
                    formContainer.style.display = 'none';
                }
            });

            const cloudCloseBtn = document.querySelector('.axon-cloud-close');
            if (cloudCloseBtn) {
                cloudCloseBtn.addEventListener('click', () => {
                    document.getElementById('axon-cloud-modal').style.display = 'none';
                });
            }


            const mobileStatusEl = document.querySelector('.mobile-connection-status');
            if (mobileStatusEl) {
                mobileStatusEl.addEventListener('click', () => {
                    showConfirmModal(
                        "Deseja encerrar todas as sessÃµes em desktops? Qualquer dispositivo conectado serÃ¡ desconectado e precisarÃ¡ de um novo login.",
                        async () => {
                            if (currentUser) {
                                try {
                                    await deleteDoc(doc(db, "sessions", currentUser));
                                } catch (e) {
                                    console.error("Erro ao encerrar sessÃ£o remota:", e);
                                }
                            }
                        }
                    );
                });
            }

            window.addEventListener('beforeunload', () => {
                if (isLoggedIn && currentUser && !isMobile) {
                    // This is a 'fire and forget' call. It's a best-effort attempt to clean up 
                    // the session document when the desktop user closes the tab or navigates away.
                    deleteDoc(doc(db, "sessions", currentUser));
                }
            });

            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    if (chatboxModal.style.display === 'flex') {
                        closeChatbox();
                    } else if (fullscreenModal.style.display === 'block') {
                        fullscreenModal.style.display = 'none';
                    } else if (albumModal.style.display === 'flex') {
                        closeAlbumModal();
                    } else if (patientListModal.style.display === 'flex') {
                        patientListModal.style.display = 'none';
                    } else if (patientDetailsModal.style.display === 'flex') {
                        patientDetailsModal.style.display = 'none';
                    } else if (savePatientModal.style.display === 'flex') {
                        closeSaveModal();
                    } else if (adminAuthModal.style.display === 'flex') {
                        adminAuthModal.style.display = 'none';
                    } else if (adminPanelModal.style.display === 'flex') {
                        adminPanelModal.style.display = 'none';
                    } else if (prescriptionHelperModal.style.display === 'flex') {
                        closePrescriptionHelper();
                    } else if (cameraModal.style.display === 'flex') {
                        cancelCamera();
                    } else if (transferModal.style.display === 'flex') {
                        transferModal.style.display = 'none';
                    }
                }
            });

            if (isSpeechRecognitionSupported()) initSpeechRecognition();

            const savedUser = localStorage.getItem('axon_logged_in_user');
            if (savedUser) {
                appendOutput(`Verificando sessÃ£o para ${savedUser}...`, "info", false);
                const userIsValid = await isUserValid(savedUser);
                if (userIsValid) {
                    const sessionRef = doc(db, "sessions", savedUser);
                    const sessionSnap = await getDoc(sessionRef);

                    if (!isMobile && sessionSnap.exists()) {
                        handleSuccessfulLogin(savedUser, true);
                        updateMobileVisibility();
                    } else {
                        if (isMobile) { // Mobile can always "restore" to connect to a desktop session
                            handleSuccessfulLogin(savedUser, true);
                            updateMobileVisibility();
                        } else {
                            appendOutput("SessÃ£o anterior foi encerrada. Por favor, faÃ§a login novamente.", "info", false);
                            localStorage.removeItem('axon_logged_in_user');
                            loginModal.style.display = 'flex';
                            loginModalUser.focus();
                        }
                    }
                } else {
                    appendOutput(`UsuÃ¡rio '${savedUser}' nÃ£o existe mais. Por favor, faÃ§a login novamente.`, "error", false);
                    localStorage.removeItem('axon_logged_in_user');
                    loginModal.style.display = 'flex';
                    loginModalUser.focus();
                }
            } else {
                loginModal.style.display = 'flex';
                loginModalUser.focus();
            }
            if (isMobile) { statusTextApi.textContent = ""; statusTextMic.textContent = ""; statusTextCam.textContent = ""; }
        };

        // Prescription Assistant Interactions & Admin Logic
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                const prescModal = document.getElementById('prescription-modal');
                if (prescModal && prescModal.style.display === 'flex') {
                    prescModal.style.display = 'none';
                }
            }
        });

        ['presc-input', 'presc-age', 'presc-weight'].forEach(id => {
            const el = document.getElementById(id);
            if (el) {
                el.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        document.getElementById('btn-generate-prescription').click();
                    }
                });
            }
        });

        // Prescription Assistant Interactions
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                const prescModal = document.getElementById('prescription-modal');
                if (prescModal && prescModal.style.display === 'flex') {
                    prescModal.style.display = 'none';
                }
            }
        });

        ['presc-input', 'presc-age', 'presc-weight'].forEach(id => {
            const el = document.getElementById(id);
            if (el) {
                el.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        document.getElementById('btn-generate-prescription').click();
                    }
                });
            }
        });



        // --- AXON PLUGIN SYSTEM ---
        class AxonPluginManager {
            constructor() {
                this.plugins = [];
                this.activeWindows = [];
                this.storePlugins = []; // Will load from mock or file
                this.unsubscribePlugins = null;
            }

            init() {
                this.injectButton();
                this.loadStoreData();
                this.startPluginListener(); // Real-time Firestore sync
                // Ensure tabs are correct on init
                this.switchTab('installed');
            }

            // Listen for user's plugins from Firestore
            startPluginListener() {
                if (!currentUser) return;
                const q = query(collection(db, "users", currentUser, "files"), where("type", "==", "axon_plugin"));

                this.unsubscribePlugins = onSnapshot(q, (snapshot) => {
                    this.plugins = [];
                    snapshot.forEach(doc => {
                        this.plugins.push({ dbId: doc.id, ...doc.data() });
                    });
                    this.renderInstalled();
                });
            }

            async loadStoreData() {
                // Base plugins (Local backup or core)
                const localPlugins = [
                    {
                        id: 'quick-notes-pro',
                        name: 'Notas RÃ¡pidas Pro',
                        author: 'Community',
                        description: 'Bloco de notas persistente. Salva suas anotaÃ§Ãµes automaticamente.',
                        icon: 'https://cdn-icons-png.flaticon.com/512/3209/3209265.png',
                        version: '2.0',
                        html: `
                            <style>body{margin:0;display:flex;flex-direction:column;height:100vh; font-family: sans-serif;} textarea{flex:1;border:none;padding:15px;font-size: 14px; resize:none;outline:none;background:#fffaf0; line-height: 1.5; color: #444;} ::placeholder { color: #aaa; }</style>
                            <textarea id="note" placeholder="Digite suas notas aqui..."></textarea>
                            <script>
                                const area = document.getElementById('note');
                                area.value = localStorage.getItem('axon_quick_note') || '';
                                area.addEventListener('input', () => localStorage.setItem('axon_quick_note', area.value));
                            <\/script>
                        `
                    }
                ];

                this.storePlugins = [...localPlugins];

                // Show Loading Animation
                const storeList = document.getElementById('store-plugins-list');
                if (storeList) {
                    storeList.innerHTML = `
                        <div style="grid-column: 1 / -1; display:flex; flex-direction:column; align-items:center; justify-content:center; padding: 50px; color: var(--text-color); opacity: 0.8;">
                            <div class="ai-processing-animation" style="transform:scale(0.8); margin-bottom:15px;">
                                <div class="scanner-animation">
                                    <div class="brain-icon"><i class="fas fa-cubes"></i></div>
                                    <div class="scanner-line"></div>
                                </div>
                            </div>
                            <div style="font-size:14px; font-weight:500;">Conectando Ã  Axon Store...</div>
                            <div style="font-size:11px; opacity:0.6; margin-top:5px;">Buscando plugins via satÃ©lite Pinata...</div>
                        </div>
                     `;
                }

                if (this.unsubscribeStore) this.unsubscribeStore();

                // Real-time listener to Global Store
                this.unsubscribeStore = onSnapshot(collection(db, "axon_store_plugins"), (snapshot) => {
                    // Update list
                    this.storePlugins = [...localPlugins];

                    snapshot.forEach(doc => {
                        this.storePlugins.push(doc.data());
                    });

                    this.storeStatusMessage = "";
                    this.renderStore();
                }, (error) => {
                    console.error("Store Error", error);
                    this.storeStatusMessage = "Erro de conexÃ£o com a loja. Verifique sua internet.";
                    this.renderStore();
                });
            }

            injectButton() {
                // Target: Header 'Enviar' button (btn-transfer-file)
                const refBtn = document.getElementById('btn-transfer-file');

                if (refBtn && refBtn.parentNode) {
                    // Check if already exists
                    if (document.getElementById('btn-tools')) return;

                    // Global Setting Check
                    if (globalSettings.showToolsButton === false) return; // Don't create if disabled globally

                    const btn = document.createElement('div');
                    btn.id = 'btn-tools';
                    btn.className = 'status-bar';
                    btn.style.cssText = 'cursor:pointer;margin-right:10px;background:var(--highlight-color);color:#fff;border-color:transparent';
                    btn.innerHTML = '<div class="status-item"><i class="fas fa-cubes"></i><span>Ferramentas</span></div>';
                    btn.onclick = () => this.openManager();

                    // Insert after btn-transfer-file
                    if (refBtn.nextSibling) {
                        refBtn.parentNode.insertBefore(btn, refBtn.nextSibling);
                    } else {
                        refBtn.parentNode.appendChild(btn);
                    }

                    // Apply mobile visibility rules immediately
                    if (typeof updateMobileVisibility === 'function') updateMobileVisibility();
                } else {
                    // Fallback to footer logic removed or simplied if needed, but Header is preferred.
                }
            }

            openManager() {
                document.getElementById('plugin-manager-modal').style.display = 'flex';
                this.renderInstalled();
                // Trigger load again when opening, to catch new file changes if possible (though browser caches)
                this.loadStoreData().then(() => this.renderStore());
            }

            switchTab(tab) {
                const installedView = document.getElementById('view-installed-plugins');
                const storeView = document.getElementById('view-axon-store');
                const tabInstalled = document.getElementById('tab-installed-plugins');
                const tabStore = document.getElementById('tab-axon-store');

                if (installedView) installedView.style.display = tab === 'installed' ? 'block' : 'none';
                if (storeView) storeView.style.display = tab === 'store' ? 'block' : 'none';
                if (tabInstalled) tabInstalled.classList.toggle('active', tab === 'installed');
                if (tabStore) tabStore.classList.toggle('active', tab === 'store');

                if (tab === 'store') this.renderStore();
            }

            renderInstalled() {
                const container = document.getElementById('installed-plugins-list');
                const emptyMsg = document.getElementById('no-plugins-msg');
                if (!container) return;

                container.innerHTML = '';

                // Add Import Button at the top/start of the list as a special card or header action
                // User asked for "Import button layout... similar to other buttons... in Installed tab"
                // Let's create a header area for the installed tab
                // Wait, the HTML structure for 'view-installed-plugins' is just the grid. 
                // I'll prepend a toolbar div.
                const toolbar = document.createElement('div');
                toolbar.style.cssText = 'width: 100%; padding: 10px 15px; display: flex; justify-content: flex-end; align-items: center; border-bottom: 1px solid var(--border-color); margin-bottom: 10px;';
                toolbar.innerHTML = `
                    <button class="patient-action-button" onclick="window.axonPluginManager.importFromFile()">
                        <i class="fas fa-file-import"></i> Importar Plugin
                    </button>
                `;
                // If I append to container, it messes up grid. 
                // Grid is 'plugin-grid'. 
                // I should clear container and insert toolbar BEFORE the logic of items? 
                // No, grid should only contain cards. Toolbar should be outside.
                // But the HTML for tab body is hardcoded. 
                // I will inject the toolbar into the parent of container if not exists?
                // Or just clear container AND add toolbar? But toolbar shouldn't be a grid item.
                // Let's modify the modal HTML dynamically properly or just assume grid handles full width items? No.
                // I will manipulate the DOM of 'view-installed-plugins' to ensure toolbar exists.

                const installedView = document.getElementById('view-installed-plugins');
                let existingToolbar = installedView.querySelector('.installed-toolbar');
                if (!existingToolbar) {
                    existingToolbar = toolbar;
                    existingToolbar.className = 'installed-toolbar';
                    installedView.insertBefore(existingToolbar, container);
                }

                if (this.plugins.length === 0) {
                    if (emptyMsg) emptyMsg.style.display = 'block';
                    return;
                }
                if (emptyMsg) emptyMsg.style.display = 'none';

                this.plugins.forEach(p => {
                    const card = this.createCard(p, true);
                    container.appendChild(card);
                });
            }

            renderStore() {
                const container = document.getElementById('store-plugins-list');
                const searchEl = document.getElementById('store-search');
                if (!container) return;

                const search = searchEl ? searchEl.value.toLowerCase() : "";
                container.innerHTML = '';

                // Show Status/Error Message if exists
                if (this.storeStatusMessage) {
                    const msgDiv = document.createElement('div');
                    msgDiv.style.cssText = 'grid-column: 1 / -1; padding: 15px; margin-bottom: 20px; background: rgba(50,50,50,0.05); border-left: 4px solid var(--highlight-color); border-radius: 4px; color: var(--text-color); font-size: 14px;';
                    // Use error color if it contains "Erro"
                    if (this.storeStatusMessage.toLowerCase().includes('erro') || this.storeStatusMessage.toLowerCase().includes('aviso')) {
                        msgDiv.style.borderLeftColor = 'var(--error-color)';
                        msgDiv.style.background = 'rgba(255,0,0,0.05)';
                    }
                    msgDiv.innerHTML = `<strong>Status:</strong> ${this.storeStatusMessage}`;
                    container.appendChild(msgDiv);
                }

                // Styling explicitly for Store to look like an App Store
                container.style.display = 'grid';
                container.style.gridTemplateColumns = 'repeat(auto-fill, minmax(280px, 1fr))';
                container.style.gap = '20px';

                this.storePlugins
                    .filter(p => p.name.toLowerCase().includes(search) || p.description.toLowerCase().includes(search))
                    .forEach(p => {
                        const card = this.createStoreCard(p);
                        container.appendChild(card);
                    });
            }

            createCard(plugin, isInstalled) {
                const div = document.createElement('div');
                div.className = 'plugin-card';
                // Use a database ID or fallback to id field
                const pId = plugin.dbId || plugin.id;

                div.innerHTML = `
                    <div class="plugin-icon-area">
                        <img src="${plugin.icon || 'default_icon.png'}" class="plugin-icon-img" onerror="this.src='https://via.placeholder.com/50'">
                        <div class="plugin-info">
                            <div class="plugin-name">${plugin.name}</div>
                            <div class="plugin-author" style="display:flex; align-items:center; gap:4px;">
                                v${plugin.version} â€¢ ${plugin.author}
                                ${plugin.author === 'Axon Dev' && plugin.source === 'store' ? '<i class="fas fa-check-circle" style="color:var(--highlight-color); font-size:10px;" title="Verificado"></i>' : ''}
                            </div>
                        </div>
                    </div>
                    <div class="plugin-desc">${plugin.description || 'Sem descriÃ§Ã£o.'}</div>
                    <div class="plugin-actions">
                        <button class="plugin-btn btn-open-plugin" onclick="window.axonPluginManager.openPlugin('${pId}')"><i class="fas fa-play"></i> Abrir</button>
                        <button class="plugin-btn btn-uninstall" onclick="window.axonPluginManager.uninstallPlugin('${pId}')" title="Desinstalar"><i class="fas fa-trash"></i></button>
                    </div>
                `;
                return div;
            }

            createStoreCard(plugin) {
                const div = document.createElement('div');
                div.className = 'plugin-store-card';
                div.style.cssText = `
                    background: var(--glass-bg);
                    border: 1px solid var(--border-color);
                    border-radius: 12px;
                    padding: 20px;
                    display: flex;
                    flex-direction: column;
                    transition: transform 0.2s;
                `;
                div.onmouseover = () => div.style.transform = 'translateY(-2px)';
                div.onmouseout = () => div.style.transform = 'translateY(0)';

                const isAlreadyInstalled = this.plugins.some(p => p.id === plugin.id); // Simple check by internal ID

                div.innerHTML = `
                    <div style="display:flex; gap: 15px; margin-bottom: 15px;">
                        <img src="${plugin.icon}" style="width: 60px; height: 60px; border-radius: 12px; object-fit: cover; background: #fff;">
                        <div>
                            <div style="font-weight: bold; font-size: 16px; color: var(--text-color);">${plugin.name}</div>
                            <div style="font-size: 12px; opacity: 0.7; margin-top: 4px; display:flex; align-items:center; gap:5px;">
                                ${plugin.author}
                                ${plugin.author === 'Axon Dev' ? '<i class="fas fa-check-circle" style="color:var(--highlight-color);" title="Verificado"></i>' : ''}
                            </div>
                        </div>
                    </div>
                    <div style="font-size: 13px; color: var(--text-color); opacity: 0.8; margin-bottom: 20px; flex: 1; line-height: 1.4;">
                        ${plugin.description}
                    </div>
                    <button class="app-modal-button" 
                        onclick="window.axonPluginManager.installPlugin('${plugin.id}')"
                        style="width: 100%; ${isAlreadyInstalled ? 'background: var(--success-color); cursor: default;' : ''}"
                        ${isAlreadyInstalled ? 'disabled' : ''}>
                        ${isAlreadyInstalled ? '<i class="fas fa-check"></i> Instalado' : '<i class="fas fa-download"></i> Obter'}
                    </button>
                `;
                return div;
            }

            async installPlugin(storePluginId) {
                const plugin = this.storePlugins.find(p => p.id === storePluginId);
                if (!plugin) return;

                // Check for duplicates
                const isDupe = this.plugins.find(p => p.originalId === storePluginId || p.name === plugin.name);
                if (isDupe) {
                    showConfirmModal(
                        `O plugin "${plugin.name}" jÃ¡ estÃ¡ instalado. Deseja reinstalar? (Sua versÃ£o atual serÃ¡ substituÃ­da)`,
                        async () => {
                            // Reinstall Logic
                            appendOutput(`Reinstalando ${plugin.name}...`, "info");
                            // 1. Remove old
                            try {
                                await deleteDoc(doc(db, "users", currentUser, "files", isDupe.dbId));
                                this.plugins = this.plugins.filter(p => p.dbId !== isDupe.dbId);
                            } catch (err) {
                                console.warn("Erro ao limpar versÃ£o antiga:", err);
                            }
                            // 2. Proceed to install (call internal helper or just continue logic? Recursive call might hit this check again if state not updated? 
                            // Optimized: Just continue execution below? No, "return" blocks it.
                            // I'll extract install logic or allow flow to continue.
                            // Safest: Recursively call installPlugin but with a force flag? Or clearer:
                            // Let's manually trigger the install steps here.
                            this._performInstall(plugin);
                        },
                        true // isConfirm
                    );
                    return;
                }

                await this._performInstall(plugin);
            }

            async _performInstall(plugin) {
                // Optimization: Link to original file instead of re-uploading
                const storeIpfsHash = plugin.ipfsHash;
                let finalIpfsHash = storeIpfsHash;
                let finalPinataKey = plugin.pinataKey || 'shared';

                if (!finalIpfsHash) {
                    appendOutput(`Instalando ${plugin.name} na nuvem (Upload)...`, "info");
                    const jsonContent = JSON.stringify(plugin);
                    const blob = new Blob([jsonContent], { type: 'application/json' });
                    const file = new File([blob], plugin.name + ".json", { type: "application/json" });
                    try {
                        const res = await uploadToPinata(file);
                        finalIpfsHash = res.ipfsHash;
                        finalPinataKey = res.pinataKey;
                    } catch (e) {
                        appendOutput("Erro no upload: " + e.message, "error");
                        return;
                    }
                } else {
                    appendOutput(`Instalando ${plugin.name}...`, "info");
                }


                try {
                    // 3. Save reference to Firestore (Persist user registry)
                    // We use type 'axon_plugin' to distinguish from regular files
                    await addDoc(collection(db, "users", currentUser, "files"), {
                        name: plugin.name,
                        type: 'axon_plugin',
                        source: 'store', // Flag as store-installed
                        originalId: plugin.id,
                        icon: plugin.icon,
                        description: plugin.description,
                        author: plugin.author,
                        version: plugin.version,
                        createdAt: new Date(),
                        size: plugin.size || 0,
                        ipfsHash: finalIpfsHash,
                        pinataKey: finalPinataKey,
                        content: plugin.html
                    });

                    // Optimistic Update
                    const newPlugin = { ...plugin, dbId: 'temp_' + Date.now() };
                    if (!this.plugins.some(p => p.originalId === plugin.id)) {
                        this.plugins.push(newPlugin);
                    }
                    this.renderInstalled();

                    appendOutput("Plugin instalado e salvo com sucesso!", "success");
                    this.switchTab('installed');
                } catch (e) {
                    console.error(e);
                    appendOutput("Erro ao instalar plugin: " + e.message, "error");
                }
            }

            async uninstallPlugin(dbId) {
                showConfirmModal("Tem certeza que deseja remover este plugin?", async () => {
                    try {
                        await deleteDoc(doc(db, "users", currentUser, "files", dbId));
                        // Optimistic
                        this.plugins = this.plugins.filter(p => p.dbId !== dbId);
                        this.renderInstalled();
                        appendOutput("Plugin removido.", "success");
                    } catch (e) {
                        appendOutput("Erro ao remover: " + e.message, "error");
                    }
                });
            }

            async importFromFile() {
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = '.json';
                input.onchange = e => {
                    const file = e.target.files[0];
                    if (!file) return;

                    showConfirmModal(
                        `ATENÃ‡ÃƒO: VocÃª estÃ¡ importando um plugin externo ("${file.name}").\n\nPlugins externos podem executar cÃ³digo desconhecido e acessar seus dados.\n\nCertifique-se de que confia na fonte deste arquivo. Deseja continuar?`,
                        () => { this.processImport(file); }
                    );
                };
                input.click();
            }

            processImport(file) {
                const reader = new FileReader();
                reader.onload = async event => {
                    try {
                        const plugin = JSON.parse(event.target.result);
                        if (plugin.name && plugin.html) {
                            // Check for duplicates
                            const existing = this.plugins.find(p => p.name === plugin.name);
                            if (existing) {
                                appendOutput(`O plugin '${plugin.name}' jÃ¡ estÃ¡ instalado!`, "error");
                                return;
                            }

                            // Install it properly via Pinata
                            const blob = new Blob([JSON.stringify(plugin)], { type: 'application/json' });
                            const uploadFile = new File([blob], plugin.name + ".json", { type: "application/json" });

                            appendOutput("Importando e salvando plugin...", "info");
                            const uploadResult = await uploadToPinata(uploadFile);

                            const docData = {
                                name: plugin.name,
                                type: 'axon_plugin',
                                source: 'import', // Flag as imported
                                originalId: plugin.id || 'custom-' + Date.now(),
                                icon: plugin.icon || 'https://via.placeholder.com/50',
                                description: plugin.description || 'Plugin importado',
                                author: plugin.author || 'User',
                                version: plugin.version || '1.0',
                                createdAt: new Date(),
                                size: uploadFile.size,
                                ipfsHash: uploadResult.ipfsHash,
                                pinataKey: uploadResult.pinataKey,
                                content: plugin.html
                            };

                            await addDoc(collection(db, "users", currentUser, "files"), docData);

                            // Optimistic Update removed to prevent duplication (Firestore listener handles it)
                            // this.plugins.push({ ...docData, dbId: 'temp_imp_' + Date.now() });
                            this.renderInstalled();

                            this.switchTab('installed');
                            appendOutput("Plugin importado com sucesso.", "success");
                        } else {
                            throw new Error("Formato invÃ¡lido (requer name e html).");
                        }
                    } catch (err) {
                        appendOutput("Erro ao importar: " + err.message, "error");
                    }
                };
                reader.readAsText(file);
            }

            openPlugin(dbIdOrId) {
                // Find in loaded plugins
                // plugins array now has firestore data
                let plugin = this.plugins.find(p => p.dbId === dbIdOrId);

                // If not found (maybe manual ID passed?), try to find by original ID?
                if (!plugin) plugin = this.plugins.find(p => p.originalId === dbIdOrId);

                if (!plugin) return;

                document.getElementById('plugin-manager-modal').style.display = 'none';
                this.createFloatingWindow(plugin);
            }

            createFloatingWindow(plugin) {
                const id = 'win_' + Date.now();
                const win = document.createElement('div');
                win.className = 'floating-plugin-window';
                win.id = id;
                win.style.top = (100 + this.activeWindows.length * 20) + 'px';
                win.style.left = (100 + this.activeWindows.length * 20) + 'px';

                // Loading Screen Overlay
                const loadingId = 'loading_' + id;

                win.innerHTML = `
                    <div class="floating-header" id="${id}_header">
                        <div class="floating-title">
                            <img src="${plugin.icon}" style="width:16px;height:16px;"> ${plugin.name}
                        </div>
                        <div class="floating-controls">
                            <div class="float-btn minimize-btn" onclick="window.axonPluginManager.minimizeWindow('${id}')"></div>
                            <div class="float-btn close-btn" onclick="document.getElementById('${id}').remove()"></div>
                        </div>
                    </div>
                    <div class="floating-content" style="position:relative;">
                        <iframe class="floating-iframe" sandbox="allow-scripts allow-same-origin allow-forms allow-popups"></iframe>
                        <div id="${loadingId}" style="position:absolute;top:0;left:0;width:100%;height:100%;background:var(--bg-color);display:flex;flex-direction:column;align-items:center;justify-content:center;z-index:10;">
                            <i class="fas fa-spinner fa-spin" style="font-size:24px;color:var(--highlight-color);margin-bottom:10px;"></i>
                            <span style="font-size:12px;opacity:0.8;">Carregando Plugin...</span>
                        </div>
                    </div>
                `;

                document.body.appendChild(win);
                this.makeDraggable(win);

                const iframe = win.querySelector('iframe');
                const loadingOverlay = document.getElementById(loadingId);

                // Hide loading when iframe loads
                iframe.onload = () => {
                    setTimeout(() => {
                        loadingOverlay.style.opacity = '0';
                        setTimeout(() => loadingOverlay.style.display = 'none', 300);
                    }, 500); // Small delay for smooth effect
                };

                // Use the cached content if available, otherwise fetch from IPFS (not implemented in this snippet for simplicity, assuming content is cached)
                let htmlContent = plugin.content;
                // Inject the bridge script
                // We use postMessage, so we need to inject a helper script into the iframe to make it easier for developers?
                /*
                   We inject a script that defines window.AxonPluginBridge for backward compatibility 
                   or simply a helper that proxies to postMessage
                */
                const bridgeScript = `
                    <script>
                        window.AxonPluginBridge = {
                            sendToChat: (text) => window.parent.postMessage({ type: 'AXON_PLUGIN_MESSAGE', action: 'sendToChat', payload: text }, '*'),
                            getAnamnesis: () => { window.parent.postMessage({ type: 'AXON_PLUGIN_MESSAGE', action: 'getAnamnesis', reqId: Date.now() }, '*'); },
                            callAI: (prompt) => { window.parent.postMessage({ type: 'AXON_PLUGIN_MESSAGE', action: 'callAI', payload: prompt, reqId: Date.now() }, '*'); },
                            getAxonEyeResults: () => { window.parent.postMessage({ type: 'AXON_PLUGIN_MESSAGE', action: 'getAxonEyeResults', reqId: Date.now() }, '*'); },
                            getExamsResults: () => { window.parent.postMessage({ type: 'AXON_PLUGIN_MESSAGE', action: 'getExamsResults', reqId: Date.now() }, '*'); }
                        };
                    <\/script>
                `;

                // Fix: Properly inject the bridge script into the content
                htmlContent = bridgeScript + htmlContent;

                const blob = new Blob([htmlContent], { type: 'text/html' });
                iframe.src = URL.createObjectURL(blob);

                this.activeWindows.push(win);
            }

            makeDraggable(elmnt) {
                var pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
                const header = elmnt.querySelector('.floating-header');
                if (header) {
                    header.onmousedown = dragMouseDown;
                }

                function dragMouseDown(e) {
                    e = e || window.event;
                    e.preventDefault();
                    pos3 = e.clientX;
                    pos4 = e.clientY;
                    document.onmouseup = closeDragElement;
                    document.onmousemove = elementDrag;

                    // Simple Z-index mgmt
                    elmnt.style.zIndex = 1500;
                }

                function elementDrag(e) {
                    e = e || window.event;
                    e.preventDefault();
                    pos1 = pos3 - e.clientX;
                    pos2 = pos4 - e.clientY;
                    pos3 = e.clientX;
                    pos4 = e.clientY;
                    elmnt.style.top = (elmnt.offsetTop - pos2) + "px";
                    elmnt.style.left = (elmnt.offsetLeft - pos1) + "px";
                }

                function closeDragElement() {
                    document.onmouseup = null;
                    document.onmousemove = null;
                }
            }


            minimizeWindow(id) {
                const win = document.getElementById(id);
                if (!win) return;

                // Store original dimensions before hiding? 
                // Actually display:none might reset iframe state in some browsers, but usually just hides.
                // The "half screen" bug might be due to re-render issues.
                // Let's ensure we save the size? CSS handles it? 
                // If the bug is "half screen content" inside iframe, it's a resize event issue.
                // If it's "half window visible", it's a position issue.
                // Assuming content issue: force redraw on restore.

                win.style.display = 'none';

                // Add to HEADER (header-right) taskbar
                let taskbar = document.getElementById('plugin-taskbar-header');
                if (!taskbar) {
                    // Create it if not exists, look for header-right
                    const headerRight = document.querySelector('.header-right');
                    if (headerRight) {
                        taskbar = document.createElement('div');
                        taskbar.id = 'plugin-taskbar-header';
                        taskbar.style.cssText = 'display: flex; gap: 8px; margin-right: 15px; align-items: center;';
                        // Insert before the first child or search/theme buttons? 
                        // Let's insert at the beginning of header-right
                        headerRight.insertBefore(taskbar, headerRight.firstChild);
                    } else {
                        // Fallback to body or footer if header not found (unlikely)
                        console.warn("Header Right not found for taskbar");
                        return;
                    }
                }

                // Get icon from header
                const img = win.querySelector('.floating-header img');
                const iconSrc = img ? img.src : 'https://via.placeholder.com/20';
                const titleEl = win.querySelector('.floating-title');
                const title = titleEl ? titleEl.textContent.trim() : 'Plugin';

                const tab = document.createElement('div');
                tab.id = 'tab_' + id;
                // ROUNDED STYLE as requested
                tab.style.cssText = `
                    cursor: pointer; 
                    background: rgba(255, 255, 255, 0.1); 
                    padding: 5px 12px; 
                    border-radius: 20px; 
                    border: 1px solid rgba(255,255,255,0.2); 
                    display: flex; 
                    align-items: center; 
                    gap: 6px;
                    transition: all 0.2s;
                    backdrop-filter: blur(5px);
                `;
                tab.onmouseover = () => tab.style.background = 'rgba(255, 255, 255, 0.2)';
                tab.onmouseout = () => tab.style.background = 'rgba(255, 255, 255, 0.1)';

                tab.innerHTML = `<img src="${iconSrc}" style="width:16px;height:16px;border-radius:50%;"> <span style="font-size: 11px; color: var(--text-color);">${title}</span>`;
                tab.title = "Restaurar " + title;
                tab.onclick = () => this.restoreWindow(id);

                taskbar.appendChild(tab);
            }

            restoreWindow(id) {
                const win = document.getElementById(id);
                if (win) {
                    win.style.display = 'flex'; // Was 'block', flex matches css usually
                    // Force Layout Recalculation to fix text/half-screen glitches
                    // Trigger a resize event on the window to help iframe content adjust
                    window.dispatchEvent(new Event('resize'));

                    // Simple fix for "half screen" if it means the iframe didn't fill:
                    const container = win.querySelector('.floating-content');
                    if (container) {
                        container.style.display = 'none';
                        container.offsetHeight; // force reflow
                        container.style.display = 'flex'; // or block
                    }

                    // Bring to front
                    this.activeWindows.forEach(w => w.style.zIndex = 1000);
                    win.style.zIndex = 1500;
                }
                const tab = document.getElementById('tab_' + id);
                if (tab) tab.remove();
            }
        }

        // --- MESSAGE HANDLER FOR PLUGINS ---
        window.addEventListener('message', (event) => {
            if (event.data && event.data.type === 'AXON_PLUGIN_MESSAGE') {
                const { action, payload, reqId } = event.data;

                // PERMISSION CHECK
                if (globalSettings.bridgePermissions && globalSettings.bridgePermissions[action] === false) {
                    if (reqId) {
                        event.source.postMessage({
                            type: 'AXON_PLUGIN_RESPONSE',
                            reqId: reqId,
                            error: `PermissÃ£o negada para '${action}'. Admin desativou.`
                        }, '*');
                    }
                    appendOutput(`Plugin tentou usar '${action}' mas foi bloqueado.`, 'error');
                    return;
                }

                if (action === 'sendToChat') {
                    const input = document.getElementById('command-input');
                    const cmdInput = document.getElementById('command-input');
                    if (cmdInput) {
                        cmdInput.value = payload;
                        cmdInput.focus();
                        // Auto-submit via Enter key event
                        const enterEvent = new KeyboardEvent('keydown', {
                            bubbles: true, cancelable: true, keyCode: 13, key: 'Enter', code: 'Enter'
                        });
                        cmdInput.dispatchEvent(enterEvent);
                    }
                }

                // Add more handlers here (getAnamnesis, etc) if we implement two-way sync
                if (action === 'getAnamnesis') {
                    // Send back
                    if (event.source) {
                        event.source.postMessage({
                            type: 'AXON_PLUGIN_RESPONSE',
                            reqId: reqId,
                            data: typeof anamnesis !== 'undefined' ? anamnesis : {}
                        }, '*');
                    }
                }

                if (action === 'getAxonEyeResults') {
                    if (event.source) {
                        event.source.postMessage({
                            type: 'AXON_PLUGIN_RESPONSE',
                            reqId: reqId,
                            data: typeof axonEyeResults !== 'undefined' ? axonEyeResults : []
                        }, '*');
                    }
                }

                if (action === 'getExamsResults') {
                    if (event.source) {
                        // Assuming 'examsResults' or 'patientExams' is the global
                        // Using 'examsResults' as per plan, but falling back to empty
                        event.source.postMessage({
                            type: 'AXON_PLUGIN_RESPONSE',
                            reqId: reqId,
                            data: typeof examsResults !== 'undefined' ? examsResults : []
                        }, '*');
                    }
                }

                if (action === 'callAI') {
                    // Call Gemini API (or current provider)
                    if (event.source && payload) {
                        // Async operation, but we don't want to block the listener
                        callGeminiAPI(payload).then(response => {
                            event.source.postMessage({
                                type: 'AXON_PLUGIN_RESPONSE',
                                reqId: reqId,
                                data: response
                            }, '*');
                        }).catch(err => {
                            event.source.postMessage({
                                type: 'AXON_PLUGIN_RESPONSE',
                                reqId: reqId,
                                error: err.message,
                                data: "Erro ao consultar IA: " + err.message
                            }, '*');
                        });

                    }
                }

                if (action === 'storage') {
                    // payload: { content: string/blob, filename: string }
                    if (event.source && payload && payload.content && payload.filename) {
                        const blob = new Blob([payload.content]);
                        const file = new File([blob], payload.filename);

                        uploadToPinata(file).then(res => {
                            event.source.postMessage({
                                type: 'AXON_PLUGIN_RESPONSE',
                                reqId: reqId,
                                data: {
                                    success: true,
                                    ipfsHash: res.ipfsHash,
                                    gatewayUrl: `https://gateway.pinata.cloud/ipfs/${res.ipfsHash}`
                                }
                            }, '*');
                        }).catch(err => {
                            event.source.postMessage({
                                type: 'AXON_PLUGIN_RESPONSE',
                                reqId: reqId,
                                error: "Falha no upload: " + err.message
                            }, '*');
                        });
                    }
                }

                if (action === 'storageList') {
                    // List files from Firestore for current user
                    try {
                        const q = query(collection(db, "users", currentUser, "files"), orderBy("lastModified", "desc"));
                        getDocs(q).then(snapshot => {
                            const files = [];
                            snapshot.forEach(doc => {
                                files.push({ id: doc.id, ...doc.data() });
                            });
                            event.source.postMessage({
                                type: 'AXON_PLUGIN_RESPONSE',
                                reqId: reqId,
                                data: { success: true, files: files }
                            }, '*');
                        }).catch(e => {
                            event.source.postMessage({ type: 'AXON_PLUGIN_RESPONSE', reqId: reqId, error: e.message }, '*');
                        });
                    } catch (e) {
                        event.source.postMessage({ type: 'AXON_PLUGIN_RESPONSE', reqId: reqId, error: e.message }, '*');
                    }
                }

                if (action === 'storageRegister') {
                    // Register a file in Firestore (metadata only)
                    // payload: { name, ipfsHash, size, mimeType }
                    if (payload && payload.name && payload.ipfsHash) {
                        try {
                            const fileData = {
                                name: payload.name,
                                ipfsHash: payload.ipfsHash,
                                size: payload.size || 0,
                                type: payload.mimeType || 'application/octet-stream',
                                pinataKey: 'shared', // or specific if available
                                lastModified: new Date()
                            };
                            addDoc(collection(db, "users", currentUser, "files"), fileData).then(docRef => {
                                event.source.postMessage({
                                    type: 'AXON_PLUGIN_RESPONSE',
                                    reqId: reqId,
                                    data: { success: true, id: docRef.id }
                                }, '*');
                            }).catch(e => {
                                event.source.postMessage({ type: 'AXON_PLUGIN_RESPONSE', reqId: reqId, error: e.message }, '*');
                            });
                        } catch (e) {
                            event.source.postMessage({ type: 'AXON_PLUGIN_RESPONSE', reqId: reqId, error: e.message }, '*');
                        }
                    } else {
                        event.source.postMessage({ type: 'AXON_PLUGIN_RESPONSE', reqId: reqId, error: "Dados incompletos (name, ipfsHash obrigatÃ³rios)" }, '*');
                    }
                }
            }
        });

        window.axonPluginManager = new AxonPluginManager();

        // --- GLOBAL SETTINGS LISTENER (Real-time Sync) ---
        try {
            onSnapshot(doc(db, "settings", "global"), (docSnap) => {
                if (docSnap.exists()) {
                    const data = docSnap.data();

                    // Sync globalSettings object
                    if (typeof globalSettings !== 'undefined') {
                        globalSettings.showToolsButton = data.showToolsButton;
                        globalSettings.mobile2_0_enabled = data.mobile2_0_enabled;
                        globalSettings.showPrescriptionAssistant = data.showPrescriptionAssistant;
                    }

                    // Update Tools Button UI
                    const btnTools = document.getElementById('btn-tools');
                    if (btnTools) {
                        const show = data.showToolsButton !== false; // Default true
                        btnTools.style.display = show ? 'flex' : 'none';
                    }

                    // Update Admin Toggle UI if present (Real-time sync for other admins)
                    const toggleTools = document.getElementById('toggle-tools-btn-visibility');
                    if (toggleTools) {
                        toggleTools.checked = data.showToolsButton !== false;
                    }

                    // Update Prescription Assistant UI if present
                    const btnAssist = document.getElementById('btn-prescription-assist');
                    if (btnAssist && typeof data.showPrescriptionAssistant !== 'undefined') {
                        btnAssist.style.display = data.showPrescriptionAssistant ? 'flex' : 'none';
                    }
                }
            }, (error) => {
                console.warn("Error listening to global settings:", error);
            });
        } catch (e) {
            console.warn("Failed to setup global settings listener:", e);
        }

        // --- ADMIN PLUGIN MANAGEMENT ---
        window.adminUploadPlugin = async (input) => {
            if (!input.files || !input.files[0]) return;
            const file = input.files[0];
            const reader = new FileReader();
            reader.onload = async (e) => {
                try {
                    const decoder = new TextDecoder("utf-8");
                    const text = decoder.decode(e.target.result);
                    const pluginData = JSON.parse(text);

                    if (!pluginData.name || !pluginData.id || !pluginData.version) {
                        alert("JSON invÃ¡lido. Requer name, id e version.");
                        return;
                    }
                    appendOutput(`Enviando plugin ${pluginData.name} para Pinata...`, "info");

                    const uploadResult = await uploadToPinata(file);

                    const docData = {
                        id: pluginData.id,
                        name: pluginData.name,
                        description: pluginData.description || "",
                        version: pluginData.version,
                        author: pluginData.author || "Admin",
                        icon: pluginData.icon || "https://via.placeholder.com/150",
                        ipfsHash: uploadResult.ipfsHash,
                        pinataKey: uploadResult.pinataKey,
                        size: file.size,
                        createdAt: new Date(),
                        updatedAt: new Date(),
                        html: pluginData.html || ""
                    };

                    await addDoc(collection(db, "axon_store_plugins"), docData);

                    appendOutput(`Plugin ${pluginData.name} publicado na Store!`, "success");
                    alert("Plugin publicado com sucesso!");
                    input.value = ''; // Reset input
                } catch (err) {
                    console.error(err);
                    alert("Erro ao processar plugin: " + err.message);
                }
            };
            reader.readAsArrayBuffer(file);
        };

        window.deleteStorePlugin = async (docId) => {
            if (!confirm("Tem certeza que deseja apagar este plugin da Loja?")) return;
            try {
                await deleteDoc(doc(db, "axon_store_plugins", docId));
                alert("Plugin removido.");
            } catch (e) {
                alert("Erro: " + e.message);
            }
        };

        let unsubscribeAdminPlugins = null;
        window.downloadStorePlugin = async (ipfsHash, name) => {
            if (!ipfsHash) { alert("Hash IPFS nÃ£o encontrado."); return; }
            try {
                const url = `https://gateway.pinata.cloud/ipfs/${ipfsHash}`;
                const res = await fetch(url);
                if (!res.ok) throw new Error("Falha no download");
                const blob = await res.blob();
                const dUrl = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = dUrl;
                a.download = (name || 'plugin') + ".json";
                document.body.appendChild(a);
                a.click();
                a.remove();
                window.URL.revokeObjectURL(dUrl);
            } catch (e) {
                alert("Erro ao baixar: " + e.message);
            }
        };

        const initAdminPluginsListener = () => {
            if (unsubscribeAdminPlugins) return; // Already listening
            const listContainer = document.getElementById('admin-plugins-list');
            if (!listContainer) return;

            unsubscribeAdminPlugins = onSnapshot(collection(db, "axon_store_plugins"), (snapshot) => {
                if (snapshot.empty) {
                    listContainer.innerHTML = '<div style="padding:10px;text-align:center;opacity:0.5;">Nenhum plugin na loja.</div>';
                    return;
                }

                listContainer.innerHTML = '';
                snapshot.forEach(docSnap => {
                    const p = docSnap.data();
                    const el = document.createElement('div'); // Using default div, style with css class
                    el.className = 'pinata-file-row';
                    el.innerHTML = `
                        <div style="display:flex; align-items:center; gap:10px;">
                            <img src="${p.icon}" style="width:24px;height:24px;border-radius:4px;object-fit:cover;">
                            <div>
                                <div style="font-weight:bold;font-size:13px;">${p.name} <span style="font-weight:normal;opacity:0.7;font-size:11px;">v${p.version}</span></div>
                                <div style="font-size:10px;opacity:0.6;">ID: ${p.id}</div>
                            </div>
                        </div>
                        <div style="display:flex; gap:5px;">
                             <button class="patient-action-button" style="padding:4px 8px; width:auto; background: var(--button-bg);" onclick="window.downloadStorePlugin('${p.ipfsHash}', '${p.name}')" title="Baixar JSON">
                                <i class="fas fa-download"></i>
                             </button>
                             <button class="patient-action-button delete" style="padding:4px 8px; width:auto;" onclick="window.deleteStorePlugin('${docSnap.id}')" title="Remover da Loja">
                                <i class="fas fa-trash"></i>
                             </button>
                        </div>
                    `;
                    listContainer.appendChild(el);
                });
            });
        };

        // Hook into Admin Tab Switching
        document.addEventListener('click', (e) => {
            if (e.target.classList.contains('admin-tab-btn')) {
                const tab = e.target.dataset.tab;
                if (tab === 'bridge') {
                    setTimeout(initAdminPluginsListener, 100);
                } else {
                    if (unsubscribeAdminPlugins) {
                        unsubscribeAdminPlugins();
                        unsubscribeAdminPlugins = null;
                    }
                }
            }
        });

        document.addEventListener('DOMContentLoaded', () => {
            if (typeof initApp === 'function') {
                // Wait a bit for auth
                setTimeout(() => window.axonPluginManager.init(), 2000);
            }
        });


        // --- Free Mode (Board) Implementation ---
        const btnFreeMode = document.getElementById('btn-free-mode');
        const freeModeBoard = document.getElementById('free-mode-board');


        const textareaFreeMode = document.getElementById('free-mode-textarea');
        const btnProcessFreeMode = document.getElementById('btn-process-free-mode');
        const inputLine = document.querySelector('.input-line');
        let isFreeMode = false;

        if (btnFreeMode && freeModeBoard && interactiveOutput && textareaFreeMode) {
            const updateFreeModeUI = (active) => {
                isFreeMode = active;
                if (isFreeMode) {
                    interactiveOutput.style.display = 'none';
                    if (inputLine) inputLine.style.display = 'none';
                    freeModeBoard.style.display = 'flex';
                    textareaFreeMode.focus();
                    btnFreeMode.style.color = 'var(--highlight-color)';
                    btnFreeMode.innerHTML = '<i class="fas fa-terminal"></i>';
                    btnFreeMode.title = "Voltar ao Terminal";
                } else {
                    interactiveOutput.style.display = 'block';
                    if (inputLine) inputLine.style.display = 'flex';
                    freeModeBoard.style.display = 'none';
                    btnFreeMode.style.color = '';
                    btnFreeMode.innerHTML = '<i class="fas fa-edit"></i>';
                    btnFreeMode.title = "Modo Livre";
                }
            };

            btnFreeMode.addEventListener('click', () => updateFreeModeUI(!isFreeMode));

            // Auto-close listeners
            ['btn-hd', 'btn-cd', 'btn-mic'].forEach(id => {
                const btn = document.getElementById(id);
                if (btn) btn.addEventListener('click', () => {
                    if (isFreeMode) updateFreeModeUI(false);
                });
            });

            // Persistence
            let saveTimeout;
            const saveFreeModeText = (text) => {
                localStorage.setItem('axon_free_mode_text', text);
                if (saveTimeout) clearTimeout(saveTimeout);
                saveTimeout = setTimeout(async () => {
                    if (currentUser && typeof setDoc !== 'undefined' && typeof doc !== 'undefined' && typeof db !== 'undefined') {
                        try {
                            await setDoc(doc(db, "users", currentUser.uid), {
                                freeModeText: text,
                                lastUpdate: new Date().toISOString()
                            }, { merge: true });
                        } catch (e) {
                            console.error("Erro saving Free Mode:", e);
                        }
                    }
                }, 2000); // 2s Debounce
            };

            textareaFreeMode.addEventListener('input', (e) => {
                saveFreeModeText(e.target.value);
            });

            // AI Processing
            btnProcessFreeMode.addEventListener('click', async () => {
                const text = textareaFreeMode.value.trim();
                if (!text) {
                    // Visual shake or feedback needed? alert is annoying.
                    const originalText = btnProcessFreeMode.innerHTML;
                    btnProcessFreeMode.innerHTML = '<i class="fas fa-exclamation-circle"></i> Vazio!';
                    setTimeout(() => btnProcessFreeMode.innerHTML = originalText, 1500);
                    return;
                }

                // Visual feedback
                const originalText = btnProcessFreeMode.innerHTML;
                const originalBg = btnProcessFreeMode.style.background;
                btnProcessFreeMode.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Processando...';
                btnProcessFreeMode.disabled = true;
                btnProcessFreeMode.style.cursor = 'wait';

                try {
                    // Call existing AI function
                    await processAnamnesisInfo(`
                    [MODO LIVRE - INPUT DO MÃ‰DICO]
                    O mÃ©dico digitou as seguintes informaÃ§Ãµes livremente no quadro:
                    "${text}"
                    
                    Por favor, extraia e atualize a anamnese.
                    `);

                    // Success Feedback
                    btnProcessFreeMode.innerHTML = '<i class="fas fa-check"></i> Enviado!';
                    btnProcessFreeMode.style.background = 'var(--success-color)';
                    setTimeout(() => {
                        btnProcessFreeMode.innerHTML = originalText;
                        btnProcessFreeMode.disabled = false;
                        btnProcessFreeMode.style.background = originalBg;
                        btnProcessFreeMode.style.cursor = 'pointer';
                    }, 2000);

                } catch (e) {
                    // Error Feedback
                    btnProcessFreeMode.innerHTML = '<i class="fas fa-times"></i> Erro';
                    btnProcessFreeMode.style.background = 'var(--error-color)';
                    console.error(e);
                    setTimeout(() => {
                        btnProcessFreeMode.innerHTML = originalText;
                        btnProcessFreeMode.disabled = false;
                        btnProcessFreeMode.style.background = originalBg;
                        btnProcessFreeMode.style.cursor = 'pointer';
                    }, 2000);
                }
            });

            // Load Data
            window.loadFreeModeData = async () => {
                const local = localStorage.getItem('axon_free_mode_text');
                if (local) textareaFreeMode.value = local;

                if (currentUser && typeof getDoc !== 'undefined' && typeof doc !== 'undefined' && typeof db !== 'undefined') {
                    try {
                        const snap = await getDoc(doc(db, "users", currentUser.uid));
                        if (snap.exists()) {
                            const data = snap.data();
                            // Load if server has data. Assuming server sync is key.
                            // If local is empty, use server.
                            // If both, prioritizing server for cross-device persistence as requested.
                            if (data.freeModeText) {
                                textareaFreeMode.value = data.freeModeText;
                                localStorage.setItem('axon_free_mode_text', data.freeModeText);
                            }
                        }
                    } catch (e) { console.error(e); }
                }
            };

            // Clear Data
            window.clearFreeModeData = async () => {
                textareaFreeMode.value = '';
                localStorage.removeItem('axon_free_mode_text');
                if (currentUser && typeof updateDoc !== 'undefined' && typeof deleteField !== 'undefined' && typeof doc !== 'undefined' && typeof db !== 'undefined') {
                    try {
                        await updateDoc(doc(db, "users", currentUser.uid), { freeModeText: deleteField() });
                    } catch (e) { console.error(e); }
                }
            };
        }

        document.addEventListener('DOMContentLoaded', initApp);</script>
    <!-- PRESCRIPTION ASSISTANT MODAL -->
    <div id="prescription-modal" class="app-modal">
        <div class="app-modal-content" style="max-width: 800px; width: 90%;">
            <span class="app-modal-close"
                onclick="document.getElementById('prescription-modal').style.display='none'">&times;</span>
            <div class="app-modal-header">
                <h2 class="app-modal-title"><i class="fas fa-file-prescription"></i> Assistente de PrescriÃ§Ã£o <span
                        class="badge-beta"
                        style="font-size: 10px; background: var(--highlight-color); color: #fff; font-weight: 800; padding: 2px 5px; border-radius: 4px; vertical-align: middle; margin-left: 5px;">BETA</span>
                </h2>
            </div>
            <div class="app-modal-body">
                <div class="prescription-row">
                    <div style="flex: 2.5;">
                        <div class="prescription-form-group">
                            <label>DoenÃ§a ou MedicaÃ§Ã£o</label>
                            <input type="text" id="presc-input" class="app-modal-input compact-input"
                                placeholder="Ex: Cefaleia">
                        </div>
                    </div>
                    <div style="flex: 1;">
                        <div class="prescription-form-group">
                            <label>Idade</label>
                            <input type="text" id="presc-age" class="app-modal-input compact-input" placeholder="Anos">
                        </div>
                    </div>
                    <div style="flex: 1;">
                        <div class="prescription-form-group">
                            <label>Peso</label>
                            <input type="text" id="presc-weight" class="app-modal-input compact-input" placeholder="Kg">
                        </div>
                    </div>
                </div>

                <div class="prescription-options"
                    style="padding: 5px; margin-bottom: 10px; display: flex; gap: 15px; align-items: center;">
                    <label class="radio-label" style="font-size: 13px;">
                        <input type="radio" name="presc-source" value="sus" checked> Apenas SUS
                    </label>
                    <label class="radio-label" style="font-size: 13px;">
                        <input type="radio" name="presc-source" value="all"> Todas (GenÃ©ricos/Ref)
                    </label>
                </div>

                <button id="btn-generate-prescription" class="app-modal-button"
                    style="width: 100%; margin-bottom: 10px; padding: 10px;">
                    <i class="fas fa-magic"></i> Gerar PrescriÃ§Ã£o
                </button>

                <div id="presc-result-area" style="display: none;">
                    <div class="prescription-form-group">
                        <label>SugestÃµes de Receita</label>
                        <div id="presc-list-container" class="prescription-result-container">
                            <!-- List will be injected here -->
                        </div>
                    </div>

                </div>
            </div>
        </div>
    </div>
    </div>

    <!-- INFO MODAL -->
    <div id="med-info-modal" class="app-modal" style="z-index: 9500;">
        <div class="app-modal-content" style="max-width: 600px;">
            <span class="app-modal-close"
                onclick="document.getElementById('med-info-modal').style.display='none'">&times;</span>
            <div class="app-modal-header">
                <h2 class="app-modal-title">Detalhes e Alertas</h2>
            </div>
            <div class="app-modal-body" id="med-info-body" style="text-align: left; line-height: 1.6;"></div>
        </div>
    </div>

    <!-- AXON PLUGIN MANAGER MODAL -->
    <div id="plugin-manager-modal" class="app-modal" style="z-index: 9999;">
        <div class="app-modal-content"
            style="max-width: 900px; width: 95%; height: 80vh; display: flex; flex-direction: column; padding: 0;">
            <div
                style="padding: 15px 20px; border-bottom: 1px solid var(--border-color); display: flex; justify-content: space-between; align-items: center; background: var(--glass-bg);">
                <div
                    style="font-size: 18px; font-weight: bold; color: var(--header-text-color); display: flex; align-items: center; gap: 10px;">
                    <i class="fas fa-cubes"></i> Gerenciador de Plugins Axon
                </div>
                <span class="app-modal-close" style="position: static;"
                    onclick="document.getElementById('plugin-manager-modal').style.display='none'">&times;</span>
            </div>

            <div style="display: flex; border-bottom: 1px solid var(--border-color); background: rgba(0,0,0,0.02);">
                <div id="tab-installed-plugins" class="plugin-tab active"
                    onclick="window.axonPluginManager.switchTab('installed')"
                    style="padding: 12px 20px; cursor: pointer; font-weight: 600; border-bottom: 2px solid transparent; transition: all 0.2s;">
                    <i class="fas fa-check-circle"></i> Instalados
                </div>
                <div id="tab-axon-store" class="plugin-tab" onclick="window.axonPluginManager.switchTab('store')"
                    style="padding: 12px 20px; cursor: pointer; font-weight: 600; border-bottom: 2px solid transparent; transition: all 0.2s;">
                    <i class="fas fa-shopping-bag"></i> Axon Store
                </div>
            </div>

            <div style="flex: 1; overflow-y: auto; padding: 20px; position: relative;">

                <!-- view: Installed -->
                <div id="view-installed-plugins">
                    <div id="installed-plugins-toolbar" class="installed-toolbar"
                        style="margin-bottom:15px; display:flex; justify-content:flex-end;">
                        <!-- Injected via JS or static -->
                    </div>
                    <div id="installed-plugins-list" class="plugin-grid"
                        style="display: grid; grid-template-columns: repeat(auto-fill, minmax(280px, 1fr)); gap: 20px;">
                        <!-- Cards go here -->
                    </div>
                    <div id="no-plugins-msg"
                        style="display:none; text-align:center; padding: 40px; color: var(--text-color); opacity: 0.6;">
                        <i class="fas fa-box-open" style="font-size: 40px; margin-bottom: 10px;"></i><br>
                        Nenhum plugin instalado.
                    </div>
                </div>

                <!-- view: Store -->
                <div id="view-axon-store" style="display: none;">
                    <div style="margin-bottom: 20px; display: flex; gap: 10px;">
                        <div style="flex: 1; position: relative;">
                            <i class="fas fa-search"
                                style="position: absolute; left: 12px; top: 50%; transform: translateY(-50%); color: var(--text-color); opacity: 0.5;"></i>
                            <input type="text" id="store-search" placeholder="Buscar plugins..."
                                style="width: 100%; padding: 10px 10px 10px 35px; border-radius: 8px; border: 1px solid var(--border-color); background: var(--input-bg); color: var(--text-color);"
                                onkeyup="window.axonPluginManager.renderStore()">
                        </div>
                    </div>
                    <div id="store-plugins-list">
                        <!-- Store Cards go here -->
                    </div>
                </div>

            </div>
        </div>
    </div>
    <script>
        // Real-time listener for Global Settings (Tools Button Visibility)
        document.addEventListener('DOMContentLoaded', () => {
            // Ensure db is initialized (it is in main script, but this runs after)
            // We need to wait for Firebase/DB to be ready if it's async? 
            // Usually it's synchronous ref creation.
            // We'll wrap in a check or timeout, or just run it since this is at the end of body.

            if (typeof onSnapshot !== 'undefined' && typeof doc !== 'undefined' && typeof db !== 'undefined') {
                onSnapshot(doc(db, "settings", "global"), (docSnap) => {
                    if (docSnap.exists()) {
                        const data = docSnap.data();

                        // Sync globalSettings object
                        if (typeof globalSettings !== 'undefined') {
                            globalSettings.showToolsButton = data.showToolsButton;
                            globalSettings.mobile2_0_enabled = data.mobile2_0_enabled;
                            globalSettings.showPrescriptionAssistant = data.showPrescriptionAssistant;
                        }

                        // Update Tools Button UI
                        const btnTools = document.getElementById('btn-tools');
                        if (btnTools) {
                            const show = data.showToolsButton !== false; // Default true
                            btnTools.style.display = show ? 'flex' : 'none';
                        }

                        // Update Admin Toggle UI if present (Real-time sync for other admins)
                        const toggleTools = document.getElementById('toggle-tools-btn-visibility');
                        if (toggleTools) {
                            toggleTools.checked = data.showToolsButton !== false;
                        }
                    }
                }, (error) => {
                    console.warn("Error listening to global settings:", error);
                });
            }
        });
    </script>
</body>

</html>
